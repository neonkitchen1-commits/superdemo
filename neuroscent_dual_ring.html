<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
    <title>NeuroScent - Core Fixed</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=EB+Garamond:wght@400;500&family=Inter:wght@300;400;500;600&family=Noto+Sans+SC:wght@300;400;500&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        :root {
            --bg: #f5f5f0;
            --fg: #2a2a2a;
            --gray: #e0e0e0;
            --accent: #c02625;
            --green-hit: #00cc00;
            --red-miss: #dd0000;
        }
        
        body { 
            font-family: 'Inter', -apple-system, sans-serif;
            background: var(--bg);
            color: var(--fg);
            overflow: hidden;
            cursor: none;
            -webkit-font-smoothing: antialiased;
        }
        
        @media (pointer: coarse) {
            body { cursor: auto; }
            #cursor { display: none; }
        }
        
        .serif { font-family: 'EB Garamond', serif; }
        .zh { font-family: 'Noto Sans SC', sans-serif; font-weight: 300; }
        
        #cursor {
            width: 6px;
            height: 6px;
            background: var(--accent);
            border-radius: 50%;
            position: fixed;
            pointer-events: none;
            z-index: 10000;
            transition: transform 0.12s ease;
            box-shadow: 0 0 10px var(--accent);
        }
        #cursor.active { transform: scale(2.5); }
        
        #canvas3d {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
            transition: filter 0.5s ease;
        }
        
        #canvas3d.bloom {
            filter: blur(2px) brightness(1.3);
        }
        
        #ui-layer {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
        }
        #ui-layer > * { 
            pointer-events: auto; 
        }
        
        .screen {
            position: absolute;
            width: 100%;
            height: 100%;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.6s ease, visibility 0.6s;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
            pointer-events: none;
        }
        .screen.active { 
            opacity: 1; 
            visibility: visible;
            pointer-events: auto;
            z-index: 10;
        }
        
        #lang-switch {
            position: fixed;
            top: 1rem;
            right: 1rem;
            z-index: 100;
            display: flex;
            gap: 1px;
            background: var(--gray);
        }
        
        @media (max-width: 768px) {
            #lang-switch {
                top: 0.75rem;
                right: 0.75rem;
            }
        }
        
        .lang-btn {
            background: transparent;
            border: none;
            color: var(--fg);
            padding: 0.4rem 0.8rem;
            cursor: pointer;
            font-size: 0.65rem;
            letter-spacing: 0.1em;
            transition: all 0.3s;
            font-weight: 500;
        }
        .lang-btn.active {
            background: var(--accent);
            color: var(--bg);
        }
        
        #welcome-screen {
            flex-direction: column;
            padding: 2rem 1rem;
            pointer-events: auto;
        }
        
        .welcome-logo {
            font-size: clamp(2.5rem, 12vw, 8rem);
            font-weight: 400;
            letter-spacing: 0.02em;
            color: var(--fg);
            margin-bottom: 0.5rem;
            line-height: 0.95;
            text-shadow: 0 0 30px rgba(192, 38, 37, 0.3);
        }
        
        .welcome-subtitle {
            font-size: clamp(0.7rem, 1.8vw, 0.95rem);
            color: rgba(42, 42, 42, 0.6);
            letter-spacing: 0.08em;
            margin-bottom: 3rem;
            text-transform: uppercase;
            font-weight: 300;
            text-align: center;
        }
        
        .btn {
            background: transparent;
            border: 1px solid var(--fg);
            color: var(--fg);
            padding: 0.9rem 2rem;
            font-size: 0.7rem;
            letter-spacing: 0.2em;
            cursor: pointer;
            transition: all 0.4s;
            text-transform: uppercase;
            font-weight: 400;
            pointer-events: auto;
        }
        .btn:hover, .btn:active {
            background: var(--fg);
            color: var(--bg);
            box-shadow: 0 0 20px rgba(42, 42, 42, 0.2);
        }
        .btn.accent {
            border-color: var(--accent);
            color: var(--accent);
        }
        .btn.accent:hover, .btn.accent:active {
            background: var(--accent);
            color: var(--bg);
            box-shadow: 0 0 20px rgba(192, 38, 37, 0.3);
        }
        
        @media (max-width: 768px) {
            .btn {
                padding: 1rem 2rem;
                font-size: 0.75rem;
            }
        }
        
        .info-container {
            max-width: 520px;
            width: 90%;
            padding: 3rem 2rem;
            position: relative;
            background: rgba(255, 255, 255, 0.95);
            box-shadow: 0 0 50px rgba(192, 38, 37, 0.15);
            border: 1px solid rgba(192, 38, 37, 0.2);
            pointer-events: auto;
        }
        
        .info-container::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 2px;
            background: linear-gradient(90deg, transparent, var(--accent), transparent);
            pointer-events: none;
        }
        
        .info-container::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 2px;
            background: linear-gradient(90deg, transparent, var(--accent), transparent);
            pointer-events: none;
        }
        
        @media (max-width: 768px) {
            .info-container {
                width: 95%;
                padding: 2rem 1.5rem;
            }
        }
        
        .form-title {
            font-size: clamp(1.8rem, 6vw, 2.8rem);
            margin-bottom: 3rem;
            letter-spacing: 0.02em;
            font-weight: 400;
            text-align: center;
            position: relative;
            color: var(--fg);
            pointer-events: none;
        }
        
        .form-title::after {
            content: '';
            position: absolute;
            bottom: -1rem;
            left: 50%;
            transform: translateX(-50%);
            width: 60px;
            height: 1px;
            background: var(--accent);
            box-shadow: 0 0 10px var(--accent);
            pointer-events: none;
        }
        
        .form-field {
            margin-bottom: 2.5rem;
            position: relative;
            pointer-events: auto;
        }
        
        .form-field label {
            display: block;
            font-size: 0.65rem;
            color: rgba(42, 42, 42, 0.7);
            margin-bottom: 0.8rem;
            letter-spacing: 0.15em;
            text-transform: uppercase;
            font-weight: 500;
            pointer-events: none;
        }
        
        .form-field input,
        .form-field select {
            width: 100%;
            background: rgba(255, 255, 255, 0.9);
            border: none;
            border-bottom: 1px solid rgba(192, 38, 37, 0.3);
            color: var(--fg);
            padding: 1rem 0;
            font-size: 1.1rem;
            font-family: 'Inter', sans-serif;
            font-weight: 300;
            transition: border-color 0.3s, box-shadow 0.3s;
            -webkit-appearance: none;
            appearance: none;
            border-radius: 0;
            pointer-events: auto;
        }
        
        .form-field input {
            cursor: text;
        }
        
        .form-field select {
            cursor: pointer;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath fill='%232a2a2a' d='M6 9L1 4h10z'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right center;
            padding-right: 2rem;
        }
        
        .form-field input:focus,
        .form-field select:focus {
            outline: none;
            border-bottom-color: var(--accent);
            box-shadow: 0 2px 10px rgba(192, 38, 37, 0.2);
        }
        
        .form-field input::placeholder {
            color: rgba(42, 42, 42, 0.4);
            font-weight: 300;
        }

        #scent-screen {
            flex-direction: column;
            padding: 1.5rem 1rem;
            overflow: hidden;
            align-items: stretch;
        }
        
        @media (max-width: 768px) {
            #scent-screen {
                padding: 1rem 0.5rem;
            }
            .lumen-name { font-size: 0.9rem; letter-spacing: 0.05em; }
            .lumen-value { font-size: 1.5rem; }
        }
        
        .scent-header {
            text-align: center;
            margin-bottom: 1rem;
            flex-shrink: 0;
        }
        
        @media (max-width: 768px) {
            .scent-header {
                margin-bottom: 0.75rem;
            }
        }
        
        .scent-header h2 {
            font-size: clamp(1.5rem, 6vw, 2.5rem);
            font-weight: 400;
            margin-bottom: 0.5rem;
            letter-spacing: 0.02em;
            text-shadow: 0 0 20px rgba(192, 38, 37, 0.2);
        }

        .scent-intro-box {
            font-size: clamp(0.7rem, 2vw, 0.85rem);
            line-height: 1.6;
            color: rgba(42, 42, 42, 0.75);
            width: 100%;
            margin: 1.5rem auto 0;
            padding: 1.2rem 1.5rem;
            border-left: 2px solid var(--accent);
            text-align: left;
            white-space: pre-wrap;
            background: rgba(192, 38, 37, 0.08);
            flex-shrink: 0;
        }
        
        @media (max-width: 768px) {
            .scent-intro-box {
                font-size: 0.7rem;
                padding: 1rem 1.2rem;
                margin: 1rem auto 0;
            }
        }
        
        .scent-header p {
            font-size: clamp(0.7rem, 2vw, 0.85rem);
            color: rgba(42, 42, 42, 0.6);
            letter-spacing: 0.05em;
        }
        
        #scent-pages {
            position: relative;
            width: 100%;
            max-width: 600px;
            flex: 1;
            margin: 0 auto 1rem;
            overflow: hidden;
            min-height: 500px;
        }
        
        @media (max-width: 768px) {
            #scent-pages {
                min-height: 550px;
            }
        }
        
        .scent-page {
            position: absolute;
            width: 100%;
            height: 100%;
            opacity: 0;
            visibility: hidden;
            transform: translateX(100%);
            transition: all 0.6s cubic-bezier(0.4, 0, 0.2, 1);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            padding: 2rem 1rem 1rem;
            overflow-y: auto;
        }
        
        @media (max-width: 768px) {
            .scent-page {
                padding: 1.5rem 0.75rem 0.75rem;
            }
        }
        
        .scent-page.active {
            opacity: 1;
            visibility: visible;
            transform: translateX(0);
        }
        
        .scent-page.prev {
            transform: translateX(-100%);
        }
        
        .lumen-label {
            text-align: center;
            pointer-events: none;
            margin-top: 1rem;
            padding: 0 1rem;
            flex-shrink: 0;
        }
        
        .lumen-instruction {
            font-size: 0.7rem;
            color: rgba(42, 42, 42, 0.6);
            margin-top: 0.8rem;
            text-align: center;
            line-height: 1.4;
        }
        
        .lumen-name {
            font-size: clamp(0.9rem, 3vw, 1.1rem);
            font-weight: 400;
            margin-bottom: 0.5rem;
            letter-spacing: 0.08em;
            text-transform: uppercase;
        }
        
        .lumen-value {
            font-size: clamp(1.8rem, 7vw, 2.5rem);
            color: var(--accent);
            font-weight: 500;
            opacity: 0.9;
            text-shadow: 0 0 10px rgba(192, 38, 37, 0.3);
            margin-bottom: 0.3rem;
        }
        
        .scent-pagination {
            display: flex;
            justify-content: center;
            gap: 0.8rem;
            margin: 0.75rem 0;
            flex-shrink: 0;
        }
        
        .page-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: rgba(42, 42, 42, 0.3);
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .page-dot.active {
            background: var(--accent);
            transform: scale(1.3);
            box-shadow: 0 0 10px var(--accent);
        }
        
        .scent-controls {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 1rem;
            flex-wrap: wrap;
            padding: 1rem 1rem 1.5rem;
            flex-shrink: 0;
        }
        
        @media (max-width: 768px) {
            .scent-controls {
                gap: 0.5rem;
                padding: 0.75rem 0.5rem 1rem;
            }
            .scent-controls .btn {
                padding: 0.8rem 1.5rem;
                font-size: 0.65rem;
            }
        }
        
        #module-selection-screen {
            padding: 2rem 1rem;
            align-items: flex-start;
        }
        
        @media (max-width: 768px) {
            #module-selection-screen {
                padding: 1.5rem 0.5rem;
            }
        }
        
        .module-wrapper {
            width: 100%;
            max-width: 1100px;
            margin: 0 auto;
        }
        
        .module-header {
            text-align: center;
            margin-bottom: 2rem;
        }
        
        .module-header h2 {
            font-size: clamp(1.5rem, 6vw, 2.5rem);
            font-weight: 400;
            margin-bottom: 1.5rem;
            letter-spacing: 0.02em;
            text-shadow: 0 0 20px rgba(192, 38, 37, 0.2);
        }
        
        .difficulty-control {
            max-width: 450px;
            margin: 0 auto 2.5rem;
            padding: 1.5rem 1.5rem;
            background: rgba(192, 38, 37, 0.08);
            border-radius: 2px;
            border: 1px solid rgba(192, 38, 37, 0.2);
        }
        
        @media (max-width: 768px) {
            .difficulty-control {
                padding: 1.2rem 1rem;
                margin-bottom: 2rem;
            }
        }
        
        .difficulty-control label {
            display: block;
            font-size: 0.65rem;
            color: rgba(42, 42, 42, 0.7);
            letter-spacing: 0.1em;
            text-transform: uppercase;
            font-weight: 500;
            margin-bottom: 0.3rem;
        }
        
        .difficulty-desc {
            font-size: 0.6rem;
            color: rgba(42, 42, 42, 0.6);
            margin-bottom: 1rem;
            line-height: 1.4;
        }
        
        .slider-container {
            display: flex;
            align-items: center;
            gap: 1rem;
        }
        
        .difficulty-slider {
            flex: 1;
            height: 2px;
            background: var(--gray);
            -webkit-appearance: none;
            appearance: none;
            outline: none;
            cursor: pointer;
        }
        
        .difficulty-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            background: var(--accent);
            cursor: pointer;
            border-radius: 50%;
            box-shadow: 0 0 10px var(--accent);
        }
        
        .difficulty-slider::-moz-range-thumb {
            width: 18px;
            height: 18px;
            background: var(--accent);
            cursor: pointer;
            border: none;
            border-radius: 50%;
            box-shadow: 0 0 10px var(--accent);
        }
        
        .difficulty-value {
            font-size: 1.2rem;
            color: var(--accent);
            font-weight: 500;
            min-width: 3rem;
            text-align: right;
            text-shadow: 0 0 10px rgba(192, 38, 37, 0.3);
        }
        
        .module-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(min(260px, 100%), 1fr));
            gap: 0;
            border: 1px solid rgba(192, 38, 37, 0.2);
            background: var(--bg);
            margin-bottom: 2rem;
        }
        
        @media (max-width: 580px) {
            .module-grid {
                grid-template-columns: 1fr;
            }
        }
        
        .module-cell {
            background: rgba(255, 255, 255, 0.9);
            padding: 2rem 1.5rem;
            cursor: pointer;
            transition: all 0.3s;
            position: relative;
            min-height: 160px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            border-right: 1px solid rgba(192, 38, 37, 0.2);
            border-bottom: 1px solid rgba(192, 38, 37, 0.2);
        }
        
        @media (min-width: 1100px) {
             .module-grid { grid-template-columns: repeat(3, 1fr); }
             .module-cell:nth-child(3n) { border-right: none; }
        }
        @media (min-width: 581px) and (max-width: 1099px) {
             .module-grid { grid-template-columns: repeat(2, 1fr); }
             .module-cell:nth-child(2n) { border-right: none; }
        }
        
        @media (max-width: 580px) {
            .module-cell {
                border-right: none;
                padding: 1.8rem 1.2rem;
            }
        }
        
        .module-cell:hover, .module-cell:active {
            background: rgba(192, 38, 37, 0.15);
            box-shadow: inset 0 0 30px rgba(192, 38, 37, 0.2);
        }
        
        .module-cell.completed::after {
            content: '✓';
            position: absolute;
            top: 1rem;
            right: 1rem;
            color: var(--accent);
            font-size: 1.2rem;
        }
        
        .module-cell h3 {
            font-size: clamp(1.3rem, 4vw, 1.8rem);
            font-weight: 400;
            margin-bottom: 0.4rem;
            letter-spacing: 0.02em;
        }
        
        .module-cell .subtitle {
            font-size: 0.65rem;
            color: rgba(42, 42, 42, 0.6);
            margin-bottom: 0.8rem;
            letter-spacing: 0.15em;
            text-transform: uppercase;
        }
        
        .module-cell .description {
            font-size: 0.8rem;
            line-height: 1.5;
            color: rgba(42, 42, 42, 0.75);
        }
        
        #game-ui {
            position: absolute;
            top: 2rem;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            opacity: 0;
            transition: opacity 0.5s;
            max-width: 85%;
            pointer-events: none;
        }
        
        @media (max-width: 768px) {
            #game-ui {
                top: 6rem;
                max-width: 90%;
            }
        }
        
        #game-ui.active { opacity: 1; }
        
        #game-ui h3 {
            font-size: clamp(1.3rem, 5vw, 2rem);
            font-weight: 400;
            margin-bottom: 0.5rem;
            letter-spacing: 0.05em;
            text-shadow: 0 0 20px rgba(192, 38, 37, 0.2);
        }
        
        #game-ui p {
            font-size: clamp(0.7rem, 2vw, 0.9rem);
            color: rgba(42, 42, 42, 0.7);
        }
        
        #game-stats {
            position: absolute;
            top: 2rem;
            right: 1rem;
            text-align: right;
            opacity: 0;
            transition: opacity 0.5s;
            pointer-events: none;
        }
        
        @media (max-width: 768px) {
            #game-stats {
                top: 1.5rem;
                right: 0.75rem;
            }
        }
        
        #game-stats.active { opacity: 1; }
        
        .stat-row {
            font-size: 0.65rem;
            color: rgba(42, 42, 42, 0.7);
            margin-bottom: 0.4rem;
            letter-spacing: 0.1em;
            font-weight: 400;
        }
        
        .stat-value {
            color: var(--accent);
            font-weight: 500;
            margin-left: 0.5rem;
            text-shadow: 0 0 10px rgba(192, 38, 37, 0.3);
        }
        
        #back-btn {
            position: absolute;
            top: 2rem;
            left: 1rem;
            opacity: 0;
            transition: opacity 0.5s;
            padding: 0.7rem 1.5rem;
            font-size: 0.65rem;
            pointer-events: auto;
        }
        
        @media (max-width: 768px) {
            #back-btn {
                top: 1.5rem;
                left: 0.75rem;
                padding: 0.65rem 1.2rem;
            }
        }
        
        #back-btn.active { opacity: 1; }
        
        #tutorial-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(245, 245, 240, 0.96);
            z-index: 99;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.5s ease, visibility 0.5s;
            pointer-events: none;
            backdrop-filter: blur(8px);
        }
        #tutorial-overlay.active {
            opacity: 1;
            visibility: visible;
            pointer-events: auto;
        }
        .tutorial-card {
            max-width: 500px;
            width: 90%;
            padding: 2.5rem 1.5rem;
            border: 2px solid var(--accent);
            text-align: center;
            background: rgba(255, 255, 255, 0.98);
            box-shadow: 0 0 50px rgba(192, 38, 37, 0.3);
        }
        .tutorial-card h3 {
            font-size: clamp(1.5rem, 5vw, 2rem);
            margin-bottom: 1rem;
            text-shadow: 0 0 20px rgba(192, 38, 37, 0.2);
        }
        .tutorial-card p {
            font-size: clamp(0.85rem, 3vw, 1.1rem);
            line-height: 1.5;
            margin-bottom: 1.5rem;
            color: var(--fg);
        }
        .tutorial-card button {
            margin-top: 1rem;
        }

        .game-intro-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            max-width: 80%;
            font-size: clamp(0.85rem, 2.5vw, 1.1rem);
            color: var(--fg);
            text-align: center;
            z-index: 50;
            pointer-events: none;
            opacity: 0;
            transition: opacity 1.0s;
            line-height: 1.5;
            letter-spacing: 0.05em;
            font-weight: 300;
        }
        
        #question-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 255, 255, 0.98);
            border: 2px solid var(--accent);
            padding: 2rem;
            max-width: 500px;
            width: 90%;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s, visibility 0.3s;
            z-index: 100;
            pointer-events: auto;
            box-shadow: 0 0 50px rgba(192, 38, 37, 0.3);
        }
        
        @media (max-width: 768px) {
            #question-overlay {
                padding: 1.5rem;
                width: 95%;
            }
        }
        
        #question-overlay.active {
            opacity: 1;
            visibility: visible;
        }
        
        #question-text {
            font-size: clamp(1rem, 3vw, 1.2rem);
            margin-bottom: 1.5rem;
            font-weight: 400;
            text-align: center;
            line-height: 1.4;
        }
        
        .answer-option {
            background: transparent;
            border: 1px solid rgba(192, 38, 37, 0.3);
            padding: 1rem;
            margin-bottom: 0.8rem;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 0.9rem;
            width: 100%;
            text-align: left;
            color: var(--fg);
        }
        
        .answer-option:hover, .answer-option:active {
            background: rgba(192, 38, 37, 0.2);
            border-color: var(--accent);
            box-shadow: 0 0 20px rgba(192, 38, 37, 0.2);
        }
        
        /* Answer feedback states */
        .answer-option.correct {
            background: rgba(76, 175, 80, 0.3) !important;
            border-color: #4caf50 !important;
            box-shadow: 0 0 25px rgba(76, 175, 80, 0.4) !important;
            animation: correctPulse 0.6s ease;
        }
        
        .answer-option.wrong {
            background: rgba(244, 67, 54, 0.3) !important;
            border-color: #f44336 !important;
            box-shadow: 0 0 25px rgba(244, 67, 54, 0.4) !important;
            animation: wrongShake 0.4s ease;
        }
        
        @keyframes correctPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }
        
        @keyframes wrongShake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-10px); }
            75% { transform: translateX(10px); }
        }
        
        /* Category badge styling */
        .category-badge {
            display: inline-block;
            padding: 0.3rem 0.8rem;
            background: rgba(192, 38, 37, 0.15);
            border: 1px solid rgba(192, 38, 37, 0.3);
            border-radius: 20px;
            font-size: 0.75rem;
            font-weight: 600;
            margin-bottom: 1rem;
            color: var(--accent);
            letter-spacing: 0.5px;
        }
        
        .results-wrapper {
            max-width: 800px;
            width: 95%;
            padding: 2rem 1rem;
            align-self: flex-start;
            margin-top: 2rem;
        }
        
        @media (max-width: 768px) {
            .results-wrapper {
                width: 98%;
                padding: 1rem 0.5rem;
            }
        }
        
        .results-header {
            font-size: clamp(1.8rem, 7vw, 3rem);
            font-weight: 400;
            text-align: center;
            margin-bottom: 2rem;
            letter-spacing: 0.02em;
            text-shadow: 0 0 30px rgba(192, 38, 37, 0.3);
        }
        
        .results-summary {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
            gap: 1px;
            background: rgba(192, 38, 37, 0.2);
            border: 1px solid rgba(192, 38, 37, 0.2);
            margin-bottom: 2rem;
        }
        
        .summary-item {
            background: rgba(255, 255, 255, 0.9);
            padding: 1rem;
            text-align: center;
        }
        
        @media (max-width: 768px) {
            .summary-item {
                padding: 0.8rem 0.5rem;
            }
            .summary-item h4 {
                 font-size: 0.55rem;
            }
             .summary-item .value {
                font-size: clamp(1.2rem, 4vw, 2rem);
            }
        }
        
        .summary-item h4 {
            font-size: 0.65rem;
            color: rgba(42, 42, 42, 0.7);
            margin-bottom: 0.6rem;
            letter-spacing: 0.15em;
            text-transform: uppercase;
            font-weight: 500;
        }
        
        .summary-item .value {
            font-size: clamp(1.5rem, 5vw, 2.6rem);
            font-weight: 400;
            color: var(--accent);
            text-shadow: 0 0 10px rgba(192, 38, 37, 0.3);
        }
        
        .results-details {
            margin-bottom: 2rem;
        }
        
        .detail-row {
            display: flex;
            justify-content: space-between;
            padding: 0.8rem 0.2rem;
            border-bottom: 1px solid rgba(192, 38, 37, 0.2);
            gap: 1rem;
            flex-wrap: wrap;
        }
        
        .detail-row:last-child {
            border-bottom: none;
        }
        
        .detail-label {
            font-size: 0.8rem;
            font-weight: 400;
        }
        
        .detail-value {
            font-size: 0.8rem;
            color: var(--accent);
            font-weight: 500;
            text-align: right;
            text-shadow: 0 0 10px rgba(192, 38, 37, 0.3);
        }
        
        #scent-wheel-container {
            text-align: center;
            margin-bottom: 2rem;
        }
        
        #scent-wheel {
            width: 100%;
            max-width: 400px;
            height: 400px;
            margin: 0 auto;
        }
        
        @media (max-width: 768px) {
            #scent-wheel {
                max-width: 320px;
                height: 320px;
            }
        }
        
        #report-visualization {
            width: 100%;
            height: 300px;
            margin-bottom: 2rem;
        }

        .recommendation-box {
            background: rgba(192, 38, 37, 0.08);
            padding: 2rem 1.5rem;
            text-align: center;
            margin-bottom: 2rem;
            border: 1px solid rgba(192, 38, 37, 0.2);
        }
        
        @media (max-width: 768px) {
            .recommendation-box {
                padding: 1.5rem 1rem;
            }
        }
        
        .recommendation-box h3 {
            font-size: clamp(0.95rem, 3vw, 1.2rem);
            font-weight: 400;
            margin-bottom: 1rem;
            letter-spacing: 0.05em;
        }
        
        .recommendation-box p {
            font-size: clamp(0.95rem, 3vw, 1.3rem);
            line-height: 1.6;
        }
        
        .dot-pattern {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 25%;
            background-image: radial-gradient(circle, rgba(42, 42, 42, 0.1) 1px, transparent 1px);
            background-size: 18px 18px;
            opacity: 0.3;
            pointer-events: none;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .fade-in {
            animation: fadeIn 0.8s ease forwards;
        }
        
        ::-webkit-scrollbar { width: 6px; }
        ::-webkit-scrollbar-track { background: var(--gray); }
        ::-webkit-scrollbar-thumb { background: var(--accent); }

        #pattern-countdown {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: clamp(3rem, 10vw, 6rem);
            color: var(--accent);
            font-weight: 500;
            opacity: 0;
            transition: opacity 0.3s;
            z-index: 50;
            pointer-events: none;
            text-shadow: 0 0 30px rgba(192, 38, 37, 0.5);
        }
        
        #pattern-countdown.active {
            opacity: 1;
        }
        
        #crystal-container {
            width: 100%;
            height: 100%;
            max-width: 800px;
            max-height: 600px;
            display: flex;
            align-items: center;
            justify-content: center;
            pointer-events: auto;
            position: relative;
        }
        
        #crystal-canvas {
            width: 100%;
            height: 100%;
        }
        
        #crystal-indicator {
            position: absolute;
            bottom: 2rem;
            left: 50%;
            transform: translateX(-50%);
            font-size: 0.9rem;
            color: var(--accent);
            text-shadow: 0 0 10px rgba(192, 38, 37, 0.3);
            pointer-events: none;
        }

        #reflex-canvas {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            max-width: 90vmin;
            max-height: 90vmin;
            aspect-ratio: 1 / 1;
            z-index: 5;
            border: none;
            background: transparent;
        }

        #game-countdown {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: clamp(4rem, 15vw, 8rem);
            color: var(--accent);
            font-weight: 700;
            opacity: 0;
            z-index: 200;
            pointer-events: none;
            transition: opacity 0.2s;
            text-shadow: 0 0 50px rgba(192, 38, 37, 0.5);
        }
        
        .game-intro-text.active-intro {
            opacity: 1;
        }

        #report-visualization .bar {
            transition: fill 0.3s, opacity 0.3s;
        }
        #report-visualization .tick line, #report-visualization .domain {
            stroke: rgba(192, 38, 37, 0.3);
        }
        #report-visualization text {
            fill: #2a2a2a; 
        }
        
        #mod4-canvas {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            max-width: 90vw;
            max-height: 80vh;
            border: 2px solid rgba(192, 38, 37, 0.3);
            background: #1a1a1a;
        }

    </style>
</head>
<body>
    <div id="cursor"></div>
    <canvas id="canvas3d"></canvas>
    
    <div id="lang-switch">
        <button class="lang-btn active" data-lang="en">EN</button>
        <button class="lang-btn" data-lang="zh">中</button>
    </div>
    
    <div id="ui-layer">
        <div id="welcome-screen" class="screen active">
            <h1 class="welcome-logo serif">NeuroScent</h1>
            <p class="welcome-subtitle" data-i18n="welcome_sub">Personalized Olfactory-Cognitive Training</p>
            <p style="font-size: 0.65rem; color: rgba(42, 42, 42, 0.5); letter-spacing: 0.1em; margin-top: 2rem;">
                TAP ANYWHERE TO BEGIN
            </p>
            <div class="dot-pattern"></div>
        </div>
        
        <div id="info-screen" class="screen" style="pointer-events: none;">
            <div class="info-container fade-in" style="pointer-events: auto;">
                <h2 class="form-title serif" data-i18n="info_title">Profile</h2>
                <div class="form-field">
                    <label data-i18n="info_name">Name</label>
                    <input type="text" id="user-name" placeholder="Enter your name" autocomplete="name">
                </div>
                <div class="form-field">
                    <label data-i18n="info_age">Age</label>
                    <input type="number" id="user-age" placeholder="Enter your age" min="1" max="120" autocomplete="age">
                </div>
                <div class="form-field">
                    <label data-i18n="info_gender">Gender</label>
                    <select id="user-gender">
                        <option value="">Select gender</option>
                        <option value="male" data-i18n="info_male">Male / 男</option>
                        <option value="female" data-i18n="info_female">Female / 女</option>
                        <option value="nonbinary" data-i18n="info_nonbinary">Nonbinary / 非二元</option>
                        <option value="prefer-not" data-i18n="info_prefer_not">Prefer not to say / 不愿透露</option>
                    </select>
                </div>
                <div class="form-field">
                    <label data-i18n="info_status">Status</label>
                    <select id="user-status">
                        <option value="">Select status</option>
                        <option value="early-stage" data-i18n="info_early">Early Stage / 早期</option>
                        <option value="moderate" data-i18n="info_moderate">Moderate / 中度</option>
                        <option value="control" data-i18n="info_control">Control / 对照</option>
                    </select>
                </div>
                <button class="btn accent" id="info-submit" style="display: block; width: 100%; margin-top: 2rem;">
                    <span data-i18n="btn_continue">CONTINUE</span>
                </button>
            </div>
        </div>
        
        <div id="scent-screen" class="screen">
            <div class="scent-header fade-in">
                <h2 class="serif" data-i18n="scent_title">Olfactory Profile</h2>
                <p data-i18n="scent_desc">Drag outward from center to set preference</p>
            </div>

            <div id="scent-pages">
                <div class="scent-page active" data-page="0"></div>
                <div class="scent-page" data-page="1"></div>
                <div class="scent-page" data-page="2"></div>
                <div class="scent-page" data-page="3"></div>
                <div class="scent-page" data-page="4"></div>
                <div class="scent-page" data-page="5"></div>
            </div>
            <div class="scent-pagination">
                <div class="page-dot active" data-page="0"></div>
                <div class="page-dot" data-page="1"></div>
                <div class="page-dot" data-page="2"></div>
                <div class="page-dot" data-page="3"></div>
                <div class="page-dot" data-page="4"></div>
                <div class="page-dot" data-page="5"></div>
            </div>
            <div class="scent-controls">
                <button class="btn" id="scent-prev" style="opacity: 0.3;">
                    <span>← PREV</span>
                </button>
                <button class="btn accent" id="scent-submit">
                    <span data-i18n="btn_continue">CONTINUE</span>
                </button>
                <button class="btn" id="scent-next">
                    <span>NEXT →</span>
                </button>
            </div>
        </div>
        
        <div id="module-selection-screen" class="screen">
            <div class="module-wrapper">
                <div class="module-header">
                    <h2 class="serif" data-i18n="modules_title">Training Modules</h2>
                    <div class="difficulty-control">
                        <label data-i18n="difficulty_label">Simulate Patient tOC (Total Outlier Count)</label>
                        <p class="difficulty-desc" data-i18n="difficulty_desc">Higher tOC increases module difficulty.</p>
                        <div class="slider-container">
                            <input type="range" class="difficulty-slider" id="toc-slider" min="0" max="100" value="20">
                            <div class="difficulty-value" id="toc-value">20</div>
                        </div>
                    </div>
                </div>
                <div class="module-grid" id="module-gallery"></div>
                <button class="btn accent" id="finish-btn" style="display: block; margin: 0 auto;">
                    <span data-i18n="btn_finish">COMPLETE SESSION</span>
                </button>
            </div>
        </div>
        
        <div id="game-screen" class="screen">
            <button class="btn" id="back-btn">
                <span data-i18n="btn_back">← BACK</span>
            </button>
            <div id="game-ui">
                <h3 class="serif" id="game-title"></h3>
                <p id="game-instruction"></p>
            </div>
            <div id="game-stats">
                <div class="stat-row"><span data-i18n="stat_time">Time</span><span class="stat-value" id="stat-time">0s</span></div>
                <div class="stat-row"><span data-i18n="stat_score">Score</span><span class="stat-value" id="stat-score">0</span></div>
                <!-- 自适应难度显示 (仅模块3可见) -->
                <div id="difficulty-display" class="stat-row" style="display: none; margin-top: 0.8rem; border-top: 1px solid rgba(192, 38, 37, 0.2); padding-top: 0.6rem;">
                    <div style="display: flex; align-items: center; justify-content: flex-end; gap: 0.5rem; margin-bottom: 0.3rem;">
                        <span style="font-size: 0.7rem;">Level</span>
                        <span class="stat-value" id="current-level" style="font-size: 1.2rem;">2</span>
                    </div>
                    <div style="font-size: 0.55rem; opacity: 0.7; text-align: right;">
                        <div id="streak-correct" style="color: #00cc00; margin-bottom: 0.2rem;">✓ Streak: 0/5</div>
                        <div id="streak-wrong" style="color: #ff6600;">✗ Streak: 0/3</div>
                    </div>
                </div>
            </div>
            <div id="game-intro-text" class="game-intro-text zh"></div>
            <div id="game-countdown"></div>
            
            <div id="question-overlay">
                <h3 id="question-text"></h3>
                <div id="answer-options"></div>
            </div>
            
            <div id="pattern-countdown"></div>
            
            <div id="crystal-container" style="display: none;">
                <canvas id="crystal-canvas"></canvas>
                <div id="crystal-indicator"></div>
            </div>

            <canvas id="reflex-canvas" style="display: none;"></canvas>
            <canvas id="mod4-canvas" style="display: none;"></canvas>
            
            <div id="tutorial-overlay">
                <div class="tutorial-card">
                    <h3 class="serif" id="tutorial-title"></h3>
                    <p id="tutorial-text"></p>
                    <button class="btn accent" id="tutorial-start-btn">
                        <span data-i18n="btn_start_game">START TRAINING</span>
                    </button>
                </div>
            </div>

            <div class="dot-pattern"></div>
        </div>
        
        <div id="results-screen" class="screen">
            <div class="results-wrapper fade-in">
                <h2 class="results-header serif" data-i18n="results_title">Session Report</h2>
                <div class="results-summary" id="results-summary"></div>
                <div class="results-details" id="results-details"></div>
                <div id="scent-wheel-container">
                    <div id="scent-wheel"></div>
                </div>
                <div id="report-visualization"></div>

                <div class="recommendation-box">
                    <h3 class="serif" data-i18n="results_scent">Recommended Scent Profile</h3>
                    <p id="scent-result"></p>
                </div>
                <button class="btn accent" id="restart-btn" style="display: block; margin: 0 auto;">
                    <span data-i18n="btn_restart">NEW SESSION</span>
                </button>
            </div>
        </div>
    </div>
    
    <script>
    document.addEventListener('DOMContentLoaded', () => {
        
        // ==================== RESOURCE MANAGER ====================
        // 统一资源管理系统，确保所有资源正确清理
        const ResourceManager = {
            resources: new Map(),
            
            register(id, resource) {
                this.resources.set(id, resource);
                console.log(`✓ Resource registered: ${id}`);
            },
            
            unregister(id) {
                const resource = this.resources.get(id);
                if (resource) {
                    if (resource.cleanup && typeof resource.cleanup === 'function') {
                        try {
                            resource.cleanup();
                            console.log(`✓ Resource cleaned up: ${id}`);
                        } catch (e) {
                            console.error(`✗ Error cleaning ${id}:`, e);
                        }
                    }
                    this.resources.delete(id);
                }
            },
            
            cleanupAll() {
                console.log(`🧹 Cleaning up ${this.resources.size} resources...`);
                const ids = Array.from(this.resources.keys());
                ids.forEach(id => this.unregister(id));
                this.resources.clear();
            },
            
            get(id) {
                return this.resources.get(id);
            }
        };
        
        // ==================== PERFORMANCE UTILITIES ====================
        const PerformanceUtils = {
            throttle(func, limit) {
                let inThrottle;
                return function(...args) {
                    if (!inThrottle) {
                        func.apply(this, args);
                        inThrottle = true;
                        setTimeout(() => inThrottle = false, limit);
                    }
                };
            },
            
            debounce(func, delay) {
                let timeoutId;
                return function(...args) {
                    clearTimeout(timeoutId);
                    timeoutId = setTimeout(() => func.apply(this, args), delay);
                };
            }
        };
        
        // ==================== SOUND SYSTEM ====================
        const Sound = {
            synths: {},
            ambient: null,
            noiseFilter: null,
            ambientLoop: null,
            initialized: false,
            ambientPianoLoop: null,
            vinylNoise: null,
            scentPanner: null,
            
            init() {
                if (this.initialized) return;
                try {
                    const reverb = new Tone.Reverb({ decay: 10, wet: 0.6, preDelay: 0.05 }).toDestination();
                    const filter = new Tone.Filter({ type: 'lowpass', frequency: 1200, rolloff: -24 }).connect(reverb);
                    const chorus = new Tone.Chorus({ frequency: 0.5, delayTime: 3.5, depth: 0.7, wet: 0.5 }).connect(filter);
                    const delay = new Tone.FeedbackDelay({ delayTime: '4n', feedback: 0.5, wet: 0.25 }).connect(chorus);
                    
                    this.noiseFilter = new Tone.Filter({ frequency: 800, type: 'bandpass', Q: 0.5 }).connect(reverb);
                    this.vinylNoise = new Tone.Noise({ type: 'pink', volume: -100 }).connect(this.noiseFilter);
                    this.vinylNoise.start();
                    
                    setTimeout(() => {
                        if (this.vinylNoise) {
                            this.vinylNoise.volume.rampTo(-34, 15);
                        }
                    }, 3000);
                    
                    this.ambient = new Tone.PolySynth(Tone.DuoSynth, {
                        volume: -26,
                        voice0: {
                            oscillator: { type: 'sine' },
                            envelope: { attack: 5, decay: 7, sustain: 0.25, release: 9 },
                            filter: { type: 'lowpass', frequency: 550 }
                        },
                        voice1: {
                            oscillator: { type: 'triangle' },
                            envelope: { attack: 9, decay: 5, sustain: 0.15, release: 11 },
                            filter: { type: 'lowpass', frequency: 350 }
                        }
                    }).connect(reverb);
                    
                    this.ambientPiano = new Tone.Sampler({
                        urls: { C4: "data:audio/wav;base64,UklGRiQAAABXQVZFZm10IBAAAAABAAEAQB8AAAB9AAACABAAZGF0YQAAAAA=" },
                        volume: -30,
                        release: 6
                    }).connect(reverb);
                    
                    this.scentPanner = new Tone.Panner3D({ 
                        positionX: 0, 
                        positionY: 0, 
                        positionZ: 0 
                    }).connect(reverb);
                    
                    this.synths = {
                        click: new Tone.MembraneSynth({ volume: -28, pitchDecay: 0.02, octaves: 1, envelope: { attack: 0.005, decay: 0.15, sustain: 0, release: 0.1 } }).connect(delay),
                        hover: new Tone.Synth({ volume: -36, oscillator: { type: 'triangle' }, envelope: { attack: 0.01, decay: 0.05, sustain: 0, release: 0.04 } }).connect(filter),
                        success: new Tone.PolySynth(Tone.FMSynth, { 
                            volume: -22, 
                            harmonicity: 3.5, 
                            modulationIndex: 12,
                            envelope: { attack: 0.06, decay: 1.8, sustain: 0.12, release: 2.5 } 
                        }).connect(reverb),
                        slider: new Tone.Synth({ 
                            volume: -32, 
                            oscillator: { type: 'sine' }, 
                            envelope: { attack: 0.015, decay: 0.12, sustain: 0.08, release: 0.25 } 
                        }).connect(this.scentPanner),
                        scentDrag: new Tone.Synth({ 
                            volume: -28, 
                            oscillator: { type: 'triangle' }, 
                            envelope: { attack: 0.01, decay: 0.2, sustain: 0.3, release: 0.4 } 
                        }).connect(this.scentPanner),
                        module1: new Tone.PluckSynth({ volume: -26, dampening: 3500, resonance: 0.96 }).connect(delay),
                        module2: new Tone.MonoSynth({ volume: -28, oscillator: { type: 'square' }, envelope: { attack: 0.1, decay: 0.2, sustain: 0.5, release: 0.5 } }).connect(chorus),
                        breakthrough: new Tone.PolySynth(Tone.AMSynth, { 
                            volume: -20, 
                            harmonicity: 1.8, 
                            modulationType: 'square',
                            envelope: { attack: 0.06, decay: 4.5, sustain: 0.15, release: 5.5 } 
                        }).connect(reverb),
                        module3_hit: new Tone.MetalSynth({ volume: -22, frequency: 150, envelope: { attack: 0.001, decay: 0.08, release: 0.05 }, harmonicity: 5, modulationIndex: 10 }).connect(filter),
                        module3_unstable: new Tone.NoiseSynth({ volume: -30, noise: { type: 'white' }, envelope: { attack: 0.01, decay: 0.1, sustain: 0.2, release: 0.2 } }).connect(filter),
                        crystal_ring: new Tone.FMSynth({ volume: -24, harmonicity: 2.5, modulationIndex: 8, envelope: { attack: 0.001, decay: 0.4, sustain: 0.1, release: 0.5 } }).connect(reverb),
                        reflex_start: new Tone.MembraneSynth({ volume: -18, pitchDecay: 0.01, octaves: 1.5, envelope: { attack: 0.005, decay: 0.3, sustain: 0, release: 0.1 } }).connect(delay),
                        reflex_cue: new Tone.FMSynth({ volume: -20, harmonicity: 0.5, modulationIndex: 5, envelope: { attack: 0.001, decay: 0.05, sustain: 0, release: 0.02 } }).connect(filter),
                        reflex_hit: new Tone.Synth({ volume: -15, oscillator: { type: 'sine' }, envelope: { attack: 0.001, decay: 0.1, sustain: 0, release: 0.05 } }).connect(reverb),
                        reflex_miss: new Tone.NoiseSynth({ volume: -25, noise: { type: 'brown' }, envelope: { attack: 0.01, decay: 0.1, sustain: 0, release: 0.05 } }).connect(filter),
                        flow_pacer: new Tone.Synth({ volume: -28, oscillator: { type: 'sine' }, envelope: { attack: 1.0, decay: 0.5, sustain: 0.8, release: 1.5 } }).connect(reverb),
                    };
                    
                    this.initialized = true;
                    this.playAmbientLoop();
                    this.playAmbientPianoLayer();
                } catch(e) { console.warn('Sound init error:', e); }
            },
            
            stopAmbient() {
                if (this.ambientLoop) {
                    this.ambientLoop.dispose();
                    this.ambientLoop = null;
                }
                if (this.ambientPianoLoop) {
                    this.ambientPianoLoop.dispose();
                    this.ambientPianoLoop = null;
                }
                if (Tone.Transport.state !== 'stopped') {
                    Tone.Transport.stop();
                }
                if (this.vinylNoise) {
                    this.vinylNoise.stop();
                    this.vinylNoise.dispose();
                    this.vinylNoise = null;
                }
            },

            playAmbientLoop() {
                if (!this.ambient || this.ambientLoop) return;
                this.ambientLoop = new Tone.Loop((time) => {
                    this.ambient.triggerAttackRelease(['C3', 'Eb3', 'G3', 'Bb3'], '8m', time, 0.25);
                }, '8m');
                this.ambientLoop.start(0);
                Tone.Transport.start();
            },
            
            playAmbientPianoLayer() {
                if (!this.ambientPiano || this.ambientPianoLoop) return;
                const etherealChords = [
                    ['C4', 'E4', 'G4', 'B4'],
                    ['D4', 'F#4', 'A4', 'C5'],
                    ['G3', 'B3', 'D4', 'F#4'],
                    ['A3', 'C#4', 'E4', 'G#4']
                ];
                
                let chordIndex = 0;
                this.ambientPianoLoop = new Tone.Loop((time) => {
                    if (Math.random() > 0.65) {
                        const chord = etherealChords[chordIndex % etherealChords.length];
                        chord.forEach((note, i) => {
                            this.ambientPiano.triggerAttackRelease(note, '2m', time + i * 0.1, 0.4);
                        });
                        chordIndex++;
                    }
                }, '4m');
                this.ambientPianoLoop.start('+2m');
            },
            
            play(type, note = 'C4', velocity = 0.7) {
                if (!this.initialized || Tone.context.state !== 'running') return;
                try {
                    const now = Tone.now();
                    switch(type) {
                        case 'click': 
                            this.synths.click.triggerAttackRelease('C3', '8n', now, velocity * 0.5); 
                            break;
                        case 'hover': 
                            this.synths.hover.triggerAttackRelease('C6', '64n', now, 0.12); 
                            break;
                        case 'success': 
                            this.synths.success.triggerAttackRelease(['C5', 'Eb5', 'G5'], '2s', now, velocity * 0.6); 
                            break;
                        case 'slider': 
                            this.synths.slider.triggerAttackRelease(note, '32n', now, velocity * 0.5); 
                            break;
                        case 'breakthrough': 
                            this.synths.breakthrough.triggerAttackRelease(['C4', 'E4', 'G4', 'B4'], '3s', now, velocity * 0.7); 
                            break;
                        case 'module3_hit': 
                            this.synths.module3_hit.triggerAttackRelease('C3', '8n', now, velocity * 0.6);
                            break;
                        case 'reflex_cue': 
                            this.synths.reflex_cue.triggerAttackRelease('A5', '64n', now, 1.0);
                            break;
                        case 'reflex_hit':
                            this.synths.reflex_hit.triggerAttackRelease('G5', '16n', now, 0.9);
                            break;
                        default: 
                            if (this.synths[type]) this.synths[type].triggerAttackRelease(note, '16n', now, velocity * 0.6);
                    }
                } catch(e) { console.warn('Sound play error:', e); }
            },
            
            playScentDrag(distance, angle) {
                if (!this.initialized || Tone.context.state !== 'running') return;
                try {
                    const freq = 200 + distance * 600;
                    const note = Tone.Frequency(freq, "hz").toNote();
                    
                    const pan = Math.cos(angle);
                    if (this.scentPanner) {
                        this.scentPanner.positionX.rampTo(pan, 0.05);
                    }
                    
                    this.synths.scentDrag.frequency.rampTo(freq, 0.05);
                    if (this.synths.scentDrag.envelope.value === 0) {
                        this.synths.scentDrag.triggerAttack(note, Tone.now(), 0.5);
                    }
                } catch(e) { console.warn('Scent drag sound error:', e); }
            },
            
            stopScentDrag() {
                if (this.synths.scentDrag) {
                    this.synths.scentDrag.triggerRelease();
                }
            },
            
            start(type, note = 'C4', velocity = 0.7) {
                if (!this.initialized || Tone.context.state !== 'running') return;
                try {
                    if (this.synths[type] && this.synths[type].triggerAttack) {
                        this.synths[type].triggerAttack(note, Tone.now(), velocity * 0.6);
                    }
                } catch(e) { console.warn('Sound start error:', e); }
            },

            release(type) {
                if (!this.initialized || !this.synths[type] || !this.synths[type].triggerRelease) return;
                try { 
                    this.synths[type].triggerRelease();
                }
                catch(e) { console.warn('Sound release error:', e); }
            }
        };
        
        // ==================== I18N SYSTEM ====================
        const I18N = {
            lang: 'en',
            data: {
                en: {
                    welcome_sub: 'Personalized Olfactory-Cognitive Training',
                    btn_begin: 'BEGIN',
                    btn_continue: 'CONTINUE',
                    btn_back: '← SAVE & EXIT',
                    btn_finish: 'COMPLETE SESSION',
                    btn_restart: 'NEW SESSION',
                    btn_start_game: 'START TRAINING',
                    info_title: 'Profile',
                    info_name: 'Name',
                    info_age: 'Age',
                    info_gender: 'Gender',
                    info_status: 'Status',
                    info_male: 'Male',
                    info_female: 'Female',
                    info_nonbinary: 'Nonbinary',
                    info_prefer_not: 'Prefer not to say',
                    info_early: 'Early Stage',
                    info_moderate: 'Moderate',
                    info_control: 'Control',
                    scent_title: 'Olfactory Profile',
                    scent_desc: 'Drag outward from center to set preference',
                    modules_title: 'Training Modules',
                    difficulty_label: 'Simulate Patient tOC (Total Outlier Count)',
                    difficulty_desc: 'Higher tOC increases module difficulty.',
                    stat_time: 'Time',
                    stat_score: 'Score',
                    stat_progress: 'Progress',
                    results_title: 'Session Report',
                    results_scent: 'Recommended Scent Profile',
                    total_time: 'Total Time',
                    avg_score: 'Average Score',
                    modules_completed: 'Modules Completed',
                    floral_desc: 'ETHEREAL, EMOTIONAL, MEMORY\n\nDelicate petals unfolding in soft whispers. Linked to emotional warmth and nostalgic recall.\nExamples: Rose, Jasmine, Ylang-Ylang, Neroli',
                    woody_desc: 'GROUNDED, ENDURING, FOCUS\n\nDeep timber essence. Anchors attention and provides steady mental foundation.\nExamples: Cedarwood, Sandalwood, Oud, Vetiver',
                    citrus_desc: 'SHARP, VIBRANT, ALERTNESS\n\nA sudden, zesty burst used to enhance cognitive speed and refresh attention.\nExamples: Lemon, Bergamot, Grapefruit, Lime',
                    earthy_desc: 'ROOTED, CALM, PRESENCE\n\nMoss-covered stones and ancient soil. Cultivates deep presence and stability.\nExamples: Patchouli, Oakmoss, Earth, Mushroom',
                    fresh_desc: 'CRISP, CLEAR, RENEWAL\n\nCool morning air and mountain springs. Clears mental fog and stimulates clarity.\nExamples: Eucalyptus, Marine, Mint, Pine',
                    spicy_desc: 'WARM, INTENSE, STIMULATION\n\nFiery heat that awakens. Sharpens reflexes and accelerates processing.\nExamples: Cinnamon, Clove, Ginger, Black Pepper',
                    mod1_intro: 'Count the flowing school',
                    mod2_intro: 'Capture the signal through noise',
                    mod3_intro: 'Stabilize reality, solve the pattern',
                    mod4_intro: 'Align the frequency waves', 
                    mod5_intro: 'React to the black targets',
                    mod6_intro: 'Flow with the cosmic vortex breath',
                    mod1_desc: 'Memory: Count fish in passing schools',
                    mod2_desc: 'Signal: Maintain focus through noise',
                    mod3_desc: 'Pattern: Stabilize and solve the core',
                    mod4_desc: 'Wave Match: Align oscillating frequencies', 
                    mod5_desc: 'Reflex: Hit black dots, avoid red distractions',
                    mod6_desc: 'Flow: Synchronize with Kármán vortex (4-7-8)',
                    mod1_tut_title: 'Memory: Fish School Counter',
                    mod1_tut_desc: 'Watch fish swim across the screen. Count how many you see! First round: count 1 school. Later rounds: count 2 schools separately.',
                    mod2_tut_title: 'Signal',
                    mod2_tut_desc: 'A signal moves through noise. CAPTURE and HOLD it precisely with your finger/mouse until breakthrough energy builds.',
                    mod3_tut_title: 'Pattern Recognition',
                    mod3_tut_desc: 'PRESS AND HOLD (two fingers on mobile, click/press on desktop) to stabilize the core. Answer the cognitive question quickly. Errors will deduct points.',
                    mod4_tut_title: 'Frequency Wave Match',
                    mod4_tut_desc: 'Artistic wave patterns oscillate on screen. Match your wave (red) to the target wave (green) by adjusting frequency and amplitude with the elegant sliders. Each stage presents a unique wave type.',
                    mod5_tut_title: 'Reflex: Target Practice',
                    mod5_tut_desc: 'After 3-2-1 countdown, dots will light up. Tap BLACK dots quickly for points. AVOID RED dots (they subtract points). Miss a black dot and lose points too. Stay sharp!',
                    mod6_tut_title: 'Flow: Kármán Vortex',
                    mod6_tut_desc: 'Guided 4-7-8 breathing synchronized with fluid dynamics. Inhale (4s, HOLD), Pause (7s), Exhale (8s, RELEASE). Follow the Kármán vortex street pattern. Only synchronization matters.',
                },
                zh: {
                    welcome_sub: '个性化嗅觉-认知训练',
                    btn_begin: '开始',
                    btn_continue: '继续',
                    btn_back: '← 保存并退出',
                    btn_finish: '完成会话',
                    btn_restart: '新会话',
                    btn_start_game: '开始训练',
                    info_title: '个人档案',
                    info_name: '姓名',
                    info_age: '年龄',
                    info_gender: '性别',
                    info_status: '状态',
                    info_male: '男性',
                    info_female: '女性',
                    info_nonbinary: '非二元',
                    info_prefer_not: '不愿透露',
                    info_early: '早期',
                    info_moderate: '中度',
                    info_control: '可控范围内',
                    scent_title: '气味偏好档案',
                    scent_desc: '从中心向外拖动以设置偏好度',
                    modules_title: '训练模块',
                    difficulty_label: '模拟患者tOC(总离群值计数)',
                    difficulty_desc: '更高的tOC值将增加模块难度。',
                    stat_time: '耗时',
                    stat_score: '得分',
                    stat_progress: '进度',
                    results_title: '会话报告',
                    results_scent: '推荐气味档案',
                    total_time: '总耗时',
                    avg_score: '平均得分',
                    modules_completed: '已完成模块',
                    floral_desc: '空灵、情感、记忆\n\n轻柔的花瓣在低语中绽放。与情感温暖和怀旧回忆相联系。\n例如: 玫瑰、茉莉、依兰、橙花',
                    woody_desc: '扎根、持久、专注\n\n深沉的木质本质。锚定注意力并提供稳定的心智基础。\n例如: 雪松、檀香、沉香、岩兰草',
                    citrus_desc: '锐利、活力、警觉\n\n突如其来的清新爆发,用于增强认知速度和刷新注意力。\n例如: 柠檬、佛手柑、葡萄柚、青柠',
                    earthy_desc: '根植、平静、临在\n\n苔藓覆盖的石头和古老的土壤。培养深层临在感和稳定性。\n例如: 广藿香、橡苔、泥土、蘑菇',
                    fresh_desc: '清爽、清晰、更新\n\n清晨的空气和山泉。清除思维迷雾并刺激清晰度。\n例如: 桉树、海洋、薄荷、松树',
                    spicy_desc: '温暖、强烈、刺激\n\n唤醒的炽热。磨砺反射并加速处理。\n例如: 肉桂、丁香、生姜、黑胡椒',
                    mod1_intro: '数清游过的鱼群',
                    mod2_intro: '在噪声中捕捉信号',
                    mod3_intro: '稳定现实,破解模式',
                    mod4_intro: '对齐频率波形',
                    mod5_intro: '响应黑色目标',
                    mod6_intro: '跟随宇宙涡旋呼吸流动',
                    mod1_desc: '记忆: 计算游过的鱼群数量',
                    mod2_desc: '信号: 在噪声中保持专注力',
                    mod3_desc: '模式: 稳定并解决核心认知问题',
                    mod4_desc: '波形匹配: 对齐振荡频率',
                    mod5_desc: '反射: 击打黑点,避开红色干扰',
                    mod6_desc: '流动: 同步卡门涡街 (4-7-8)',
                    mod1_tut_title: '记忆:鱼群计数',
                    mod1_tut_desc: '观察鱼群游过屏幕。数清你看到了几条!第一轮:数1群。后续轮次:分别数2群。',
                    mod2_tut_title: '信号',
                    mod2_tut_desc: '信号在噪声中移动。用手指/鼠标精确捕捉并按住它,直到突破能量积累完成。',
                    mod3_tut_title: '模式识别',
                    mod3_tut_desc: '按住(移动设备双指按住,桌面端点击/按住)以稳定核心。快速回答认知问题。错误将扣分。',
                    mod4_tut_title: '频率波形匹配',
                    mod4_tut_desc: '艺术化波形在屏幕上振荡。通过优雅的滑条调整频率和振幅,让你的波形(红色)匹配目标波形(绿色)。每个阶段呈现独特的波形类型。',
                    mod5_tut_title: '反射:目标练习',
                    mod5_tut_desc: '3-2-1倒计时后,点会亮起。快速点击黑色点得分。避开红色点(会扣分)。错过黑点也会扣分。保持警觉!',
                    mod6_tut_title: '流动:卡门涡街',
                    mod6_tut_desc: '引导式4-7-8呼吸与流体动力学同步。吸气(4秒,按住)、屏息(7秒)、呼气(8秒,释放)。跟随卡门涡街模式。只有同步率。',
                }
            },
            set(lang) {
                this.lang = lang;
                document.querySelectorAll('[data-i18n]').forEach(el => {
                    const key = el.getAttribute('data-i18n');
                    if (this.data[lang][key]) el.textContent = this.data[lang][key];
                });
                
                document.querySelectorAll('#user-gender option').forEach(option => {
                    const key = option.dataset.i18n;
                    if (key) {
                        const baseText = option.value === '' ? (this.lang === 'zh' ? '选择性别' : 'Select gender') : (this.data.en[key] || '');
                        option.textContent = baseText + (this.lang === 'zh' ? ` / ${this.data.zh[key]}` : '');
                    }
                });
                document.querySelectorAll('#user-status option').forEach(option => {
                    const key = option.dataset.i18n;
                    if (key) {
                        const baseText = option.value === '' ? (this.lang === 'zh' ? '选择状态' : 'Select status') : (this.data.en[key] || '');
                        option.textContent = baseText + (this.lang === 'zh' ? ` / ${this.data.zh[key]}` : '');
                    }
                });

                if (App.state === 'MODULES') {
                    setTimeout(() => App.updateModules(), 10);
                }
                if (App.state === 'SCENT') LumenScent.updateLabels();
            },
            t(key) { return this.data[this.lang][key] || key; }
        };
        
        // ==================== LUMEN SCENT SYSTEM ====================
        const LumenScent = {
            scents: [
                { 
                    id: 'floral', 
                    en: 'Floral', 
                    zh: '花香', 
                    shape: 'flower', 
                    colors: [
                        { r: 255, g: 193, b: 182 },
                        { r: 255, g: 160, b: 160 },
                        { r: 232, g: 74, b: 95 }
                    ] 
                },
                { 
                    id: 'woody', 
                    en: 'Woody', 
                    zh: '木质', 
                    shape: 'trunk', 
                    colors: [
                        { r: 139, g: 69, b: 19 },
                        { r: 131, g: 90, b: 60 },
                        { r: 44, g: 23, b: 8 }
                    ] 
                },
                { 
                    id: 'citrus', 
                    en: 'Citrus', 
                    zh: '柑橘', 
                    shape: 'burst', 
                    colors: [
                        { r: 255, g: 240, b: 100 },
                        { r: 255, g: 215, b: 0 },
                        { r: 255, g: 180, b: 0 }
                    ] 
                },
                { 
                    id: 'earthy', 
                    en: 'Earthy', 
                    zh: '土壤', 
                    shape: 'moss', 
                    colors: [
                        { r: 85, g: 107, b: 47 },
                        { r: 76, g: 92, b: 23 },
                        { r: 36, g: 47, b: 20 }
                    ] 
                },
                { 
                    id: 'fresh', 
                    en: 'Fresh', 
                    zh: '清新', 
                    shape: 'wave', 
                    colors: [
                        { r: 155, g: 183, b: 212 },
                        { r: 100, g: 140, b: 180 },
                        { r: 58, g: 78, b: 107 }
                    ] 
                },
                { 
                    id: 'spicy', 
                    en: 'Spicy', 
                    zh: '辛香', 
                    shape: 'chili', 
                    colors: [
                        { r: 178, g: 34, b: 34 },
                        { r: 124, g: 34, b: 32 },
                        { r: 95, g: 33, b: 25 }
                    ] 
                }
            ],
            values: {},
            isActive: false,
            instances: [],
            currentPage: 0,
            dragging: null,

            init() {
                this.isActive = true;
                this.scents.forEach(scent => {
                    this.values[scent.id] = 0;
                });
                
                this.instances = [];
                
                this.scents.forEach((scent, idx) => {
                    const pageEl = document.querySelector(`.scent-page[data-page="${idx}"]`);
                    if (!pageEl) return; 

                    pageEl.innerHTML = '';
                    
                    const container = document.createElement('div');
                    container.style.cssText = 'width: 100%; display: flex; flex-direction: column; align-items: center; flex: 1;';
                    
                    const canvasWrapper = document.createElement('div');
                    canvasWrapper.style.cssText = 'position: relative; flex-shrink: 0; margin-bottom: 1rem;';
                    
                    const canvas = document.createElement('canvas');
                    canvas.className = 'lumen-canvas';
                    
                    const isMobile = window.innerWidth <= 768;
                    const size = isMobile ? Math.min(280, window.innerWidth - 40) : Math.min(350, window.innerWidth - 60);
                    canvas.width = size;
                    canvas.height = size;
                    canvasWrapper.appendChild(canvas);
                    container.appendChild(canvasWrapper);
                    
                    const label = document.createElement('div');
                    label.className = 'lumen-label';
                    label.innerHTML = `
                        <div class="lumen-name ${I18N.lang === 'zh' ? 'zh' : ''}" data-scent="${scent.id}">${scent[I18N.lang]}</div>
                        <div class="lumen-value" data-value="${scent.id}">0</div>
                        <p class="lumen-instruction">
                            ${I18N.lang === 'en' ? 'Drag outward from center' : '从中心向外拖动'}
                        </p>
                    `;
                    container.appendChild(label);
                    
                    const introBox = document.createElement('div');
                    introBox.className = `scent-intro-box ${I18N.lang === 'zh' ? 'zh' : ''}`;
                    introBox.dataset.scent = scent.id;
                    const key = `${scent.id}_desc`;
                    introBox.textContent = I18N.t(key);
                    container.appendChild(introBox);
                    
                    pageEl.appendChild(container);
                    
                    const instance = new LumenOrganicParticles(canvas, scent, this);
                    this.instances.push(instance);
                    
                    this.addRadialInteraction(canvas, scent.id, instance);
                });
                
                this.updateLabels();
                ResourceManager.register('lumenscent', this);
            },

            update(deltaTime = 16.6) {
                if (App.state !== 'SCENT') return;
                this.instances.forEach(inst => inst.update(deltaTime));
            },

            addRadialInteraction(canvas, scentId, instance) {
                const getPointer = (e) => {
                    const rect = canvas.getBoundingClientRect();
                    const clientX = e.clientX || (e.touches && e.touches[0] && e.touches[0].clientX);
                    const clientY = e.clientY || (e.touches && e.touches[0] && e.touches[0].clientY);
                    if (!clientX || !clientY) return null;
                    
                    const x = clientX - rect.left;
                    const y = clientY - rect.top;
                    return { x, y };
                };
                
                const onStart = (e) => {
                    if (!this.isActive) return;
                    this.dragging = scentId;
                    instance.isDragging = true;
                    e.preventDefault();
                };
                
                const onMove = PerformanceUtils.throttle((e) => {
                    if (this.dragging !== scentId || !this.isActive) return;
                    
                    const pos = getPointer(e);
                    if (!pos) return;
                    
                    const centerX = canvas.width / 2;
                    const centerY = canvas.height / 2;
                    
                    const dx = pos.x - centerX;
                    const dy = pos.y - centerY;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    const maxDist = Math.min(centerX, centerY) * 0.8;
                    
                    const value = Math.min(100, Math.max(0, (dist / maxDist) * 100));
                    this.values[scentId] = Math.round(value);
                    
                    const valueEl = document.querySelector(`[data-value="${scentId}"]`);
                    if (valueEl) valueEl.textContent = this.values[scentId];
                    
                    instance.targetIntensity = this.values[scentId] / 100;
                    instance.dragAngle = Math.atan2(dy, dx);
                    instance.dragDist = dist / maxDist;
                    
                    Sound.playScentDrag(instance.dragDist, instance.dragAngle);
                    
                    e.preventDefault();
                }, 16);
                
                const onEnd = () => {
                    if (this.dragging === scentId) {
                        this.dragging = null;
                        instance.isDragging = false;
                        Sound.stopScentDrag();
                    }
                };
                
                // Store listeners on instance for cleanup
                instance.listeners = { onStart, onMove, onEnd };
                
                canvas.addEventListener('mousedown', onStart);
                canvas.addEventListener('touchstart', onStart, { passive: false });
                
                document.addEventListener('mousemove', onMove);
                document.addEventListener('touchmove', onMove, { passive: false });
                
                document.addEventListener('mouseup', onEnd);
                document.addEventListener('touchend', onEnd);
                
                canvas.addEventListener('contextmenu', e => e.preventDefault());
            },
            
            prevPage() {
                if (this.currentPage > 0) {
                    this.goToPage(this.currentPage - 1);
                    Sound.play('click');
                }
            },
            
            nextPage() {
                if (this.currentPage < 5) {
                    this.goToPage(this.currentPage + 1);
                    Sound.play('click');
                }
            },
            
            goToPage(page) {
                const pages = document.querySelectorAll('.scent-page');
                const dots = document.querySelectorAll('.page-dot');
                
                pages[this.currentPage].classList.remove('active');
                pages[this.currentPage].classList.add('prev');
                
                pages[page].classList.remove('prev');
                pages[page].classList.add('active');
                
                dots[this.currentPage].classList.remove('active');
                dots[page].classList.add('active');
                
                this.currentPage = page;
                
                document.getElementById('scent-prev').style.opacity = page === 0 ? '0.3' : '1';
                document.getElementById('scent-next').style.opacity = page === 5 ? '0.3' : '1';
                
                this.updateLabels();
            },
            
            updateLabels() {
                document.querySelectorAll('.scent-intro-box').forEach(introEl => {
                    const scentId = introEl.dataset.scent;
                    if (scentId) {
                        introEl.classList.toggle('zh', I18N.lang === 'zh');
                        const key = `${scentId}_desc`;
                        introEl.textContent = I18N.t(key);
                    }
                });

                this.scents.forEach(scent => {
                    const el = document.querySelector(`[data-scent="${scent.id}"]`);
                    if (el && el.classList.contains('lumen-name')) {
                        el.textContent = scent[I18N.lang];
                        el.className = `lumen-name ${I18N.lang === 'zh' ? 'zh' : ''}`;
                    }
                });
                
                document.querySelectorAll('.lumen-instruction').forEach(instr => {
                    instr.textContent = I18N.lang === 'en' ? 'Drag outward from center' : '从中心向外拖动';
                });
            },
            
            cleanup() {
                console.log('🧹 Cleaning up LumenScent...');
                this.isActive = false;
                
                this.instances.forEach(instance => {
                    if (instance.listeners) {
                        const canvas = instance.canvas;
                        const { onStart, onMove, onEnd } = instance.listeners;
                        
                        if (canvas && onStart) {
                            canvas.removeEventListener('mousedown', onStart);
                            canvas.removeEventListener('touchstart', onStart);
                        }
                        if (onMove) {
                            document.removeEventListener('mousemove', onMove);
                            document.removeEventListener('touchmove', onMove);
                        }
                        if (onEnd) {
                            document.removeEventListener('mouseup', onEnd);
                            document.removeEventListener('touchend', onEnd);
                        }
                    }
                });
                
                this.instances = [];
                this.dragging = null;
                console.log('✓ LumenScent cleaned up');
            }
        };
        
        // ==================== LUMEN ORGANIC PARTICLES ====================
        class LumenOrganicParticles {
            constructor(canvas, scent, parent) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d', { alpha: true, willReadFrequently: false });
                this.scent = scent;
                this.parent = parent;
                this.particles = [];
                this.time = 0;
                this.intensity = 0;
                this.targetIntensity = 0;
                this.isDragging = false;
                this.dragAngle = 0;
                this.dragDist = 0;
                this.listeners = null;
                
                // Adaptive particle count for scent visualization
                const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
                const numParticles = isMobile ? 1000 : 2000;
                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;
                
                for (let i = 0; i < numParticles; i++) {
                    const layer = Math.random();
                    const angle = Math.random() * Math.PI * 2;
                    
                    let radius, distribution, sizeBase;
                    
                    switch(scent.shape) {
                        case 'flower':
                            const petalIndex = Math.floor(Math.random() * 6);
                            const petalAngle = (petalIndex / 6) * Math.PI * 2;
                            const petalOffset = Math.sin((angle - petalAngle) * 6) * 0.4 + 0.6;
                            radius = Math.pow(Math.random(), 0.4) * 90 * petalOffset;
                            distribution = Math.sin(angle * 6) * 0.4 + 0.8;
                            sizeBase = 1.8;
                            break;
                        case 'trunk':
                            const grainLayer = Math.floor(Math.random() * 15);
                            const grainNoise = (Math.sin(angle * 20 + grainLayer * 0.5) + Math.cos(angle * 15)) * 0.15;
                            radius = (grainLayer / 15) * 80 + grainNoise * 10 + Math.random() * 4;
                            distribution = Math.abs(Math.sin(angle * 18 + grainLayer * 0.3)) * 0.3 + 0.75;
                            sizeBase = 1.4;
                            break;
                        case 'burst':
                            const burstRing = Math.floor(Math.random() * 8);
                            radius = Math.pow(Math.random(), 0.25) * 95 * (0.7 + burstRing / 16);
                            distribution = 1;
                            sizeBase = 1.6;
                            break;
                        case 'moss':
                            const mossCluster = Math.sin(angle * 7 + Math.random() * 3) * 0.3;
                            radius = Math.pow(Math.random(), 0.8) * 75 + mossCluster * 15;
                            distribution = (Math.sin(angle * 6) + Math.cos(angle * 9)) * 0.25 + 0.7;
                            sizeBase = 2.2;
                            break;
                        case 'wave':
                            const waveLayer = Math.floor(Math.random() * 8);
                            radius = Math.pow(Math.random(), 0.65) * 65 * (0.5 + waveLayer / 16);
                            distribution = Math.abs(Math.cos(angle * 5 + Math.sin(angle * 2) * 2)) * 0.35 + 0.7;
                            sizeBase = 1.4;
                            break;
                        case 'chili':
                            const spiceIntensity = Math.pow(Math.random(), 0.5);
                            radius = spiceIntensity * 80;
                            distribution = Math.pow(Math.abs(Math.sin(angle * 10)), 1.5) * 0.6 + 0.5;
                            sizeBase = 1.3;
                            break;
                        default:
                            radius = Math.pow(Math.random(), 0.6) * 70;
                            distribution = 1;
                            sizeBase = 2.0;
                    }
                    
                    radius *= distribution;
                    
                    const x = centerX + Math.cos(angle) * radius;
                    const y = centerY + Math.sin(angle) * radius;
                    
                    this.particles.push({
                        baseX: x,
                        baseY: y,
                        x: x,
                        y: y,
                        angle: angle,
                        radius: radius,
                        size: Math.random() * sizeBase + 0.8,
                        speedX: (Math.random() - 0.5) * 0.2,
                        speedY: (Math.random() - 0.5) * 0.2,
                        breathPhase: Math.random() * Math.PI * 2,
                        layer: layer,
                        energy: Math.random(),
                        noiseOffset: Math.random() * 100
                    });
                }
            }
            
            update(deltaTime = 16.6) {
                this.time += deltaTime / 1000;
                
                const diff = this.targetIntensity - this.intensity;
                this.intensity += diff * 0.12;
                
                const ctx = this.ctx;
                const w = this.canvas.width;
                const h = this.canvas.height;
                const centerX = w / 2;
                const centerY = h / 2;
                
                ctx.fillStyle = 'rgba(245, 245, 240, 0.95)';
                ctx.fillRect(0, 0, w, h);
                
                const colors = this.scent.colors;
                
                const globalBreath = Math.sin(this.time * 0.5) * 0.5 + 0.5;
                
                this.particles.forEach(p => {
                    const breathe = Math.sin(this.time * 0.7 + p.breathPhase) * 0.5 + 0.5;
                    const breathScale = 1 + (breathe * 0.1 + globalBreath * 0.05);
                    
                    const maxExpansion = this.scent.shape === 'wave' ? 1.8 : 2.5;
                    const expansion = this.intensity * maxExpansion;
                    
                    let targetX = centerX + (p.baseX - centerX) * (1 + expansion) * breathScale;
                    let targetY = centerY + (p.baseY - centerY) * (1 + expansion) * breathScale;
                    
                    if (this.isDragging) {
                        const dragInfluence = this.intensity * 0.6;
                        const particleAngleToDrag = Math.atan2(p.baseY - centerY, p.baseX - centerX);
                        const angleDiff = Math.abs(particleAngleToDrag - this.dragAngle);
                        const angleProximity = Math.cos(angleDiff);
                        
                        const dragForce = dragInfluence * angleProximity * (1 - p.layer * 0.5);
                        targetX += Math.cos(this.dragAngle) * this.dragDist * dragForce * 180;
                        targetY += Math.sin(this.dragAngle) * this.dragDist * dragForce * 180;
                    }
                    
                    p.x += (targetX - p.x) * 0.2 + p.speedX * (1 - this.intensity * 0.7);
                    p.y += (targetY - p.y) * 0.2 + p.speedY * (1 - this.intensity * 0.7);
                    
                    let r, g, b;
                    const energyBoost = p.energy * 0.2;
                    
                    if (this.intensity < 0.5) {
                        const t = this.intensity / 0.5;
                        r = colors[0].r + (colors[1].r - colors[0].r) * t;
                        g = colors[0].g + (colors[1].g - colors[0].g) * t;
                        b = colors[0].b + (colors[1].b - colors[0].b) * t;
                    } else {
                        const t = (this.intensity - 0.5) / 0.5;
                        r = colors[1].r + (colors[2].r - colors[1].r) * t;
                        g = colors[1].g + (colors[2].g - colors[1].g) * t;
                        b = colors[1].b + (colors[2].b - colors[1].b) * t;
                    }
                    
                    r = Math.min(255, r + energyBoost * 30);
                    g = Math.min(255, g + energyBoost * 25);
                    b = Math.min(255, b + energyBoost * 20);
                    
                    const baseSize = p.size * (0.8 + this.intensity * 2.0);
                    const size = baseSize * (1 + breathe * 0.3) * (0.7 + p.layer * 0.6);
                    
                    const baseAlpha = 0.2 + this.intensity * 0.85;
                    const alpha = baseAlpha * (0.6 + p.layer * 0.7);
                    
                    ctx.fillStyle = `rgba(${Math.round(r)}, ${Math.round(g)}, ${Math.round(b)}, ${alpha})`;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, size, 0, Math.PI * 2);
                    ctx.fill();
                    
                    if (this.intensity > 0.4) {
                        const glowAlpha = (this.intensity - 0.4) * 0.3 * alpha;
                        ctx.fillStyle = `rgba(${Math.round(r)}, ${Math.round(g)}, ${Math.round(b)}, ${glowAlpha})`;
                        ctx.beginPath();
                        ctx.arc(p.x, p.y, size * 4, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    
                    if (this.intensity > 0.75) {
                        const outerGlow = (this.intensity - 0.75) * 0.2;
                        ctx.fillStyle = `rgba(${Math.round(r)}, ${Math.round(g)}, ${Math.round(b)}, ${outerGlow})`;
                        ctx.beginPath();
                        ctx.arc(p.x, p.y, size * 7, 0, Math.PI * 2);
                        ctx.fill();
                    }
                });
                
                if (this.intensity > 0.7) {
                    const gradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, 200);
                    const c = colors[Math.min(2, Math.floor(this.intensity * 3))];
                    const bloomIntensity = (this.intensity - 0.7) * 0.5;
                    gradient.addColorStop(0, `rgba(${c.r}, ${c.g}, ${c.b}, ${bloomIntensity})`);
                    gradient.addColorStop(0.5, `rgba(${c.r}, ${c.g}, ${c.b}, ${bloomIntensity * 0.3})`);
                    gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, w, h);
                }
            }
        }
        
        // ==================== APP CORE ====================
        const App = {
            state: 'WELCOME',
            patient: {},
            scents: {},
            modules: {},
            completed: new Set(),
            current: null,
            tOC: 20,
            
            screens: {
                WELCOME: 'welcome-screen',
                INFO: 'info-screen', 
                SCENT: 'scent-screen',
                MODULES: 'module-selection-screen',
                GAME: 'game-screen',
                RESULTS: 'results-screen'
            },

            resetAllResources() {
                console.log('🔄 Resetting all resources...');
                ResourceManager.cleanupAll();
            },
            
            setState(s) {
                console.log(`📍 State change: ${this.state} → ${s}`);
                
                // Clean up previous state resources
                if (this.state === 'SCENT') {
                    ResourceManager.unregister('lumenscent');
                }
                if (this.state === 'GAME') {
                    ResourceManager.unregister('gamemodule');
                }
                
                document.querySelectorAll('.screen').forEach(el => el.classList.remove('active'));
                document.getElementById(this.screens[s]).classList.add('active');
                this.state = s;
                
                document.getElementById('crystal-container').style.display = 'none';
                document.getElementById('reflex-canvas').style.display = 'none';
                document.getElementById('mod4-canvas').style.display = 'none';
                
                if (s === 'GAME') {
                    document.getElementById('game-ui').classList.add('active');
                    document.getElementById('game-stats').classList.add('active');
                    document.getElementById('back-btn').classList.add('active');
                } else {
                    document.getElementById('game-ui').classList.remove('active');
                    document.getElementById('game-stats').classList.remove('active');
                    document.getElementById('back-btn').classList.remove('active');
                }
                
                if (s === 'SCENT') setTimeout(() => LumenScent.init(), 100);
                if (s === 'MODULES') setTimeout(() => this.updateModules(), 10);
                
                Visual.setScene(s);
            },
            
            startModule(id) {
                this.current = id;
                this.setState('GAME');
                
                setTimeout(() => {
                    GameEngine.showTutorial(id);
                }, 100);
            },
            
            completeModule(id, data) {
                // 只保存数据，不自动跳转
                this.completed.add(id);
                this.modules[id] = data;
                Sound.play('success');
                // 不再自动跳转到模块列表
                // this.setState('MODULES');  // 移除自动跳转
                this.updateModules();
                console.log(`✓ Module ${id} data saved (no auto-exit)`);
            },
            
            updateModules() {
                const grid = document.getElementById('module-gallery');
                grid.innerHTML = '';
                
                Object.entries(MODULES).forEach(([id, m]) => {
                    const cell = document.createElement('div');
                    cell.className = 'module-cell';
                    if (this.completed.has(id)) cell.classList.add('completed');
                    
                    const lang = I18N.lang;
                    cell.innerHTML = `
                        <h3 class="${lang === 'zh' ? 'zh' : 'serif'}">${m.title[lang]}</h3>
                        <p class="subtitle">${m.subtitle[lang]}</p>
                        <p class="description">${m.desc[lang]}</p>
                    `;
                    
                    cell.addEventListener('mouseenter', () => Sound.play('hover'));
                    cell.addEventListener('click', () => {
                        Sound.play('click');
                        this.startModule(id);
                    });
                    grid.appendChild(cell);
                });
            },
            
            finish() {
                if (this.completed.size === 0) return;
                Sound.play('success');
                this.setState('RESULTS');
                setTimeout(() => this.showResults(), 100);
            },
            
            drawWheel() {
                const container = document.getElementById('scent-wheel');
                container.innerHTML = '';
                const canvas = document.createElement('canvas');
                const size = Math.min(400, container.clientWidth);
                canvas.width = size;
                canvas.height = size;
                container.appendChild(canvas);
                
                const ctx = canvas.getContext('2d');
                const cx = size / 2, cy = size / 2, r = size * 0.32;
                
                for (let i = 1; i <= 4; i++) {
                    ctx.beginPath();
                    ctx.arc(cx, cy, r * (i / 4), 0, Math.PI * 2);
                    ctx.strokeStyle = 'rgba(192, 38, 37, 0.2)';
                    ctx.lineWidth = 1;
                    ctx.stroke();
                }
                
                const cats = Object.keys(this.scents);
                const step = (Math.PI * 2) / cats.length;
                
                ctx.beginPath();
                cats.forEach((cat, i) => {
                    const angle = step * i - Math.PI / 2;
                    const val = this.scents[cat] / 100;
                    const x = cx + Math.cos(angle) * r * val;
                    const y = cy + Math.sin(angle) * r * val;
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                });
                ctx.closePath();
                ctx.fillStyle = 'rgba(192, 38, 37, 0.15)';
                ctx.fill();
                ctx.strokeStyle = '#c02625';
                ctx.lineWidth = 2.5;
                ctx.stroke();
                
                ctx.strokeStyle = 'rgba(192, 38, 37, 0.15)';
                ctx.lineWidth = 1;
                cats.forEach((cat, i) => {
                    const angle = step * i - Math.PI / 2;
                    ctx.beginPath();
                    ctx.moveTo(cx, cy);
                    ctx.lineTo(cx + Math.cos(angle) * r, cy + Math.sin(angle) * r);
                    ctx.stroke();
                });
                
                ctx.fillStyle = '#c02625';
                cats.forEach((cat, i) => {
                    const angle = step * i - Math.PI / 2;
                    const val = this.scents[cat] / 100;
                    const x = cx + Math.cos(angle) * r * val;
                    const y = cy + Math.sin(angle) * r * val;
                    
                    ctx.beginPath();
                    ctx.arc(x, y, 4, 0, Math.PI * 2);
                    ctx.fill();
                });
                
                ctx.fillStyle = '#2a2a2a';
                ctx.font = '11px Inter';
                ctx.textAlign = 'center';
                cats.forEach((cat, i) => {
                    const angle = step * i - Math.PI / 2;
                    const labelDist = r + 30;
                    const x = cx + Math.cos(angle) * labelDist;
                    const y = cy + Math.sin(angle) * labelDist + 4;
                    ctx.fillText(cat.toUpperCase(), x, y);
                });
            },

            drawReportVisualization() {
                const data = Object.entries(this.modules).map(([id, d]) => {
                    let normalizedScore = d.score;
                    if (id === '5' && d.score > 0) { 
                        normalizedScore = Math.min(100, Math.max(0, 100 - (d.score - 200) / 3));
                    }
                    return {
                        module: MODULES[id].title[I18N.lang],
                        score: normalizedScore,
                        rawScore: d.score,
                        id: id 
                    };
                });

                const container = document.getElementById('report-visualization');
                container.innerHTML = '';

                const margin = { top: 20, right: 20, bottom: 60, left: 40 };
                const width = container.clientWidth - margin.left - margin.right;
                const height = container.clientHeight - margin.top - margin.bottom;

                if (width <= 0 || height <= 0) return;

                const svg = d3.select(container)
                    .append("svg")
                    .attr("width", width + margin.left + margin.right)
                    .attr("height", height + margin.top + margin.bottom)
                    .append("g")
                    .attr("transform", `translate(${margin.left},${margin.top})`);

                const x = d3.scaleBand()
                    .domain(data.map(d => d.module))
                    .range([0, width])
                    .padding(0.1);

                const y = d3.scaleLinear()
                    .domain([0, 100])
                    .range([height, 0]);
                
                const colorScale = d3.scaleSequential(d3.interpolateInferno).domain([0, 100]);

                svg.append("g")
                    .attr("transform", `translate(0,${height})`)
                    .call(d3.axisBottom(x))
                    .selectAll("text")
                        .style("font-size", "10px")
                        .style("text-anchor", "end")
                        .attr("dx", "-.8em")
                        .attr("dy", ".15em")
                        .attr("transform", "rotate(-45)");

                svg.append("g")
                    .call(d3.axisLeft(y).tickFormat(d => `${d}%`))
                    .selectAll("text")
                    .style("fill", "#2a2a2a");

                svg.selectAll(".bar")
                    .data(data)
                    .enter().append("rect")
                    .attr("class", "bar")
                    .attr("x", d => x(d.module))
                    .attr("y", d => y(d.score))
                    .attr("width", x.bandwidth())
                    .attr("height", d => height - y(d.score))
                    .attr("fill", d => colorScale(d.score))
                    .on("mouseover", function(event, d) {
                        d3.select(this).attr("opacity", 0.8);
                        
                        const tooltipText = d.id === '5' ? `${Math.round(d.rawScore)} ms RT` : `${Math.round(d.score)}% Eff.`;
                        
                        svg.append("text")
                            .attr("id", "tooltip")
                            .attr("x", x(d.module) + x.bandwidth() / 2)
                            .attr("y", y(d.score) - 5)
                            .attr("text-anchor", "middle")
                            .style("font-size", "12px")
                            .style("fill", "#c02625")
                            .text(tooltipText);
                    })
                    .on("mouseout", function() {
                        d3.select(this).attr("opacity", 1.0);
                        d3.select("#tooltip").remove();
                    });
            },

            showResults() {
                const summary = document.getElementById('results-summary');
                summary.innerHTML = '';
                
                const totalTime = Object.values(this.modules).reduce((sum, d) => sum + (d.time || 0), 0);
                const avgScore = Object.values(this.modules).reduce((sum, d) => sum + (d.score || 0), 0) / this.completed.size;
                
                const summaryData = [
                    { key: 'modules_completed', value: this.completed.size },
                    { key: 'total_time', value: Math.round(totalTime) + 's' },
                    { key: 'avg_score', value: this.completed.has('5') ? 'N/A*' : Math.round(avgScore) }
                ];
                
                summaryData.forEach(item => {
                    const div = document.createElement('div');
                    div.className = 'summary-item';
                    div.innerHTML = `
                        <h4>${I18N.t(item.key)}</h4>
                        <div class="value">${item.value}</div>
                    `;
                    summary.appendChild(div);
                });
                
                const details = document.getElementById('results-details');
                details.innerHTML = '';
                
                Object.entries(this.modules).forEach(([id, data]) => {
                    const row = document.createElement('div');
                    row.className = 'detail-row';
                    const lang = I18N.lang;
                    const scoreText = id === '5' ? `${Math.round(data.score)} ms RT` : `${Math.round(data.score)} pts`;

                    row.innerHTML = `
                        <span class="detail-label ${lang === 'zh' ? 'zh' : ''}">${MODULES[id].title[lang]}</span>
                        <span class="detail-value">${scoreText} · ${Math.round(data.time)}s</span>
                    `;
                    details.appendChild(row);
                });
                
                let rec = [];
                const avgErrors = Object.values(this.modules).reduce((sum, d) => sum + (d.errors || 0), 0) / this.completed.size;
                const scentValues = this.scents;
                
                if (avgScore > 70) {
                    if (scentValues.floral > 60) rec.push('Jasmine');
                    if (scentValues.citrus > 60) rec.push('Bergamot');
                } else if (avgScore > 40) {
                    if (scentValues.woody > 50) rec.push('Sandalwood');
                    if (scentValues.earthy > 50) rec.push('Vetiver');
                    rec.push('Rosemary');
                } else {
                    rec.push('Lavender');
                    if (scentValues.fresh > 50) rec.push('Peppermint');
                    rec.push('Frankincense');
                }
                
                if (avgErrors > 10) rec.push('Chamomile');
                if (avgErrors < 3 && !rec.includes('Bergamot')) rec.push('Lemon');
                
                Object.entries(scentValues).forEach(([scent, value]) => {
                    if (value > 80) {
                        const map = {
                            floral: 'Rose',
                            woody: 'Cedar',
                            citrus: 'Orange',
                            earthy: 'Patchouli',
                            fresh: 'Eucalyptus',
                            spicy: 'Cinnamon'
                        };
                        if (!rec.includes(map[scent])) rec.push(map[scent]);
                    }
                });
                
                if (rec.length === 0) rec.push('Balanced Blend');
                
                document.getElementById('scent-result').textContent = rec.slice(0, 4).join(' + ');
                
                this.drawWheel();
                this.drawReportVisualization();
            },
        };
        
        // ==================== VISUAL SYSTEM ====================
        const Visual = {
            scene: null,
            camera: null,
            renderer: null,
            current: null,
            animating: false,
            lastTime: 0,
            
            init() {
                try {
                    this.scene = new THREE.Scene();
                    this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                    this.camera.position.z = 5;
                    
                    const canvas = document.getElementById('canvas3d');
                    if (!canvas) throw new Error('Canvas not found');
                    
                    this.renderer = new THREE.WebGLRenderer({
                        canvas: canvas,
                        antialias: window.devicePixelRatio < 2,
                        alpha: true,
                        powerPreference: 'high-performance',
                        stencil: false,
                        depth: true
                    });
                    
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                    this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                    
                    const throttledResize = PerformanceUtils.throttle(() => this.resize(), 250);
                    window.addEventListener('resize', throttledResize);
                    
                    this.setScene('WELCOME');
                    this.lastTime = performance.now();
                    this.animate();
                    
                    return true;
                } catch(e) {
                    console.error('Visual init error:', e);
                    return false;
                }
            },
            
            resize() {
                if (!this.camera || !this.renderer) return;
                
                this.camera.aspect = window.innerWidth / window.innerHeight;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                
                if (App.state === 'RESULTS') App.drawReportVisualization(); 
            },
            
            setScene(state) {
                try {
                    console.log(`🎬 Setting scene for state: ${state}`);
                    
                    // Thoroughly clean up existing scene
                    if (this.scene) {
                        // Recursively dispose all objects
                        const disposeObject = (obj) => {
                            if (!obj) return;
                            
                            // Remove from parent
                            if (obj.parent) {
                                obj.parent.remove(obj);
                            }
                            
                            // Dispose geometry
                            if (obj.geometry) {
                                obj.geometry.dispose();
                            }
                            
                            // Dispose material(s)
                            if (obj.material) {
                                if (Array.isArray(obj.material)) {
                                    obj.material.forEach(m => {
                                        if (m.map) m.map.dispose();
                                        if (m.lightMap) m.lightMap.dispose();
                                        if (m.bumpMap) m.bumpMap.dispose();
                                        if (m.normalMap) m.normalMap.dispose();
                                        if (m.specularMap) m.specularMap.dispose();
                                        if (m.envMap) m.envMap.dispose();
                                        m.dispose();
                                    });
                                } else {
                                    if (obj.material.map) obj.material.map.dispose();
                                    if (obj.material.lightMap) obj.material.lightMap.dispose();
                                    if (obj.material.bumpMap) obj.material.bumpMap.dispose();
                                    if (obj.material.normalMap) obj.material.normalMap.dispose();
                                    if (obj.material.specularMap) obj.material.specularMap.dispose();
                                    if (obj.material.envMap) obj.material.envMap.dispose();
                                    obj.material.dispose();
                                }
                            }
                            
                            // Recursively dispose children
                            if (obj.children) {
                                while (obj.children.length > 0) {
                                    disposeObject(obj.children[0]);
                                }
                            }
                        };
                        
                        // Clear all scene children
                        while (this.scene.children.length > 0) {
                            disposeObject(this.scene.children[0]);
                        }
                    }
                    
                    this.current = null;
                    
                    // Create new ambient particles for non-game states
                    if (state === 'WELCOME' || state === 'INFO' || state === 'SCENT' || state === 'MODULES' || state === 'RESULTS') {
                        const geom = new THREE.BufferGeometry();
                        const particleCount = 500;
                        const pos = new Float32Array(particleCount * 3);
                        
                        for (let i = 0; i < particleCount; i++) {
                            pos[i*3] = (Math.random() - 0.5) * 20;
                            pos[i*3+1] = (Math.random() - 0.5) * 20;
                            pos[i*3+2] = (Math.random() - 0.5) * 20;
                        }
                        
                        geom.setAttribute('position', new THREE.BufferAttribute(pos, 3));
                        
                        const mat = new THREE.PointsMaterial({ 
                            size: 0.035, 
                            color: 0xc02625, 
                            transparent: true, 
                            opacity: 0.4
                        });
                        
                        this.current = new THREE.Points(geom, mat);
                        this.scene.add(this.current);
                    }
                    
                    console.log(`✅ Scene set for ${state}`);
                } catch(e) {
                    console.error('❌ setScene error:', e);
                    // Try to at least clear the scene
                    try {
                        if (this.scene) {
                            while (this.scene.children.length > 0) {
                                this.scene.remove(this.scene.children[0]);
                            }
                        }
                    } catch(clearErr) {
                        console.error('Scene clear failed:', clearErr);
                    }
                }
            },
            
            animate() {
                requestAnimationFrame(() => this.animate());
                
                const now = performance.now();
                const deltaTime = Math.min((now - this.lastTime) / 1000, 0.1); // Cap deltaTime to prevent huge jumps
                this.lastTime = now;
                
                try {
                    // Rotate background particles
                    if (this.current && this.current.rotation) {
                        this.current.rotation.y += 0.05 * deltaTime;
                        this.current.rotation.x += 0.02 * deltaTime;
                    }

                    // Update game module if active
                    if (App.state === 'GAME' && GameEngine.module && !GameEngine.isLoading) {
                        try {
                            GameEngine.update(GameEngine.stats, deltaTime);
                        } catch(gameErr) {
                            console.error('❌ Game update error:', gameErr);
                            // 不再自动退出 - 让用户决定何时退出
                            // 只停止当前模块的更新
                            if (GameEngine.module) {
                                GameEngine.module.isActive = false;
                            }
                        }
                    } else if (App.state === 'SCENT') {
                        try {
                            LumenScent.update(deltaTime);
                        } catch(scentErr) {
                            console.error('Scent update error:', scentErr);
                        }
                    }
                    
                    // Render scene
                    if (this.renderer && this.scene && this.camera) {
                        this.renderer.render(this.scene, this.camera);
                    }
                } catch(e) {
                    console.error('❌ Critical render error:', e);
                    // Try to recover renderer
                    setTimeout(() => {
                        try {
                            if (!this.renderer || !this.scene || !this.camera) {
                                console.log('🔄 Attempting to reinitialize Visual system...');
                                this.init();
                            }
                        } catch(reinitErr) {
                            console.error('Reinit failed:', reinitErr);
                        }
                    }, 100);
                }
            }
        };

        // ==================== GAME ENGINE (WITH DELAYED LOADING) ====================
        const GameEngine = {
            module: null,
            t0: 0,
            stats: { time: 0, score: 0, progress: 0, errors: 0 },
            isLoading: false,
            currentModuleId: null,
            
            start(id) {
                // Prevent loading the same module twice
                if (this.currentModuleId === id && this.module) {
                    console.warn(`⚠️ Module ${id} is already loaded`);
                    return;
                }
                
                if (this.isLoading) {
                    console.warn('⚠️ Module still loading, please wait...');
                    return;
                }
                
                // Clean up any existing module first
                if (this.module) {
                    console.log('🧹 Cleaning up previous module before loading new one...');
                    try {
                        ResourceManager.unregister('gamemodule');
                        this.module = null;
                    } catch(cleanErr) {
                        console.error('Previous module cleanup error:', cleanErr);
                    }
                }
                
                this.isLoading = true;
                this.currentModuleId = id;
                console.log(`🔄 Loading Module ${id}...`);
                
                // Hide all canvas elements
                document.getElementById('crystal-container').style.display = 'none';
                document.getElementById('reflex-canvas').style.display = 'none';
                document.getElementById('mod4-canvas').style.display = 'none';

                // Safety timeout - if module doesn't load in 5 seconds, warn user
                const safetyTimeout = setTimeout(() => {
                    if (this.isLoading) {
                        console.error('⏱️ Module load timeout - 模块加载超时');
                        this.isLoading = false;
                        ResourceManager.unregister('gamemodule');
                        // 不自动跳转 - 显示错误信息让用户决定
                        alert('Module failed to load. Please use the "SAVE & EXIT" button to return.');
                        // App.setState('MODULES');  // 移除自动跳转
                    }
                }, 5000);

                // Delay to ensure DOM is ready
                setTimeout(() => {
                    try {
                        // Create module instance
                        this.module = MODULES[id].create();
                        this.module.id = id;
                        this.t0 = Date.now();
                        this.stats = { time: 0, score: 0, progress: 0, errors: 0 }; 
                        
                        const lang = I18N.lang;
                        document.getElementById('game-title').textContent = MODULES[id].title[lang];
                        
                        // Show intro text
                        const introTextEl = document.getElementById('game-intro-text');
                        introTextEl.textContent = I18N.t(`mod${id}_intro`);
                        introTextEl.classList.add('active-intro');

                        setTimeout(() => {
                            introTextEl.classList.remove('active-intro');
                        }, 3000);
                        
                        // Delayed initialization with error handling
                        setTimeout(() => {
                            try {
                                if (this.module && this.module.init) {
                                    this.module.init();
                                    this.isLoading = false;
                                    clearTimeout(safetyTimeout);
                                    console.log(`✅ Module ${id} loaded successfully`);
                                }
                            } catch(initErr) {
                                console.error(`❌ Module ${id} init error:`, initErr);
                                this.isLoading = false;
                                clearTimeout(safetyTimeout);
                                ResourceManager.unregister('gamemodule');
                                // 不自动跳转 - 让用户手动退出
                                alert(`Module initialization failed: ${initErr.message}\nPlease use "SAVE & EXIT" button to return.`);
                                // App.setState('MODULES');  // 移除自动跳转
                            }
                        }, 100);
                        
                        // Register module for cleanup
                        ResourceManager.register('gamemodule', this.module);
                    } catch (error) {
                        console.error(`❌ Error loading Module ${id}:`, error);
                        this.isLoading = false;
                        clearTimeout(safetyTimeout);
                        // 不自动跳转 - 让用户手动退出
                        alert(`Failed to load module: ${error.message}\nPlease use "SAVE & EXIT" button to return.`);
                        // App.setState('MODULES');  // 移除自动跳转
                    }
                }, 100);
            },

            showTutorial(id) {
                const tutorial = document.getElementById('tutorial-overlay');
                const lang = I18N.lang;
                
                document.getElementById('tutorial-title').textContent = I18N.t(`mod${id}_tut_title`);
                document.getElementById('tutorial-text').textContent = I18N.t(`mod${id}_tut_desc`);

                tutorial.classList.add('active');

                document.getElementById('game-ui').classList.add('active');
                document.getElementById('game-stats').classList.add('active');
                document.getElementById('back-btn').classList.add('active');

                const startButton = document.getElementById('tutorial-start-btn');
                
                const newStartButton = startButton.cloneNode(true);
                startButton.parentNode.replaceChild(newStartButton, startButton);
                
                newStartButton.addEventListener('click', () => {
                    tutorial.classList.remove('active');
                    this.start(id);
                    Sound.play('click');
                });
            },
            
            update(stats, deltaTime) {
                if (!this.module || App.state !== 'GAME' || this.isLoading) return;
                
                try {
                    stats.time = (Date.now() - this.t0) / 1000;
                    this.module.update(stats, deltaTime);
                    
                    document.getElementById('stat-time').textContent = Math.round(stats.time) + 's';
                    
                    if (this.module.id === '5' && typeof stats.score === 'number' && stats.score > 0) {
                        document.getElementById('stat-score').textContent = `${Math.round(stats.score)}ms`;
                    } else if (this.module.id === '5') {
                        document.getElementById('stat-score').textContent = '0ms';
                    } else {
                        document.getElementById('stat-score').textContent = Math.round(stats.score);
                    }
                } catch (error) {
                    console.error('❌ Error in game update:', error);
                }
            },
            
            complete() {
                if (!this.module) return;
                
                const finalScore = this.stats.score;
                const data = { 
                    time: this.stats.time, 
                    score: finalScore || 0, 
                    errors: this.stats.errors 
                };
                
                ResourceManager.unregister('gamemodule');
                this.module = null;
                this.currentModuleId = null;
                this.isLoading = false;
                
                App.completeModule(App.current, data);
            }
        };
        
        // ==================== MODULES ====================
        const MODULES = {
            '1': { 
                title: { en: 'Memory Trace', zh: '记忆轨迹' }, 
                subtitle: { en: 'Fish School', zh: '鱼群' }, 
                desc: { en: I18N.data.en.mod1_desc, zh: I18N.data.zh.mod1_desc }, 
                create: () => new Module1() 
            },
            '2': { 
                title: { en: 'Signal', zh: '信号' }, 
                subtitle: { en: 'Sustained Attention', zh: '持续注意力' }, 
                desc: { en: I18N.data.en.mod2_desc, zh: I18N.data.zh.mod2_desc }, 
                create: () => new Module2() 
            },
            '3': { 
                title: { en: 'Pattern', zh: '模式' }, 
                subtitle: { en: 'Cognitive Recognition', zh: '认知识别' }, 
                desc: { en: I18N.data.en.mod3_desc, zh: I18N.data.zh.mod3_desc }, 
                create: () => new Module3() 
            },
            '4': { 
                title: { en: 'Wave Match', zh: '波形匹配' }, 
                subtitle: { en: 'Frequency Align', zh: '频率对齐' }, 
                desc: { en: I18N.data.en.mod4_desc, zh: I18N.data.zh.mod4_desc }, 
                create: () => new Module4() 
            },
            '5': { 
                title: { en: 'Reflex', zh: '反射' }, 
                subtitle: { en: 'Precision Target', zh: '精确目标' }, 
                desc: { en: I18N.data.en.mod5_desc, zh: I18N.data.zh.mod5_desc }, 
                create: () => new Module5() 
            },
            '6': { 
                title: { en: 'Flow', zh: '流动' }, 
                subtitle: { en: 'Deep Presence', zh: '深层临在' }, 
                desc: { en: I18N.data.en.mod6_desc, zh: I18N.data.zh.mod6_desc }, 
                create: () => new Module6() 
            }
        };
        
        // ==================== MODULE 1: FISH SCHOOL COUNTER ====================
        class Module1 {
            init() {
                console.log('🐟 Module 1 initializing...');
                this.isActive = true;
                this.canvas = document.createElement('canvas');
                this.canvas.style.cssText = 'position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); max-width: 90vw; max-height: 70vh; border: 2px solid rgba(192, 38, 37, 0.3); background: #f5f5f0;';
                
                const size = Math.min(window.innerWidth * 0.9, window.innerHeight * 0.7, 600);
                this.canvas.width = size;
                this.canvas.height = size;
                this.ctx = this.canvas.getContext('2d');
                
                document.getElementById('game-screen').appendChild(this.canvas);
                
                const difficulty = App.tOC;
                this.round = 0;
                this.maxRounds = 3 + Math.floor(difficulty / 30);
                this.currentPhase = 'showing';
                this.schools = [];
                this.userAnswers = [];
                this.correctAnswers = [];
                
                this.startRound();
            }
            
            startRound() {
                this.round++;
                this.currentPhase = 'showing';
                this.schools = [];
                this.correctAnswers = [];
                
                const numSchools = this.round === 1 ? 1 : 2;
                
                for (let s = 0; s < numSchools; s++) {
                    const numFish = 3 + Math.floor(Math.random() * 5);
                    this.correctAnswers.push(numFish);
                    
                    const school = {
                        fish: [],
                        shown: false,
                        showTime: s * 4000 + 1000
                    };
                    
                    const baseY = this.canvas.height / 2 + (s - 0.5) * 100;
                    const startX = -100;
                    
                    for (let i = 0; i < numFish; i++) {
                        school.fish.push({
                            x: startX - i * 60,
                            y: baseY + (Math.random() - 0.5) * 40,
                            size: 15 + Math.random() * 10,
                            speed: 2 + Math.random() * 1,
                            phase: Math.random() * Math.PI * 2,
                            particles: this.createFishParticles()
                        });
                    }
                    
                    this.schools.push(school);
                }
                
                this.animationStart = Date.now();
            }
            
            createFishParticles() {
                const particles = [];
                const numParticles = 30;
                for (let i = 0; i < numParticles; i++) {
                    particles.push({
                        angle: (i / numParticles) * Math.PI * 2,
                        dist: Math.random() * 8 + 5,
                        size: Math.random() * 2 + 1
                    });
                }
                return particles;
            }
            
            drawFish(fish, time) {
                const ctx = this.ctx;
                const wobble = Math.sin(time * 3 + fish.phase) * 3;
                
                fish.particles.forEach(p => {
                    const x = fish.x + Math.cos(p.angle) * p.dist;
                    const y = fish.y + Math.sin(p.angle) * p.dist + wobble;
                    
                    ctx.fillStyle = `rgba(255, 122, 92, ${0.6 + Math.random() * 0.3})`;
                    ctx.beginPath();
                    ctx.arc(x, y, p.size, 0, Math.PI * 2);
                    ctx.fill();
                });
            }
            
            showAnswerPrompt() {
                this.currentPhase = 'answering';
                const overlay = document.getElementById('question-overlay');
                const questionText = document.getElementById('question-text');
                const optionsDiv = document.getElementById('answer-options');
                
                const lang = I18N.lang;
                if (this.round === 1 || this.correctAnswers.length === 1) {
                    questionText.textContent = lang === 'en' ? 'How many fish did you see?' : '你看到了几条鱼?';
                } else {
                    questionText.textContent = lang === 'en' ? 
                        'First school count? Then second school count?' : 
                        '第一群有几条?第二群有几条?';
                }
                
                optionsDiv.innerHTML = '';
                
                const createInput = (placeholder) => {
                    const input = document.createElement('input');
                    input.type = 'number';
                    input.min = '1';
                    input.max = '20';
                    input.placeholder = placeholder;
                    input.style.cssText = 'width: 100%; padding: 1rem; margin-bottom: 0.8rem; border: 1px solid rgba(192, 38, 37, 0.3); font-size: 1rem;';
                    return input;
                };
                
                const input1 = createInput(this.correctAnswers.length === 1 ? 'Enter count' : 'First school');
                optionsDiv.appendChild(input1);
                
                let input2;
                if (this.correctAnswers.length === 2) {
                    input2 = createInput('Second school');
                    optionsDiv.appendChild(input2);
                }
                
                const submitBtn = document.createElement('button');
                submitBtn.className = 'btn accent';
                submitBtn.textContent = lang === 'en' ? 'SUBMIT' : '提交';
                submitBtn.style.cssText = 'width: 100%; margin-top: 1rem;';
                submitBtn.addEventListener('click', () => {
                    const ans1 = parseInt(input1.value);
                    const ans2 = input2 ? parseInt(input2.value) : null;
                    
                    let correct = 0;
                    if (ans1 === this.correctAnswers[0]) correct++;
                    if (this.correctAnswers.length === 2 && ans2 === this.correctAnswers[1]) correct++;
                    
                    if (correct === this.correctAnswers.length) {
                        GameEngine.stats.score += 20;
                        Sound.play('success');
                    } else {
                        GameEngine.stats.errors++;
                        GameEngine.stats.score = Math.max(0, GameEngine.stats.score - 10);
                        Sound.play('click', 'C2', 0.5);
                    }
                    
                    overlay.classList.remove('active');
                    
                    // 自由体验模式：记录轮次但不强制完成
                    // if (this.round >= this.maxRounds) {
                    //     GameEngine.complete();
                    // } else {
                    //     setTimeout(() => this.startRound(), 1000);
                    // }
                    
                    // 改为：总是开始下一轮，让用户自由体验
                    setTimeout(() => this.startRound(), 1000);
                });
                optionsDiv.appendChild(submitBtn);
                
                overlay.classList.add('active');
            }
            
            update(stats, deltaTime) {
                if (!this.isActive) return;
                
                const ctx = this.ctx;
                ctx.fillStyle = '#f5f5f0';
                ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                if (this.currentPhase === 'showing') {
                    const elapsed = Date.now() - this.animationStart;
                    const time = elapsed / 1000;
                    
                    let allDone = true;
                    
                    this.schools.forEach(school => {
                        if (elapsed > school.showTime && !school.shown) {
                            school.shown = true;
                        }
                        
                        if (school.shown) {
                            school.fish.forEach(fish => {
                                fish.x += fish.speed;
                                this.drawFish(fish, time);
                            });
                            
                            if (school.fish[school.fish.length - 1].x < this.canvas.width + 100) {
                                allDone = false;
                            }
                        } else {
                            allDone = false;
                        }
                    });
                    
                    if (allDone && elapsed > Math.max(...this.schools.map(s => s.showTime)) + 5000) {
                        this.showAnswerPrompt();
                    }
                }
            }
            
            cleanup() {
                console.log('🧹 Cleaning up Module 1...');
                this.isActive = false;
                if (this.canvas && this.canvas.parentNode) {
                    this.canvas.parentNode.removeChild(this.canvas);
                }
                const overlay = document.getElementById('question-overlay');
                if (overlay) overlay.classList.remove('active');
                console.log('✓ Module 1 cleaned up');
            }
        }

        // ==================== MODULE 2: SIGNAL ====================
        class Module2 {
            init() {
                console.log('📡 Module 2 initializing...');
                this.focusLevel = 0;
                this.focusDuration = 0;
                this.inBreakthrough = false;
                this.timeOffTarget = 0;
                this.lastSoundTime = 0;
                this.breakthroughs = 0;
                this.totalBreakthroughs = 2;

                const difficulty = App.tOC;
                this.signalSpeed = 1.2 + (difficulty / 100) * 1.5;
                this.trackingRadius = 0.20 - (difficulty / 100) * 0.12;
                this.requiredFocusDuration = 5 - (difficulty / 100) * 2;
                this.isActive = true;

                this.pointer = { x: 0, y: 0, isDown: false };
                this.onMove = (e) => {
                    const clientX = e.clientX || (e.touches && e.touches[0].clientX);
                    const clientY = e.clientY || (e.touches && e.touches[0].clientY);
                    this.pointer.x = (clientX / innerWidth) * 2 - 1;
                    this.pointer.y = -(clientY / innerHeight) * 2 + 1;
                };
                this.onDown = () => { 
                    this.pointer.isDown = true; 
                    if(this.isActive) Sound.start('module2', 'C4', 0.4);
                };
                this.onUp = () => { 
                    this.pointer.isDown = false; 
                    if(this.isActive) Sound.release('module2');
                };

                document.addEventListener('mousemove', this.onMove);
                document.addEventListener('touchmove', this.onMove, { passive: false });
                document.addEventListener('mousedown', this.onDown);
                document.addEventListener('touchstart', this.onDown, { passive: false });
                document.addEventListener('mouseup', this.onUp);
                document.addEventListener('touchend', this.onUp);

                this.material = new THREE.ShaderMaterial({
                    uniforms: {
                        u_time: { value: 0 },
                        u_focus_level: { value: 0.0 },
                        u_signal_speed: { value: this.signalSpeed },
                        u_breakthrough: { value: 0.0 },
                        u_focus_progress: { value: 0.0 }
                    },
                    vertexShader: `
                        varying vec2 vUv;
                        void main() {
                            vUv = uv;
                            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                        }
                    `,
                    fragmentShader: `
                        uniform float u_time;
                        uniform float u_focus_level;
                        uniform float u_signal_speed;
                        uniform float u_breakthrough;
                        uniform float u_focus_progress;
                        varying vec2 vUv;

                        float random (vec2 st) { return fract(sin(dot(st.xy, vec2(12.9898,78.233)))*43758.5453123); }
                        float noise (in vec2 st) { vec2 i = floor(st); vec2 f = fract(st); float a = random(i); float b = random(i + vec2(1.0, 0.0)); float c = random(i + vec2(0.0, 1.0)); float d = random(i + vec2(1.0, 1.0)); vec2 u = f*f*(3.0-2.0*f); return mix(a, b, u.x) + (c - a)* u.y * (1.0 - u.x) + (d - b) * u.x * u.y; }
                        float fbm (in vec2 st) { float value = 0.0; float amplitude = .5; for (int i = 0; i < 4; i++) { value += amplitude * noise(st); st *= 2.; amplitude *= .5; } return value; }

                        void main() {
                            vec2 st = vUv * vec2(0.8, 1.5) + vec2(0.0, -u_time * 0.05);
                            float fbm_val = fbm(st);
                            
                            vec3 color1 = vec3(0.5, 0.1, 0.2);
                            vec3 color2 = vec3(0.8, 0.3, 0.1);
                            vec3 color3 = vec3(0.9, 0.7, 0.5);
                            
                            vec3 nebula_color = mix(color1, color2, smoothstep(0.3, 0.6, fbm_val));
                            nebula_color = mix(nebula_color, color3, smoothstep(0.7, 0.9, fbm_val));

                            float signalY = sin(u_time * u_signal_speed) * 0.4 + 0.5;
                            float distToSignal = abs(vUv.y - signalY);
                            float signalClarity = 1.0 - smoothstep(0.0, 0.05, distToSignal);
                            float signal = sin(vUv.x * 80.0 + u_time * 10.0) * 0.5 + 0.5;
                            signal = smoothstep(0.7, 0.71, signal) * signalClarity;

                            float static_noise = random(vUv * 2.0 - u_time * 0.1);
                            vec3 noise_color = vec3(static_noise * 0.5);

                            vec3 final_color = mix(noise_color, nebula_color, smoothstep(0.1, 0.8, u_focus_level));
                            final_color += vec3(signal) * (0.4 + u_focus_level * 0.6);
                            
                            float breakthrough_wave = 1.0 - smoothstep(0.0, 0.8, abs(distance(vUv, vec2(0.5)) - u_breakthrough * 0.7));
                            vec3 breakthrough_color = nebula_color * 1.8 + breakthrough_wave;
                            final_color = mix(final_color, breakthrough_color, u_breakthrough);

                            gl_FragColor = vec4(final_color, 1.0);
                        }
                    `
                });
                this.screenMesh = new THREE.Mesh(new THREE.PlaneGeometry(16, 9), this.material);
                this.screenMesh.position.z = -1;
                Visual.scene.add(this.screenMesh);
            }

            update(stats, deltaTime) {
                this.material.uniforms.u_time.value = stats.time;

                const signalY = Math.sin(stats.time * this.signalSpeed) * 0.4 + 0.5;
                const pointerYNorm = this.pointer.y * 0.5 + 0.5;
                const dist = Math.abs(pointerYNorm - signalY);
                let isOnTarget = this.pointer.isDown && dist < this.trackingRadius;
                
                if (isOnTarget) {
                    this.focusLevel = Math.min(1.0, this.focusLevel + deltaTime * 0.4);
                } else {
                    this.focusLevel = Math.max(0.0, this.focusLevel - deltaTime * 0.7);
                }
                this.material.uniforms.u_focus_level.value = this.focusLevel;

                if (this.focusLevel > 0.95 && !this.inBreakthrough) {
                    this.focusDuration += deltaTime;
                    this.timeOffTarget = 0;
                } else {
                    if (this.focusDuration > 0) {
                        this.timeOffTarget += deltaTime;
                        if (this.timeOffTarget > 0.5) { this.focusDuration = 0; }
                    }
                }
                this.material.uniforms.u_focus_progress.value = this.focusDuration / this.requiredFocusDuration;

                if (this.focusDuration > this.requiredFocusDuration && !this.inBreakthrough) {
                    this.inBreakthrough = true;
                    this.breakthroughs++;
                    Sound.play('breakthrough');
                    setTimeout(() => {
                        this.inBreakthrough = false;
                        this.focusDuration = 0;
                    }, 2000);
                }
                
                if (this.inBreakthrough) {
                    const breakthroughProgress = (this.focusDuration - this.requiredFocusDuration) / 2.0;
                    this.material.uniforms.u_breakthrough.value = Math.sin(Math.min(breakthroughProgress, 1.0) * Math.PI);
                } else {
                    this.material.uniforms.u_breakthrough.value = Math.max(0.0, this.material.uniforms.u_breakthrough.value - deltaTime * 2);
                }

                if (isOnTarget && stats.time > this.lastSoundTime + 0.1) {
                    // Safe audio with existence check
                    if (Sound.synths.module2 && Sound.synths.module2.frequency && Sound.synths.module2.frequency.rampTo) {
                        try {
                            Sound.synths.module2.frequency.rampTo(400 + Math.random() * 200, 0.2);
                        } catch(err) {
                            console.warn('Audio error:', err);
                        }
                    }
                    this.lastSoundTime = stats.time;
                } else if (!isOnTarget && this.pointer.isDown) {
                    if (Sound.synths.module2 && Sound.synths.module2.frequency && Sound.synths.module2.frequency.rampTo) {
                        try {
                            Sound.synths.module2.frequency.rampTo(200 + Math.random() * 100, 0.5);
                        } catch(err) {
                            console.warn('Audio error:', err);
                        }
                    }
                }

                // Free experience mode
                stats.score = this.breakthroughs * 10; // Score based on breakthroughs

                // 移除强制完成 - 用户可随时退出
                // if (this.breakthroughs >= this.totalBreakthroughs) {
                //     GameEngine.complete();
                // }
            }

            cleanup() {
                console.log('🧹 Cleaning up Module 2...');
                this.isActive = false;
                Sound.release('module2');      
                
                document.removeEventListener('mousemove', this.onMove);
                document.removeEventListener('touchmove', this.onMove);
                document.removeEventListener('mousedown', this.onDown);
                document.removeEventListener('touchstart', this.onDown);
                document.removeEventListener('mouseup', this.onUp);
                document.removeEventListener('touchend', this.onUp);      
                
                if (Visual.scene && this.screenMesh) {
                    Visual.scene.remove(this.screenMesh);
                    if (this.screenMesh.geometry) this.screenMesh.geometry.dispose();
                    if (this.screenMesh.material) this.screenMesh.material.dispose();
                }      
                this.screenMesh = null;
                this.material = null;
                console.log('✓ Module 2 cleaned up');
            }
        }

        // ==================== MODULE 3: PATTERN (BASED ON WORKING VERSION) ====================
        // ==================== MODULE 3: AESTHETIC BREATHING REVOLUTION ====================
        class Module3 {
            init() {
                console.log('🌸 Module 3 - Dual Ring System initializing...');
                this.isActive = true;
                this.phase = 'breathing';
                this.score = 0;
                this.questionCount = 0;
                this.maxQuestions = 12 + Math.floor(App.tOC / 20);
                
                // ========== BREATHING & INTERACTION ==========
                this.breathTime = 0; // 连续累加，无痕循环
                this.breathCycleTime = 4.0;
                this.isHolding = false;
                this.holdTime = 0;
                this.playerRingScale = 0;
                
                // ========== VISUAL ELEMENTS ==========
                this.group = new THREE.Group();
                
                // 背景
                const bgGeometry = new THREE.PlaneGeometry(20, 20);
                const bgMaterial = new THREE.MeshBasicMaterial({
                    color: 0xf5f5f0,
                    transparent: true,
                    opacity: 0.3
                });
                this.background = new THREE.Mesh(bgGeometry, bgMaterial);
                this.background.position.z = -5;
                this.group.add(this.background);
                
                // 目标环（持续呼吸）
                this.targetRing = this.createWabiSabiRing(1.0, 0xc02625);
                this.group.add(this.targetRing);
                
                // 玩家追踪环（按住时扩张）
                this.playerRing = this.createSmoothRing(0.5, 0x2a2a2a);
                this.playerRing.scale.set(0, 0, 1);
                this.group.add(this.playerRing);
                
                // 匹配指示器（重叠时发光）
                this.matchRing = this.createSmoothRing(1.0, 0x00cc00);
                this.matchRing.scale.set(0, 0, 1);
                this.matchRing.position.z = 0.02;
                this.group.add(this.matchRing);
                
                // 外圈指示点（随目标环呼吸）
                this.indicatorDots = [];
                for (let i = 0; i < 8; i++) {
                    const angle = (i / 8) * Math.PI * 2;
                    const dot = this.createDot();
                    dot.userData = { angle, baseRadius: 1.5 };
                    this.indicatorDots.push(dot);
                    this.group.add(dot);
                }
                
                // 神经网络装饰
                this.neurons = [];
                this.createNeuralNetwork();
                
                this.particles = [];
                
                Visual.scene.add(this.group);
                
                // 显示提示
                const breathHint = document.getElementById('breath-hint');
                if (breathHint) {
                    breathHint.classList.add('active');
                }
                
                // ========== QUESTION BANK ==========
                this.questionBank = [
                    { cat: 'semantic', q_en: "Which doesn't belong: Rose, Tulip, Oak, Daisy?", q_zh: "哪个不属于同类: 玫瑰、郁金香、橡树、雏菊?", a_en: ["Rose", "Tulip", "Oak", "Daisy"], a_zh: ["玫瑰", "郁金香", "橡树", "雏菊"], correct: 2 },
                    { cat: 'semantic', q_en: "Odd one out: Apple, Orange, Carrot, Banana?", q_zh: "哪个不同: 苹果、橙子、胡萝卜、香蕉?", a_en: ["Apple", "Orange", "Carrot", "Banana"], a_zh: ["苹果", "橙子", "胡萝卜", "香蕉"], correct: 2 },
                    { cat: 'semantic', q_en: "Which is not a mammal: Dolphin, Shark, Whale, Seal?", q_zh: "哪个不是哺乳动物: 海豚、鲨鱼、鲸鱼、海豹?", a_en: ["Dolphin", "Shark", "Whale", "Seal"], a_zh: ["海豚", "鲨鱼", "鲸鱼", "海豹"], correct: 1 },
                    { cat: 'math', q_en: "7 + 5 = ?", q_zh: "7 + 5 = ?", a_en: ["10", "12", "13", "15"], a_zh: ["10", "12", "13", "15"], correct: 1, level: 1 },
                    { cat: 'math', q_en: "15 - 8 = ?", q_zh: "15 - 8 = ?", a_en: ["6", "7", "8", "9"], a_zh: ["6", "7", "8", "9"], correct: 1, level: 1 },
                    { cat: 'math', q_en: "9 × 6 = ?", q_zh: "9 × 6 = ?", a_en: ["48", "52", "54", "56"], a_zh: ["48", "52", "54", "56"], correct: 2, level: 2 }
                ];
                
                // ========== DIFFICULTY SYSTEM ==========
                this.difficultySystem = {
                    currentLevel: 2,
                    consecutiveCorrect: 0,
                    consecutiveWrong: 0,
                    upgradeThreshold: 5,
                    downgradeThreshold: 3,
                    
                    recordAnswer: function(isCorrect) {
                        if (isCorrect) {
                            this.consecutiveCorrect++;
                            this.consecutiveWrong = 0;
                            if (this.consecutiveCorrect >= this.upgradeThreshold && this.currentLevel < 5) {
                                this.currentLevel++;
                                this.consecutiveCorrect = 0;
                                return 'upgrade';
                            }
                        } else {
                            this.consecutiveWrong++;
                            this.consecutiveCorrect = 0;
                            if (this.consecutiveWrong >= this.downgradeThreshold && this.currentLevel > 1) {
                                this.currentLevel--;
                                this.consecutiveWrong = 0;
                                return 'downgrade';
                            }
                        }
                        return 'same';
                    },
                    
                    getLevel: function() { return this.currentLevel; },
                    
                    getProgress: function() {
                        return {
                            level: this.currentLevel,
                            correctStreak: this.consecutiveCorrect,
                            wrongStreak: this.consecutiveWrong
                        };
                    }
                };
                
                // ========== EVENT LISTENERS ==========
                this.onDown = (e) => {
                    if (this.phase !== 'breathing') return;
                    const isTouch = e.type === 'touchstart';
                    if (isTouch && e.touches.length < 2) return;
                    
                    this.isHolding = true;
                    this.holdTime = 0;
                    this.playerRingScale = 0;
                    Sound.play('hover');
                    
                    if (isTouch) e.preventDefault();
                };
                
                this.onUp = (e) => {
                    if (!this.isHolding || this.phase !== 'breathing') return;
                    this.isHolding = false;
                    
                    // 检查匹配度
                    const targetScale = this.getTargetRingScale();
                    const scaleDiff = Math.abs(this.playerRingScale - targetScale);
                    const matchQuality = Math.max(0, 1 - scaleDiff * 2); // 差0.5 = 0%
                    
                    if (matchQuality >= 0.7) { // 70%以上算成功
                        this.triggerPerfectActivation();
                    } else {
                        this.triggerFailedActivation();
                    }
                };
                
                document.addEventListener('mousedown', this.onDown);
                document.addEventListener('mouseup', this.onUp);
                document.addEventListener('touchstart', this.onDown, { passive: false });
                document.addEventListener('touchend', this.onUp);
                document.addEventListener('touchcancel', this.onUp);
                
                console.log('✓ Module 3 initialized');
            }
            
            // ========== VISUAL CREATION ==========
            
            createWabiSabiRing(baseRadius, color) {
                // 侘寂风格的不完美环
                const points = [];
                const segments = 64;
                
                for (let i = 0; i <= segments; i++) {
                    const angle = (i / segments) * Math.PI * 2;
                    const irregularity = Math.sin(angle * 7) * 0.015 + Math.cos(angle * 11) * 0.01;
                    const radius = baseRadius + irregularity;
                    points.push(new THREE.Vector3(
                        Math.cos(angle) * radius,
                        Math.sin(angle) * radius,
                        0
                    ));
                }
                
                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                const material = new THREE.LineBasicMaterial({
                    color: color,
                    transparent: true,
                    opacity: 0.6,
                    linewidth: 2
                });
                
                return new THREE.Line(geometry, material);
            }
            
            createSmoothRing(radius, color) {
                // 平滑的完美圆环
                const points = [];
                const segments = 64;
                
                for (let i = 0; i <= segments; i++) {
                    const angle = (i / segments) * Math.PI * 2;
                    points.push(new THREE.Vector3(
                        Math.cos(angle) * radius,
                        Math.sin(angle) * radius,
                        0
                    ));
                }
                
                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                const material = new THREE.LineBasicMaterial({
                    color: color,
                    transparent: true,
                    opacity: 0.0,
                    linewidth: 3
                });
                
                return new THREE.Line(geometry, material);
            }
            
            createDot() {
                const geometry = new THREE.CircleGeometry(0.04, 16);
                const material = new THREE.MeshBasicMaterial({
                    color: 0xc02625,
                    transparent: true,
                    opacity: 0.8
                });
                return new THREE.Mesh(geometry, material);
            }
            
            createNeuralNetwork() {
                const nodeCount = 12;
                for (let i = 0; i < nodeCount; i++) {
                    const angle = (i / nodeCount) * Math.PI * 2;
                    const radius = 2.5 + Math.random() * 0.5;
                    
                    const geometry = new THREE.SphereGeometry(0.03, 8, 8);
                    const material = new THREE.MeshBasicMaterial({
                        color: 0x2a2a2a,
                        transparent: true,
                        opacity: 0.3
                    });
                    
                    const neuron = new THREE.Mesh(geometry, material);
                    neuron.position.set(
                        Math.cos(angle) * radius,
                        Math.sin(angle) * radius,
                        0
                    );
                    neuron.userData = { 
                        angle, 
                        baseRadius: radius,
                        phase: Math.random() * Math.PI * 2
                    };
                    
                    this.neurons.push(neuron);
                    this.group.add(neuron);
                }
            }
            
            // ========== INTERACTION ==========
            
            getTargetRingScale() {
                // 获取目标环当前的呼吸缩放值
                const phase = (this.breathTime % this.breathCycleTime) / this.breathCycleTime;
                const breathCurve = this.easeInOutSine(phase);
                return 0.8 + breathCurve * 0.4; // 0.8-1.2
            }
            
            triggerPerfectActivation() {
                console.log('✨ Perfect match!');
                
                const breathHint = document.getElementById('breath-hint');
                if (breathHint) breathHint.classList.remove('active');
                
                Sound.play('click');
                this.createParticleBurst();
                
                setTimeout(() => this.showQuestion(), 300);
            }
            
            triggerFailedActivation() {
                console.log('⚠️ Timing off...');
                
                try {
                    if (typeof Tone !== 'undefined') {
                        const synth = new Tone.Synth().toDestination();
                        synth.triggerAttackRelease('C2', '0.1');
                        setTimeout(() => synth.dispose(), 200);
                    }
                } catch(e) {}
                
                this.shakeNetwork();
            }
            
            createParticleBurst() {
                const particleCount = 20;
                for (let i = 0; i < particleCount; i++) {
                    const angle = (i / particleCount) * Math.PI * 2;
                    const speed = 0.02 + Math.random() * 0.03;
                    
                    const geometry = new THREE.CircleGeometry(0.02, 8);
                    const material = new THREE.MeshBasicMaterial({
                        color: 0xc02625,
                        transparent: true,
                        opacity: 1.0
                    });
                    
                    const particle = new THREE.Mesh(geometry, material);
                    particle.position.set(0, 0, 0);
                    particle.userData = {
                        velocity: {
                            x: Math.cos(angle) * speed,
                            y: Math.sin(angle) * speed
                        },
                        life: 1.0,
                        decay: 0.02
                    };
                    
                    this.particles.push(particle);
                    this.group.add(particle);
                }
            }
            
            shakeNetwork() {
                this.neurons.forEach(neuron => {
                    const originalPos = neuron.position.clone();
                    const shakeIntensity = 0.1;
                    
                    const shake = () => {
                        neuron.position.x = originalPos.x + (Math.random() - 0.5) * shakeIntensity;
                        neuron.position.y = originalPos.y + (Math.random() - 0.5) * shakeIntensity;
                    };
                    
                    shake();
                    setTimeout(shake, 50);
                    setTimeout(shake, 100);
                    setTimeout(() => neuron.position.copy(originalPos), 150);
                });
            }
            
            showQuestion() {
                this.phase = 'answer';
                this.questionStartTime = Date.now();
                
                const q = this.questionBank[Math.floor(Math.random() * this.questionBank.length)];
                this.currentQuestion = q;
                
                const overlay = document.getElementById('question-overlay');
                const lang = I18N.lang;
                
                document.getElementById('question-text').textContent = lang === 'zh' ? q.q_zh : q.q_en;
                
                const answersContainer = document.getElementById('answer-options');
                if (answersContainer) {
                    answersContainer.innerHTML = '';
                    const answers = lang === 'zh' ? q.a_zh : q.a_en;
                    answers.forEach((answer, i) => {
                        const btn = document.createElement('button');
                        btn.className = 'answer-option';
                        btn.textContent = answer;
                        btn.onclick = () => this.submitAnswer(i);
                        answersContainer.appendChild(btn);
                    });
                }
                
                overlay.classList.add('active');
            }
            
            submitAnswer(index) {
                if (this.phase !== 'answer') return;
                
                const isCorrect = index === this.currentQuestion.correct;
                const levelChange = this.difficultySystem.recordAnswer(isCorrect);
                
                if (isCorrect) {
                    this.score += 10;
                    Sound.play('click');
                } else {
                    try {
                        if (typeof Tone !== 'undefined') {
                            const synth = new Tone.Synth().toDestination();
                            synth.triggerAttackRelease('C2', '0.15');
                            setTimeout(() => synth.dispose(), 200);
                        }
                    } catch(e) {}
                }
                
                if (levelChange === 'upgrade') {
                    this.showLevelNotification('LEVEL UP', 'upgrade');
                } else if (levelChange === 'downgrade') {
                    this.showLevelNotification('ADJUST', 'downgrade');
                }
                
                this.questionCount++;
                document.getElementById('question-overlay').classList.remove('active');
                
                if (this.questionCount >= this.maxQuestions) {
                    GameEngine.complete();
                } else {
                    this.phase = 'breathing';
                    const breathHint = document.getElementById('breath-hint');
                    if (breathHint) breathHint.classList.add('active');
                }
            }
            
            showLevelNotification(message, type) {
                const notification = document.createElement('div');
                notification.className = `level-notification ${type}`;
                notification.textContent = message;
                document.body.appendChild(notification);
                setTimeout(() => {
                    if (document.body.contains(notification)) {
                        document.body.removeChild(notification);
                    }
                }, 2500);
            }
            
            // ========== UPDATE LOOP ==========
            
            update(stats, deltaTime) {
                if (!this.isActive) return;
                
                // 无痕循环：时间持续累加
                this.breathTime += deltaTime;
                
                // 计算呼吸相位
                const phase = (this.breathTime % this.breathCycleTime) / this.breathCycleTime;
                const breathCurve = this.easeInOutSine(phase);
                
                // === 目标环呼吸（0.8-1.2倍） ===
                const targetScale = 0.8 + breathCurve * 0.4;
                this.targetRing.scale.set(targetScale, targetScale, 1);
                this.targetRing.material.opacity = 0.4 + breathCurve * 0.3;
                
                // === 外圈指示点跟随目标环 ===
                this.indicatorDots.forEach((dot, i) => {
                    const angle = dot.userData.angle + this.breathTime * 0.2;
                    const radius = dot.userData.baseRadius * targetScale;
                    
                    dot.position.set(
                        Math.cos(angle) * radius,
                        Math.sin(angle) * radius,
                        0
                    );
                    
                    dot.material.opacity = 0.6 + breathCurve * 0.3;
                    const dotScale = 0.8 + breathCurve * 0.4;
                    dot.scale.set(dotScale, dotScale, 1);
                });
                
                // === 神经网络节点细微呼吸 ===
                this.neurons.forEach(neuron => {
                    const phase = neuron.userData.phase + this.breathTime * 2;
                    const pulse = Math.sin(phase) * 0.5 + 0.5;
                    const scale = 0.7 + pulse * 0.3 + breathCurve * 0.2;
                    neuron.scale.set(scale, scale, scale);
                    neuron.material.opacity = 0.2 + pulse * 0.2 + breathCurve * 0.1;
                });
                
                // === 按住交互：玩家环扩张 ===
                if (this.isHolding && this.phase === 'breathing') {
                    this.holdTime += deltaTime;
                    
                    // 玩家环从0扩张到1.5（2秒）
                    const expansionSpeed = 0.5; // 每秒扩张0.5
                    this.playerRingScale = Math.min(1.5, this.playerRingScale + deltaTime * expansionSpeed);
                    
                    // 更新玩家环视觉
                    this.playerRing.scale.set(this.playerRingScale, this.playerRingScale, 1);
                    this.playerRing.material.opacity = 0.8;
                    
                    // === 检测匹配度 ===
                    const scaleDiff = Math.abs(this.playerRingScale - targetScale);
                    const isMatched = scaleDiff < 0.15; // 容差范围
                    
                    if (isMatched) {
                        // 重叠时：匹配指示器发光
                        this.matchRing.scale.set(targetScale, targetScale, 1);
                        this.matchRing.material.opacity = 0.8;
                        
                        // 玩家环变绿
                        this.playerRing.material.color.setHex(0x00cc00);
                        
                        // 显示波峰指示
                        const peakIndicator = document.getElementById('peak-indicator');
                        if (peakIndicator) peakIndicator.classList.add('active');
                    } else {
                        // 不匹配：保持原色
                        this.playerRing.material.color.setHex(0x2a2a2a);
                        this.matchRing.material.opacity = 0;
                        
                        const peakIndicator = document.getElementById('peak-indicator');
                        if (peakIndicator) peakIndicator.classList.remove('active');
                    }
                } else {
                    // 没有按住：隐藏玩家环
                    this.playerRing.material.opacity = Math.max(0, this.playerRing.material.opacity - deltaTime * 3);
                    if (this.playerRing.material.opacity <= 0) {
                        this.playerRing.scale.set(0, 0, 1);
                    }
                    
                    this.matchRing.material.opacity = Math.max(0, this.matchRing.material.opacity - deltaTime * 3);
                    if (this.matchRing.material.opacity <= 0) {
                        this.matchRing.scale.set(0, 0, 1);
                    }
                    
                    const peakIndicator = document.getElementById('peak-indicator');
                    if (peakIndicator) peakIndicator.classList.remove('active');
                }
                
                // === 粒子更新 ===
                for (let i = this.particles.length - 1; i >= 0; i--) {
                    const particle = this.particles[i];
                    particle.position.x += particle.userData.velocity.x;
                    particle.position.y += particle.userData.velocity.y;
                    particle.userData.life -= particle.userData.decay;
                    particle.material.opacity = particle.userData.life;
                    
                    if (particle.userData.life <= 0) {
                        this.group.remove(particle);
                        particle.geometry.dispose();
                        particle.material.dispose();
                        this.particles.splice(i, 1);
                    }
                }
                
                // === 整体旋转 ===
                this.group.rotation.z += deltaTime * 0.05;
                
                // === 更新UI ===
                stats.score = this.score;
                stats.progress = (this.questionCount / this.maxQuestions) * 100;
                
                const difficultyDisplay = document.getElementById('difficulty-display');
                if (difficultyDisplay) {
                    difficultyDisplay.style.display = 'block';
                    const progress = this.difficultySystem.getProgress();
                    const levelEl = document.getElementById('current-level');
                    const correctEl = document.getElementById('streak-correct');
                    const wrongEl = document.getElementById('streak-wrong');
                    if (levelEl) levelEl.textContent = progress.level;
                    if (correctEl) correctEl.textContent = `✓ Streak: ${progress.correctStreak}/5`;
                    if (wrongEl) wrongEl.textContent = `✗ Streak: ${progress.wrongStreak}/3`;
                }
            }
            
            // ========== EASING ==========
            
            easeInOutSine(x) {
                return -(Math.cos(Math.PI * x) - 1) / 2;
            }
            
            // ========== CLEANUP ==========
            
            cleanup() {
                console.log('🧹 Cleaning up Module 3...');
                this.isActive = false;
                
                const breathHint = document.getElementById('breath-hint');
                if (breathHint) breathHint.classList.remove('active');
                const peakIndicator = document.getElementById('peak-indicator');
                if (peakIndicator) peakIndicator.classList.remove('active');
                const difficultyDisplay = document.getElementById('difficulty-display');
                if (difficultyDisplay) difficultyDisplay.style.display = 'none';
                
                document.removeEventListener('mousedown', this.onDown);
                document.removeEventListener('mouseup', this.onUp);
                document.removeEventListener('touchstart', this.onDown);
                document.removeEventListener('touchend', this.onUp);
                document.removeEventListener('touchcancel', this.onUp);
                
                if (Visual.scene && this.group) {
                    this.group.traverse(obj => {
                        if (obj.geometry) obj.geometry.dispose();
                        if (obj.material) obj.material.dispose();
                    });
                    Visual.scene.remove(this.group);
                }
                
                console.log('✓ Module 3 cleaned up');
            }
        }

        class Module4 {
            init() {
                console.log('〰️ Module 4 initializing - Vintage Radio Tuner...');
                this.isActive = true;
                this.canvas = document.getElementById('mod4-canvas');
                this.canvas.style.display = 'block';
                
                // Full screen canvas
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
                this.ctx = this.canvas.getContext('2d');
                
                this.resizeHandler = PerformanceUtils.throttle(() => this.resize(), 250);
                window.addEventListener('resize', this.resizeHandler);
                
                const difficulty = App.tOC;
                this.currentStage = 0;
                this.totalStages = 3 + Math.floor(difficulty / 30);
                
                // User controls
                this.userFreq = 0.5; // 0-1 normalized
                this.userAmp = 0.5;  // 0-1 normalized
                
                // Static noise for radio effect
                this.staticNoise = [];
                for (let i = 0; i < 800; i++) {
                    this.staticNoise.push({
                        x: Math.random(),
                        y: Math.random(),
                        alpha: Math.random() * 0.2
                    });
                }
                
                // Generate artistic target waves with various types
                this.targetWaves = [];
                const waveTypes = ['sine', 'complex', 'modulated', 'harmonic'];
                for (let i = 0; i < this.totalStages; i++) {
                    this.targetWaves.push({
                        type: waveTypes[Math.floor(Math.random() * waveTypes.length)],
                        freq: 0.3 + Math.random() * 0.7,  // normalized 0-1
                        amp: 0.3 + Math.random() * 0.6,   // normalized 0-1
                        phase: Math.random() * Math.PI * 2,
                        harmonics: Math.random() > 0.5 ? 2 : 1,
                        modDepth: 0.2 + Math.random() * 0.3
                    });
                }
                
                // Visual effects parameters
                this.particles = [];
                this.gridAlpha = 0.03;
                this.time = 0;
                
                this.createControls();
                console.log('✓ Module 4 initialized - Vintage Radio Style');
            }
            
            resize() {
                if (!this.canvas) return;
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
            }
            
            createControls() {
                const isMobile = window.innerWidth < 768;
                
                const controlDiv = document.createElement('div');
                controlDiv.id = 'wave-controls';
                
                // 艺术化控制面板设计
                if (isMobile) {
                    // 手机：两个旋钮都在底部，横向排列
                    controlDiv.style.cssText = `
                        position: fixed;
                        left: 0;
                        right: 0;
                        bottom: 0;
                        pointer-events: none;
                        z-index: 100;
                        display: flex;
                        justify-content: center;
                        align-items: flex-end;
                        padding-bottom: 1.5rem;
                    `;
                    
                    // 容器：横向布局
                    const knobContainer = document.createElement('div');
                    knobContainer.style.cssText = `
                        display: flex;
                        gap: 2rem;
                        align-items: center;
                        pointer-events: auto;
                        background: rgba(245, 245, 240, 0.95);
                        padding: 1.2rem 1.8rem;
                        border-radius: 20px;
                        border: 2px solid rgba(192, 38, 37, 0.3);
                        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.15);
                        backdrop-filter: blur(10px);
                    `;
                    
                    const tuneKnob = this.createArtisticKnob('TUNE', true);
                    const volumeKnob = this.createArtisticKnob('VOLUME', false);
                    
                    knobContainer.appendChild(tuneKnob);
                    knobContainer.appendChild(volumeKnob);
                    controlDiv.appendChild(knobContainer);
                    
                    // CHECK按钮放在右下角
                    const checkBtn = document.createElement('button');
                    checkBtn.className = 'btn accent';
                    checkBtn.textContent = 'CHECK';
                    checkBtn.style.cssText = `
                        position: fixed;
                        bottom: 1.5rem;
                        right: 1rem;
                        padding: 0.9rem 1.8rem;
                        font-size: 0.7rem;
                        letter-spacing: 0.2em;
                        pointer-events: auto;
                        background: rgba(192, 38, 37, 0.95);
                        border: 2px solid rgba(42, 42, 42, 0.2);
                        color: #f5f5f0;
                        box-shadow: 0 6px 20px rgba(192, 38, 37, 0.35);
                        border-radius: 8px;
                        font-weight: 500;
                    `;
                    checkBtn.addEventListener('click', () => this.checkMatch());
                    controlDiv.appendChild(checkBtn);
                    
                } else {
                    // 桌面：右侧精致面板
                    controlDiv.style.cssText = `
                        position: absolute;
                        right: 2.5rem;
                        top: 50%;
                        transform: translateY(-50%);
                        width: 260px;
                        background: rgba(245, 245, 240, 0.98);
                        padding: 2.5rem 2rem;
                        border: 2px solid rgba(192, 38, 37, 0.4);
                        border-radius: 20px;
                        box-shadow: 
                            0 12px 48px rgba(0, 0, 0, 0.18),
                            inset 0 2px 0 rgba(255, 255, 255, 0.6);
                        backdrop-filter: blur(10px);
                    `;
                    
                    const tuneKnob = this.createArtisticKnob('TUNE', true);
                    tuneKnob.style.marginBottom = '2.5rem';
                    controlDiv.appendChild(tuneKnob);
                    
                    const volumeKnob = this.createArtisticKnob('VOLUME', false);
                    volumeKnob.style.marginBottom = '2rem';
                    controlDiv.appendChild(volumeKnob);
                    
                    const checkBtn = document.createElement('button');
                    checkBtn.className = 'btn accent';
                    checkBtn.textContent = 'CHECK SIGNAL';
                    checkBtn.style.cssText = `
                        width: 100%;
                        font-size: 0.7rem;
                        letter-spacing: 0.15em;
                        padding: 1rem;
                        background: rgba(192, 38, 37, 0.95);
                        border: 2px solid rgba(42, 42, 42, 0.2);
                        color: #f5f5f0;
                        box-shadow: 
                            0 4px 16px rgba(192, 38, 37, 0.3),
                            inset 0 -2px 8px rgba(0, 0, 0, 0.2);
                        border-radius: 8px;
                        font-weight: 500;
                    `;
                    checkBtn.addEventListener('click', () => this.checkMatch());
                    controlDiv.appendChild(checkBtn);
                }
                
                this.controlDiv = controlDiv;
                document.getElementById('game-screen').appendChild(controlDiv);
            }
            
            createArtisticKnob(label, isFrequency) {
                const container = document.createElement('div');
                container.style.cssText = `
                    display: flex;
                    flex-direction: column;
                    align-items: center;
                    position: relative;
                `;
                
                // 标签
                const labelEl = document.createElement('div');
                labelEl.textContent = label;
                labelEl.style.cssText = `
                    font-size: 0.6rem;
                    letter-spacing: 0.25em;
                    color: rgba(42, 42, 42, 0.7);
                    margin-bottom: 1rem;
                    font-weight: 600;
                    text-transform: uppercase;
                `;
                container.appendChild(labelEl);
                
                // 旋钮外圈 - 艺术化设计
                const knobOuter = document.createElement('div');
                knobOuter.style.cssText = `
                    width: 100px;
                    height: 100px;
                    border-radius: 50%;
                    background: radial-gradient(circle at 35% 35%, rgba(255, 255, 255, 0.9), rgba(245, 245, 240, 0.95));
                    box-shadow: 
                        0 8px 24px rgba(0, 0, 0, 0.15),
                        inset 0 -4px 12px rgba(0, 0, 0, 0.1),
                        inset 0 4px 12px rgba(255, 255, 255, 0.8);
                    position: relative;
                    cursor: grab;
                    transition: transform 0.05s ease-out, box-shadow 0.2s ease;
                    border: 3px solid rgba(192, 38, 37, 0.2);
                `;
                
                // 悬停效果
                knobOuter.addEventListener('mouseenter', () => {
                    knobOuter.style.boxShadow = `
                        0 10px 32px rgba(192, 38, 37, 0.25),
                        inset 0 -4px 12px rgba(0, 0, 0, 0.1),
                        inset 0 4px 12px rgba(255, 255, 255, 0.8)
                    `;
                });
                knobOuter.addEventListener('mouseleave', () => {
                    knobOuter.style.boxShadow = `
                        0 8px 24px rgba(0, 0, 0, 0.15),
                        inset 0 -4px 12px rgba(0, 0, 0, 0.1),
                        inset 0 4px 12px rgba(255, 255, 255, 0.8)
                    `;
                });
                
                // 刻度圈 - 艺术化刻度
                const scaleRing = document.createElement('div');
                scaleRing.style.cssText = `
                    position: absolute;
                    top: -8px;
                    left: -8px;
                    right: -8px;
                    bottom: -8px;
                    border-radius: 50%;
                `;
                
                // 绘制刻度线（12个）
                for (let i = 0; i < 12; i++) {
                    const tick = document.createElement('div');
                    const angle = (i * 30) - 90; // -90 to start from top
                    const isMainTick = i % 3 === 0;
                    
                    tick.style.cssText = `
                        position: absolute;
                        width: ${isMainTick ? '3px' : '2px'};
                        height: ${isMainTick ? '12px' : '8px'};
                        background: linear-gradient(to bottom, 
                            ${isMainTick ? 'rgba(192, 38, 37, 0.8)' : 'rgba(42, 42, 42, 0.4)'}, 
                            transparent);
                        top: 0;
                        left: 50%;
                        transform-origin: center ${50 + 8}px;
                        transform: translateX(-50%) rotate(${angle}deg);
                        border-radius: 2px;
                    `;
                    scaleRing.appendChild(tick);
                }
                knobOuter.appendChild(scaleRing);
                
                // 旋钮指示器 - 更艺术化
                const indicator = document.createElement('div');
                indicator.style.cssText = `
                    position: absolute;
                    top: 12px;
                    left: 50%;
                    width: 4px;
                    height: 28px;
                    background: linear-gradient(to bottom, 
                        #c02625, 
                        rgba(192, 38, 37, 0.7));
                    transform: translateX(-50%);
                    border-radius: 2px;
                    box-shadow: 
                        0 0 12px rgba(192, 38, 37, 0.8),
                        0 2px 6px rgba(0, 0, 0, 0.3);
                `;
                knobOuter.appendChild(indicator);
                
                // 中心装饰 - 艺术化圆形
                const centerCircle = document.createElement('div');
                centerCircle.style.cssText = `
                    position: absolute;
                    top: 50%;
                    left: 50%;
                    width: 30px;
                    height: 30px;
                    background: radial-gradient(circle at 35% 35%, 
                        rgba(255, 255, 255, 0.9), 
                        rgba(192, 38, 37, 0.15));
                    border: 2px solid rgba(192, 38, 37, 0.3);
                    border-radius: 50%;
                    transform: translate(-50%, -50%);
                    box-shadow: 
                        0 2px 8px rgba(0, 0, 0, 0.15),
                        inset 0 2px 4px rgba(0, 0, 0, 0.1);
                `;
                knobOuter.appendChild(centerCircle);
                
                // 中心点
                const centerDot = document.createElement('div');
                centerDot.style.cssText = `
                    position: absolute;
                    top: 50%;
                    left: 50%;
                    width: 8px;
                    height: 8px;
                    background: #2a2a2a;
                    border-radius: 50%;
                    transform: translate(-50%, -50%);
                    box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.6);
                `;
                knobOuter.appendChild(centerDot);
                
                container.appendChild(knobOuter);
                
                // 滑块（隐藏）
                const slider = document.createElement('input');
                slider.type = 'range';
                slider.min = '0';
                slider.max = '100';
                slider.value = '50';
                slider.style.cssText = 'opacity: 0; position: absolute; width: 1px; height: 1px;';
                
                let rotation = 0;
                const updateKnob = (value) => {
                    rotation = (value - 50) * 2.7; // -135deg to +135deg
                    knobOuter.style.transform = `rotate(${rotation}deg)`;
                    
                    if (isFrequency) {
                        this.userFreq = value / 100;
                        this.freqSlider = slider;
                    } else {
                        this.userAmp = value / 100;
                        this.ampSlider = slider;
                    }
                };
                
                slider.addEventListener('input', (e) => {
                    updateKnob(parseFloat(e.target.value));
                });
                
                // 鼠标/触摸控制旋钮
                let isDragging = false;
                let startY = 0;
                let startValue = 50;
                
                const onStart = (e) => {
                    isDragging = true;
                    startY = e.clientY || e.touches[0].clientY;
                    startValue = parseFloat(slider.value);
                    knobOuter.style.cursor = 'grabbing';
                    e.preventDefault();
                };
                
                const onMove = (e) => {
                    if (!isDragging) return;
                    const currentY = e.clientY || (e.touches && e.touches[0].clientY);
                    const deltaY = startY - currentY;
                    const newValue = Math.max(0, Math.min(100, startValue + deltaY * 0.4));
                    slider.value = newValue;
                    updateKnob(newValue);
                    e.preventDefault();
                };
                
                const onEnd = () => {
                    isDragging = false;
                    knobOuter.style.cursor = 'grab';
                };
                
                knobOuter.addEventListener('mousedown', onStart);
                knobOuter.addEventListener('touchstart', onStart, { passive: false });
                document.addEventListener('mousemove', onMove);
                document.addEventListener('touchmove', onMove, { passive: false });
                document.addEventListener('mouseup', onEnd);
                document.addEventListener('touchend', onEnd);
                
                container.appendChild(slider);
                
                return container;
            }
            
            checkMatch() {
                const target = this.targetWaves[this.currentStage];
                const freqDiff = Math.abs(this.userFreq - target.freq);
                const ampDiff = Math.abs(this.userAmp - target.amp);
                
                // 更宽容的容错空间
                if (freqDiff < 0.22 && ampDiff < 0.22) {
                    Sound.play('success');
                    GameEngine.stats.score += 20;
                    this.currentStage++;
                    
                    // Cycle back to first stage for continuous play
                    if (this.currentStage >= this.totalStages) {
                        this.currentStage = 0;
                    }
                    
                    // Reset sliders for new wave
                    this.userFreq = 0.5;
                    this.userAmp = 0.5;
                    this.freqSlider.value = '50';
                    this.ampSlider.value = '50';
                    
                    // Visual feedback
                    this.spawnSuccessParticles();
                } else {
                    Sound.play('click', 'C2', 0.5);
                    GameEngine.stats.errors++;
                }
            }
            
            spawnSuccessParticles() {
                // Create particle burst on success
                const centerX = this.canvas.width / 2;
                const centerY = this.canvas.height / 2;
                for (let i = 0; i < 20; i++) {
                    const angle = (Math.PI * 2 * i) / 20;
                    this.particles.push({
                        x: centerX,
                        y: centerY,
                        vx: Math.cos(angle) * 3,
                        vy: Math.sin(angle) * 3,
                        life: 1.0,
                        color: '#00ff00'
                    });
                }
            }
            
            update(stats, deltaTime) {
                if (!this.isActive) return;
                
                this.time += deltaTime;
                
                const ctx = this.ctx;
                const w = this.canvas.width;
                const h = this.canvas.height;
                
                // === 主题浅色背景 ===
                ctx.fillStyle = '#f5f5f0';
                ctx.fillRect(0, 0, w, h);
                
                // === 艺术化网格 ===
                this.drawArtisticGrid(ctx, w, h);
                
                // === Update and draw particles ===
                this.updateParticles(ctx, deltaTime);
                
                const target = this.targetWaves[this.currentStage];
                
                // === Draw Target Wave (top third - 主题红色) ===
                const targetY = h * 0.3;
                this.drawArtisticWave(ctx, w, h, target, targetY, '#c02625', true);
                
                // === Draw User Wave (bottom third - 黑色) ===
                const userY = h * 0.7;
                const userWave = {
                    type: 'sine',
                    freq: this.userFreq,
                    amp: this.userAmp,
                    phase: 0,
                    harmonics: 1,
                    modDepth: 0
                };
                this.drawArtisticWave(ctx, w, h, userWave, userY, '#2a2a2a', false);
                
                // === 艺术化标签 ===
                ctx.shadowBlur = 0;
                ctx.fillStyle = 'rgba(192, 38, 37, 0.9)';
                ctx.font = 'bold 12px Inter';
                ctx.letterSpacing = '0.15em';
                ctx.fillText('◆ TARGET SIGNAL', 20, 30);
                
                ctx.fillStyle = 'rgba(42, 42, 42, 0.9)';
                ctx.fillText('◆ YOUR SIGNAL', 20, h - 20);
                
                // === Stage indicator ===
                ctx.fillStyle = 'rgba(192, 38, 37, 0.6)';
                ctx.font = '11px Inter';
                ctx.textAlign = 'right';
                ctx.fillText(`STAGE ${this.currentStage + 1}/${this.totalStages}`, w - 20, 30);
                ctx.textAlign = 'left';
            }
            
            drawArtisticGrid(ctx, w, h) {
                // 艺术化网格 - 红色和灰色交替
                ctx.lineWidth = 0.5;
                
                const gridSize = 60;
                
                // Vertical lines
                for (let x = 0; x < w; x += gridSize) {
                    const isAccent = Math.floor(x / gridSize) % 3 === 0;
                    ctx.strokeStyle = isAccent 
                        ? 'rgba(192, 38, 37, 0.08)' 
                        : 'rgba(42, 42, 42, 0.05)';
                    ctx.beginPath();
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, h);
                    ctx.stroke();
                }
                
                // Horizontal lines
                for (let y = 0; y < h; y += gridSize) {
                    const isAccent = Math.floor(y / gridSize) % 3 === 0;
                    ctx.strokeStyle = isAccent 
                        ? 'rgba(192, 38, 37, 0.08)' 
                        : 'rgba(42, 42, 42, 0.05)';
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(w, y);
                    ctx.stroke();
                }
                
                // Center reference line
                ctx.strokeStyle = 'rgba(192, 38, 37, 0.12)';
                ctx.lineWidth = 1.5;
                ctx.setLineDash([10, 5]);
                ctx.beginPath();
                ctx.moveTo(0, h * 0.5);
                ctx.lineTo(w, h * 0.5);
                ctx.stroke();
                ctx.setLineDash([]);
            }
            
            drawArtisticWave(ctx, w, h, wave, centerY, color, isTarget) {
                const points = [];
                const resolution = 2;
                
                // Generate wave points
                for (let x = 0; x < w; x += resolution) {
                    const t = (x / w) * Math.PI * 6;
                    let y = 0;
                    
                    switch(wave.type) {
                        case 'sine':
                            y = Math.sin(t * (wave.freq * 4 + 1) + this.time);
                            break;
                            
                        case 'complex':
                            y = Math.sin(t * (wave.freq * 4 + 1) + this.time) * 0.6;
                            y += Math.sin(t * (wave.freq * 8 + 2) + this.time * 1.5) * 0.3;
                            y += Math.sin(t * (wave.freq * 16 + 4) + this.time * 0.5) * 0.1;
                            break;
                            
                        case 'modulated':
                            const carrier = Math.sin(t * (wave.freq * 4 + 1) + this.time);
                            const modulator = Math.sin(t * (wave.freq * 2) + this.time * 0.5) * wave.modDepth;
                            y = carrier * (1 + modulator);
                            break;
                            
                        case 'harmonic':
                            for (let h = 1; h <= wave.harmonics; h++) {
                                y += Math.sin(t * (wave.freq * 4 + 1) * h + this.time) / h;
                            }
                            y /= wave.harmonics;
                            break;
                    }
                    
                    // Apply amplitude
                    y *= wave.amp * h * 0.12;
                    y += centerY;
                    
                    points.push({x, y});
                }
                
                // === 艺术化线条 - 多层效果 ===
                
                // 外层光晕（柔和）
                ctx.shadowBlur = 15;
                ctx.shadowColor = color;
                ctx.strokeStyle = color + '30'; // 半透明
                ctx.lineWidth = isTarget ? 6 : 7;
                ctx.beginPath();
                points.forEach((p, i) => {
                    if (i === 0) ctx.moveTo(p.x, p.y);
                    else ctx.lineTo(p.x, p.y);
                });
                ctx.stroke();
                
                // 中层（主体线条）
                ctx.shadowBlur = 8;
                ctx.strokeStyle = color + 'CC'; // 80%不透明
                ctx.lineWidth = isTarget ? 3.5 : 4;
                ctx.beginPath();
                points.forEach((p, i) => {
                    if (i === 0) ctx.moveTo(p.x, p.y);
                    else ctx.lineTo(p.x, p.y);
                });
                ctx.stroke();
                
                // 核心亮线
                ctx.shadowBlur = 0;
                ctx.strokeStyle = isTarget 
                    ? 'rgba(255, 255, 255, 0.9)' 
                    : 'rgba(255, 255, 255, 0.7)';
                ctx.lineWidth = 1;
                ctx.beginPath();
                points.forEach((p, i) => {
                    if (i === 0) ctx.moveTo(p.x, p.y);
                    else ctx.lineTo(p.x, p.y);
                });
                ctx.stroke();
                
                // Reset shadow
                ctx.shadowBlur = 0;
                
                // === 艺术化填充 ===
                const gradient = ctx.createLinearGradient(0, centerY - h * 0.1, 0, centerY + h * 0.1);
                gradient.addColorStop(0, color + '18');
                gradient.addColorStop(0.5, color + '08');
                gradient.addColorStop(1, color + '00');
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.moveTo(0, centerY);
                points.forEach(p => ctx.lineTo(p.x, p.y));
                ctx.lineTo(w, centerY);
                ctx.closePath();
                ctx.fill();
            }
            
            updateParticles(ctx, deltaTime) {
                // Update particles
                this.particles = this.particles.filter(p => {
                    p.x += p.vx;
                    p.y += p.vy;
                    p.life -= deltaTime * 2;
                    return p.life > 0;
                });
                
                // Draw particles
                this.particles.forEach(p => {
                    ctx.fillStyle = p.color + Math.floor(p.life * 255).toString(16).padStart(2, '0');
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, 3, 0, Math.PI * 2);
                    ctx.fill();
                });
            }
            
            cleanup() {
                console.log('🧹 Cleaning up Module 4 - Artistic Wave System...');
                this.isActive = false;
                if (this.canvas) this.canvas.style.display = 'none';
                if (this.controlDiv && this.controlDiv.parentNode) {
                    this.controlDiv.parentNode.removeChild(this.controlDiv);
                }
                this.particles = [];
                console.log('✓ Module 4 cleaned up');
            }
        }

        // ==================== MODULE 5: REFLEX ====================
        class Module5 {
            init() {
                console.log('🎯 Module 5 initializing...');
                this.canvasEl = document.getElementById('reflex-canvas');
                this.ctx = this.canvasEl.getContext('2d');
                this.canvasEl.style.display = 'block';
                this.isGameActive = true;

                this.setCanvasSize();
                this.resizeHandler = PerformanceUtils.throttle(() => this.setCanvasSize(), 250);
                window.addEventListener('resize', this.resizeHandler);

                this.dots = [];
                this.numDots = 9;
                this.targetDotIndex = -1;
                this.state = 'countdown';
                this.countdownTimer = 3; // 3秒倒计时
                this.trialCount = 0;
                this.maxTrials = 15;
                this.reactionTimes = [];
                
                this.drawInitialDots();
                this.startCountdown();

                this.onClick = this.handleClick.bind(this);
                this.canvasEl.addEventListener('mousedown', this.onClick);
                this.canvasEl.addEventListener('touchstart', this.onClick);
            }

            setCanvasSize() {
                if (!this.canvasEl) return;
                const size = Math.min(window.innerWidth * 0.9, window.innerHeight * 0.9);
                this.canvasEl.width = size;
                this.canvasEl.height = size;
                this.drawInitialDots();
                this.drawBackground();
            }

            drawInitialDots() {
                this.dots = [];
                const w = this.canvasEl.width;
                const h = this.canvasEl.height;
                const padding = w * 0.15;
                const gridW = (w - padding * 2) / 2;
                const gridH = (h - padding * 2) / 2;
                
                for (let i = 0; i < 3; i++) {
                    for (let j = 0; j < 3; j++) {
                        this.dots.push({ 
                            x: padding + j * gridW, 
                            y: padding + i * gridH, 
                            r: w * 0.06, 
                            state: 'hidden',
                            index: i * 3 + j 
                        });
                    }
                }
            }

            startCountdown() {
                this.state = 'countdown';
                this.dots.forEach(d => d.state = 'hidden');
                Sound.play('reflex_start');
                
                this.countdownInterval = setInterval(() => { 
                    if (!this.isGameActive) {
                        clearInterval(this.countdownInterval);
                        return;
                    }
                    this.countdownTimer--;
                    if (this.countdownTimer <= 0) {
                        clearInterval(this.countdownInterval);
                        this.countdownInterval = null;
                        this.startTrial();
                    } else {
                        Sound.play('reflex_cue', 'C2');
                    }
                }, 1000); // 1秒间隔
            }

            startTrial() {
                if (!this.isGameActive) return;

                this.trialCount++;
                // 自由体验模式：记录试验次数但不强制完成
                if (this.trialCount > this.maxTrials) {
                    this.calculateResults();
                    // GameEngine.complete();
                    // 改为：重置试验，让用户继续体验
                    this.trialCount = 1;
                    this.reactionTimes = [];
                    // return;
                }
                
                this.state = 'wait';
                const delay = Math.random() * 2000 + 1000;
                this.cueTimeout = setTimeout(() => this.cueTarget(), delay); 
            }

            cueTarget() {
                if (!this.isGameActive) return;

                this.state = 'cue';
                this.cueTime = performance.now();
                
                const isTarget = Math.random() > 0.3;
                this.targetDotIndex = Math.floor(Math.random() * this.numDots);
                this.dots[this.targetDotIndex].state = isTarget ? 'black' : 'red';
                this.isCurrentTarget = isTarget;
                
                Sound.play('reflex_cue', 'A5');

                this.missTimeout = setTimeout(() => { 
                    if (this.isGameActive && this.state === 'cue') {
                        if (this.isCurrentTarget) {
                            this.handleMiss();
                        } else {
                            this.handleCorrectAvoid();
                        }
                    }
                }, 1000); 
            }

            handleClick(e) {
                if (this.state !== 'cue') return;

                clearTimeout(this.missTimeout);
                this.missTimeout = null;

                const rect = this.canvasEl.getBoundingClientRect();
                const clickX = (e.clientX || e.touches[0].clientX) - rect.left;
                const clickY = (e.clientY || e.touches[0].clientY) - rect.top;

                let clickedDot = null;
                this.dots.forEach(dot => {
                    const dist = Math.sqrt((clickX - dot.x)**2 + (clickY - dot.y)**2);
                    if (dist < dot.r * 1.5) clickedDot = dot;
                });
                
                if (clickedDot && clickedDot.index === this.targetDotIndex) {
                    if (this.isCurrentTarget) {
                        const reactionTime = performance.now() - this.cueTime;
                        this.reactionTimes.push(reactionTime);
                        this.handleHit(reactionTime);
                    } else {
                        this.handleWrongClick();
                    }
                } else {
                    this.handleWrongClick();
                }
            }

            handleHit(reactionTime) {
                this.state = 'click';
                this.dots[this.targetDotIndex].state = 'green';
                Sound.play('reflex_hit', 'G6');
                GameEngine.stats.score += 10;
                
                setTimeout(() => {
                    this.dots[this.targetDotIndex].state = 'hidden';
                    this.startTrial();
                }, 300);
            }

            handleMiss() {
                this.state = 'click';
                GameEngine.stats.errors++;
                GameEngine.stats.score = Math.max(0, GameEngine.stats.score - 5);
                Sound.play('reflex_miss', 'C2', 0.8);
                this.dots[this.targetDotIndex].state = 'gray'; 
                
                setTimeout(() => {
                    this.dots[this.targetDotIndex].state = 'hidden';
                    this.startTrial();
                }, 300);
            }
            
            handleCorrectAvoid() {
                this.state = 'click';
                this.dots[this.targetDotIndex].state = 'hidden';
                GameEngine.stats.score += 5;
                setTimeout(() => this.startTrial(), 300);
            }
            
            handleWrongClick() {
                GameEngine.stats.errors++;
                GameEngine.stats.score = Math.max(0, GameEngine.stats.score - 10);
                Sound.play('reflex_miss', 'C1', 0.5);
                
                this.state = 'click';
                setTimeout(() => {
                    this.dots[this.targetDotIndex].state = 'hidden';
                    this.startTrial();
                }, 300);
            }

            calculateResults() {
                const totalTime = this.reactionTimes.reduce((sum, rt) => sum + rt, 0);
                const avgTime = this.reactionTimes.length > 0 ? totalTime / this.reactionTimes.length : 500;
                GameEngine.stats.score = Math.round(avgTime);
            }

            drawBackground() {
                const ctx = this.ctx;
                const w = this.canvasEl.width;
                const h = this.canvasEl.height;

                ctx.fillStyle = '#f5f5f0'; // Match main background color
                ctx.fillRect(0, 0, w, h);
                
                this.dots.forEach(dot => {
                    if (dot.state === 'hidden') {
                        ctx.strokeStyle = 'rgba(42, 42, 42, 0.15)';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.arc(dot.x, dot.y, dot.r, 0, Math.PI * 2);
                        ctx.stroke();
                    } else {
                        let color = '#2a2a2a';
                        if (dot.state === 'black') color = '#2a2a2a';
                        if (dot.state === 'red') color = '#dd0000'; 
                        if (dot.state === 'green') color = '#00cc00'; 
                        if (dot.state === 'gray') color = '#888888';

                        ctx.fillStyle = color;
                        ctx.beginPath();
                        ctx.arc(dot.x, dot.y, dot.r, 0, Math.PI * 2);
                        ctx.fill();
                    }
                });
                
                if (this.state === 'countdown') {
                    const countEl = document.getElementById('game-countdown');
                    countEl.textContent = this.countdownTimer;
                    countEl.style.opacity = 1;
                } else {
                    document.getElementById('game-countdown').style.opacity = 0;
                }
            }

            update(stats, deltaTime) {
                this.drawBackground();
            }

            cleanup() { 
                console.log('🧹 Cleaning up Module 5...');
                this.isGameActive = false;      
                
                if (this.countdownInterval) {
                    clearInterval(this.countdownInterval);
                    this.countdownInterval = null;
                }
                if (this.cueTimeout) {
                    clearTimeout(this.cueTimeout);
                    this.cueTimeout = null;
                }
                if (this.missTimeout) {
                    clearTimeout(this.missTimeout);
                    this.missTimeout = null;
                }

                if (this.resizeHandler) {
                    window.removeEventListener('resize', this.resizeHandler);
                }
                if (this.canvasEl && this.onClick) {
                    this.canvasEl.removeEventListener('mousedown', this.onClick);
                    this.canvasEl.removeEventListener('touchstart', this.onClick);
                }      
                if (this.canvasEl) {
                    this.canvasEl.style.display = 'none';
                }      
                const countdownEl = document.getElementById('game-countdown');
                if (countdownEl) countdownEl.style.opacity = 0;
                
                console.log('✓ Module 5 cleaned up');
            }
        }
        
        // ==================== MODULE 6: FLOW ====================
        class Module6 {
            init() {
                console.log('🌊 Module 6 initializing...');
                this.group = new THREE.Group();
                
                this.inhaleDuration = 4;
                this.holdDuration = 7;
                this.exhaleDuration = 8;
                this.cycleDuration = this.inhaleDuration + this.holdDuration + this.exhaleDuration;
                
                this.totalPresenceTime = 0;
                this.requiredTime = 60;
                this.isHolding = false;
                this.isActive = true;
                
                this.particles = [];
                // Adaptive particle count based on device performance
                const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
                const pixelRatio = window.devicePixelRatio || 1;
                this.numParticles = isMobile ? 1500 : (pixelRatio > 2 ? 2000 : 3000);
                
                console.log(`🎨 Using ${this.numParticles} particles for Module 6`);
                
                const geom = new THREE.BufferGeometry();
                const positions = new Float32Array(this.numParticles * 3);
                const colors = new Float32Array(this.numParticles * 3);
                const velocities = new Float32Array(this.numParticles * 3);
                const phases = new Float32Array(this.numParticles);
                
                const palette = [
                    { r: 232/255, g: 74/255, b: 95/255 },
                    { r: 255/255, g: 122/255, b: 92/255 },
                    { r: 255/255, g: 193/255, b: 182/255 }
                ];
                
                for (let i = 0; i < this.numParticles; i++) {
                    positions[i*3] = (Math.random() - 0.5) * 15;
                    positions[i*3+1] = (Math.random() - 0.5) * 15;
                    positions[i*3+2] = (Math.random() - 0.5) * 8;
                    
                    velocities[i*3] = 0;
                    velocities[i*3+1] = 0;
                    velocities[i*3+2] = 0;
                    
                    phases[i] = Math.random() * Math.PI * 2;
                    
                    const colorChoice = palette[Math.floor(Math.random() * palette.length)];
                    colors[i*3] = colorChoice.r;
                    colors[i*3+1] = colorChoice.g;
                    colors[i*3+2] = colorChoice.b;
                }
                
                geom.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                geom.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                geom.setAttribute('velocity', new THREE.BufferAttribute(velocities, 3));
                geom.setAttribute('phase', new THREE.BufferAttribute(phases, 1));
                
                this.mat = new THREE.PointsMaterial({
                    size: 0.15,
                    vertexColors: true,
                    transparent: true,
                    opacity: 0.8,
                    blending: THREE.AdditiveBlending
                });
                
                this.vortexParticles = new THREE.Points(geom, this.mat);
                this.group.add(this.vortexParticles);
                
                this.group.add(new THREE.AmbientLight(0xffffff, 0.5));
                const pointLight = new THREE.PointLight(0xff7a5c, 1.5, 100);
                pointLight.position.set(5, 5, 5);
                this.group.add(pointLight);
                
                Visual.scene.add(this.group);
                
                this.quoteEl = document.getElementById('game-intro-text');
                this.quoteEl.style.top = '75%';
                this.quoteEl.style.color = '#E84A5F';
                this.quoteEl.style.textShadow = '0 0 20px rgba(232, 74, 95, 0.5)';

                this.onDown = () => { this.isHolding = true; };
                this.onUp = () => { this.isHolding = false; };
                
                document.addEventListener('mousedown', this.onDown);
                document.addEventListener('mouseup', this.onUp);
                document.addEventListener('touchstart', this.onDown);
                document.addEventListener('touchend', this.onUp);
            }
            
            update(stats, deltaTime) {
                if (!this.isActive) return;

                const elapsedInCycle = stats.time % this.cycleDuration;
                
                let breathPhase, targetScale;
                
                if (elapsedInCycle < this.inhaleDuration) {
                    breathPhase = 'inhale';
                    targetScale = 1.0 - (elapsedInCycle / this.inhaleDuration) * 0.5;
                    this.quoteEl.textContent = I18N.lang === 'en' ? 'INHALE (4s)' : '吸气 (4秒)';
                } else if (elapsedInCycle < this.inhaleDuration + this.holdDuration) {
                    breathPhase = 'hold';
                    targetScale = 0.5; 
                    this.quoteEl.textContent = I18N.lang === 'en' ? 'HOLD (7s)' : '屏息 (7秒)';
                } else {
                    breathPhase = 'exhale';
                    const exhaleTime = elapsedInCycle - (this.inhaleDuration + this.holdDuration); 
                    targetScale = 0.5 + (exhaleTime / this.exhaleDuration) * 0.5;
                    this.quoteEl.textContent = I18N.lang === 'en' ? 'EXHALE (8s)' : '呼气 (8秒)';
                }
                
                const positions = this.vortexParticles.geometry.attributes.position.array;
                const velocities = this.vortexParticles.geometry.attributes.velocity.array;
                const phases = this.vortexParticles.geometry.attributes.phase.array;
                
                const breathForce = breathPhase === 'inhale' ? -0.003 : (breathPhase === 'exhale' ? 0.003 : 0);
                
                for (let i = 0; i < this.numParticles; i++) {
                    const i3 = i * 3;
                    
                    const x = positions[i3];
                    const y = positions[i3+1];
                    const z = positions[i3+2];
                    
                    const dist = Math.sqrt(x*x + y*y);
                    
                    const angle = Math.atan2(y, x);
                    const vortexStrength = 0.015 * Math.sin(stats.time * 1.5 + phases[i]);
                    const tangentialForce = vortexStrength / (dist + 0.1);
                    
                    velocities[i3] += (-Math.sin(angle) * tangentialForce + breathForce * x * 0.15);
                    velocities[i3+1] += (Math.cos(angle) * tangentialForce + breathForce * y * 0.15);
                    velocities[i3+2] += Math.sin(stats.time * 0.8 + phases[i]) * 0.002;
                    
                    velocities[i3] *= 0.97;
                    velocities[i3+1] *= 0.97;
                    velocities[i3+2] *= 0.97;
                    
                    positions[i3] += velocities[i3];
                    positions[i3+1] += velocities[i3+1];
                    positions[i3+2] += velocities[i3+2];
                    
                    if (Math.abs(positions[i3]) > 12) positions[i3] = -Math.sign(positions[i3]) * 12;
                    if (Math.abs(positions[i3+1]) > 12) positions[i3+1] = -Math.sign(positions[i3+1]) * 12;
                    if (Math.abs(positions[i3+2]) > 6) positions[i3+2] = -Math.sign(positions[i3+2]) * 6;
                }
                
                this.vortexParticles.geometry.attributes.position.needsUpdate = true;
                
                const isTargetInhale = breathPhase === 'inhale';
                const inSync = (this.isHolding && isTargetInhale) || (!this.isHolding && !isTargetInhale);
                
                if (inSync) {
                    this.totalPresenceTime += deltaTime;
                }
                
                // Score based on presence time
                stats.score = Math.round(this.totalPresenceTime * 10);
                
                this.group.rotation.y += 0.002;
                
                // 自由体验模式：记录时间但不强制完成
                // if (this.totalPresenceTime >= this.requiredTime) {
                //     GameEngine.complete();
                // }
            }
            
            cleanup() { 
                console.log('🧹 Cleaning up Module 6...');
                this.isActive = false;
                Sound.release('flow_pacer');
                
                const quoteEl = document.getElementById('game-intro-text');
                if (quoteEl) {
                    quoteEl.textContent = ''; 
                    quoteEl.style.top = '50%';
                    quoteEl.style.color = '';
                    quoteEl.style.textShadow = '';
                }

                document.removeEventListener('mousedown', this.onDown);
                document.removeEventListener('mouseup', this.onUp);
                document.removeEventListener('touchstart', this.onDown);
                document.removeEventListener('touchend', this.onUp);
                
                if (Visual.scene && this.group) {
                    Visual.scene.remove(this.group);
                }      
                
                const disposeMesh = (mesh) => {
                    if (mesh) {
                        if (mesh.geometry) mesh.geometry.dispose();
                        if (mesh.material) mesh.material.dispose();
                    }
                };
                disposeMesh(this.vortexParticles);
                
                console.log('✓ Module 6 cleaned up');
            }
        }
        
        // ==================== UI INITIALIZATION ====================
        function initUI() {
            const cursor = document.getElementById('cursor');
            
            document.addEventListener('mousemove', e => {
                cursor.style.transform = `translate(${e.clientX - 3}px, ${e.clientY - 3}px)`;
            });
            document.addEventListener('mousedown', () => cursor.classList.add('active'));
            document.addEventListener('mouseup', () => cursor.classList.remove('active'));
            
            document.querySelectorAll('.lang-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('.lang-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    Sound.play('click');
                    I18N.set(btn.dataset.lang);
                });
            });
            
            const welcomeScreen = document.getElementById('welcome-screen');
            const startApp = async (e) => {
                if (e.target.closest('#lang-switch')) return;
                if (!welcomeScreen.classList.contains('active')) return;

                try {
                    await Tone.start();
                    Sound.init();
                    Sound.play('click');
                } catch(err) {
                    console.warn('Audio start error:', err);
                }
                
                welcomeScreen.removeEventListener('click', startApp);
                welcomeScreen.removeEventListener('touchstart', startApp);
                
                App.setState('INFO');
            };
            
            welcomeScreen.addEventListener('click', startApp);
            welcomeScreen.addEventListener('touchstart', startApp, { passive: true });
            
            document.getElementById('info-submit').addEventListener('click', () => {
                const name = document.getElementById('user-name').value.trim();
                const age = document.getElementById('user-age').value;
                const gender = document.getElementById('user-gender').value;
                const status = document.getElementById('user-status').value;
                
                App.patient = { name, age: parseInt(age) || null, gender: gender || 'unknown', status: status || 'unknown' };
                Sound.play('click');
                App.setState('SCENT');
            });
            
            document.getElementById('scent-submit').addEventListener('click', () => {
                App.scents = { ...LumenScent.values };
                Sound.play('click');
                App.setState('MODULES');
            });
            
            document.getElementById('scent-prev').addEventListener('click', (e) => {
                e.stopPropagation();
                LumenScent.prevPage();
            });
            
            document.getElementById('scent-next').addEventListener('click', (e) => {
                e.stopPropagation();
                LumenScent.nextPage();
            });
            
            document.querySelectorAll('.page-dot').forEach(dot => {
                dot.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const page = parseInt(dot.dataset.page);
                    LumenScent.goToPage(page);
                    Sound.play('click');
                });
            });
            
            const tocSlider = document.getElementById('toc-slider');
            tocSlider.addEventListener('input', (e) => {
                App.tOC = parseInt(e.target.value);
                document.getElementById('toc-value').textContent = App.tOC;
                const pitch = `C${Math.floor(App.tOC / 20) + 3}`;
                Sound.play('slider', pitch, App.tOC / 120);
            });
            
            document.getElementById('back-btn').addEventListener('click', () => {
                // 自由体验模式：保存当前进度并退出
                if (GameEngine.module && App.current) {
                    const data = {
                        time: GameEngine.stats.time || 0,
                        score: GameEngine.stats.score || 0,
                        errors: GameEngine.stats.errors || 0,
                        progress: GameEngine.stats.progress || 0
                    };
                    
                    // 保存进度
                    App.completed.add(App.current);
                    App.modules[App.current] = data;
                    
                    console.log(`✓ Module ${App.current} progress saved:`, data);
                }
                
                // 清理界面和资源
                document.getElementById('tutorial-overlay').classList.remove('active');
                
                const introTextEl = document.getElementById('game-intro-text');
                introTextEl.classList.remove('active-intro'); 
                
                ResourceManager.unregister('gamemodule');
                GameEngine.currentModuleId = null;
                GameEngine.isLoading = false;
                
                Sound.play('click');
                App.setState('MODULES');
            });
            
            document.getElementById('finish-btn').addEventListener('click', () => App.finish());
            document.getElementById('restart-btn').addEventListener('click', () => {
                App.resetAllResources();
                location.reload();
            });
            
            document.querySelectorAll('.btn, .module-cell').forEach(el => {
                el.addEventListener('mouseenter', () => Sound.play('hover'));
            });

            I18N.set(I18N.lang);
        }
        
        // ==================== MAIN INITIALIZATION ====================
        
        // White screen detection and recovery
        let lastRenderTime = performance.now();
        let renderHealthCheckInterval = null;
        
        function checkRenderHealth() {
            const now = performance.now();
            const timeSinceLastRender = now - lastRenderTime;
            
            // If no render for 3 seconds during GAME state, something is wrong
            if (App.state === 'GAME' && timeSinceLastRender > 3000) {
                console.error('⚠️ Render freeze detected! Attempting recovery...');
                try {
                    // 只清理资源，不自动退出
                    ResourceManager.unregister('gamemodule');
                    GameEngine.module = null;
                    GameEngine.isLoading = false;
                    
                    // Try to restore Visual system
                    if (Visual.scene && Visual.camera && Visual.renderer) {
                        Visual.setScene('GAME');  // 保持在GAME状态
                    }
                    
                    // 不自动跳转 - 让用户决定
                    alert('Render freeze detected. Please use "SAVE & EXIT" button if needed.');
                    // App.setState('MODULES');  // 移除自动跳转
                } catch(recoveryErr) {
                    console.error('Recovery failed:', recoveryErr);
                    alert('Critical error. Please use "SAVE & EXIT" button or refresh the page.');
                }
            }
            
            lastRenderTime = now;
        }
        
        // Start health monitoring
        function startHealthMonitoring() {
            if (renderHealthCheckInterval) {
                clearInterval(renderHealthCheckInterval);
            }
            renderHealthCheckInterval = setInterval(checkRenderHealth, 2000);
        }
        
        window.addEventListener('load', () => { 
            try {
                // Global error handlers
                window.addEventListener('error', (e) => {
                    console.error('❌ Global error:', e.error);
                    try {
                        // 只记录错误，不自动退出
                        if (App.state === 'GAME') {
                            console.warn('Error in GAME state. User can manually exit if needed.');
                            // 不自动跳转，让用户决定
                            // ResourceManager.unregister('gamemodule');
                            // setTimeout(() => {
                            //     try {
                            //         App.setState('MODULES');
                            //     } catch(err) {
                            //         console.error('State recovery failed:', err);
                            //     }
                            // }, 100);
                        }
                    } catch(recoveryErr) {
                        console.error('Error recovery failed:', recoveryErr);
                    }
                    e.preventDefault();
                });
                
                window.addEventListener('unhandledrejection', (e) => {
                    console.error('❌ Unhandled promise rejection:', e.reason);
                    try {
                        // 只记录错误，不自动退出
                        if (App.state === 'GAME' && e.reason && e.reason.message) {
                            console.warn('Promise rejection in GAME state. User can manually exit if needed.');
                            // 不自动跳转
                            // ResourceManager.unregister('gamemodule');
                            // setTimeout(() => App.setState('MODULES'), 100);
                        }
                    } catch(recoveryErr) {
                        console.error('Promise error recovery failed:', recoveryErr);
                    }
                    e.preventDefault();
                });
                
                // Initialize Visual system
                const visualInit = Visual.init();
                if (!visualInit) {
                    throw new Error('Visual system failed to initialize');
                }
                
                // Initialize UI
                initUI();
                
                // Start health monitoring
                startHealthMonitoring();
                
                console.log('🌸 NeuroScent Core Fixed Edition loaded');
                console.log('✅ ResourceManager active');
                console.log('✅ Enhanced error recovery system');
                console.log('✅ White screen detection enabled');
                console.log('✅ Render health monitoring active');
            } catch(e) {
                console.error('❌ Critical initialization error:', e);
                alert('Application failed to initialize. Please refresh the page.');
            }
        });
        
        window.addEventListener('beforeunload', (e) => {
            // Cleanup health monitoring
            if (renderHealthCheckInterval) {
                clearInterval(renderHealthCheckInterval);
            }
            
            // Warn if user has unsaved progress
            if (App.completed.size > 0 && App.state !== 'RESULTS') {
                e.preventDefault();
                e.returnValue = '';
            }
        });
    });
    </script>
</body>
</html>