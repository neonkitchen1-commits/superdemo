<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
    <title>NeuroScent - Bright Edition</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=EB+Garamond:wght@400;500&family=Inter:wght@300;400;500;600&family=Noto+Sans+SC:wght@300;400;500&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        :root {
            --bg: #f5f5f0;
            --fg: #2a2a2a;
            --gray: #e0e0e0;
            --accent: #c02625;
            --green-hit: #00cc00;
            --red-miss: #dd0000;
        }
        
        body { 
            font-family: 'Inter', -apple-system, sans-serif;
            background: var(--bg);
            color: var(--fg);
            overflow: hidden;
            cursor: none;
            -webkit-font-smoothing: antialiased;
        }
        
        @media (pointer: coarse) {
            body { cursor: auto; }
            #cursor { display: none; }
        }
        
        .serif { font-family: 'EB Garamond', serif; }
        .zh { font-family: 'Noto Sans SC', sans-serif; font-weight: 300; }
        
        #cursor {
            width: 6px;
            height: 6px;
            background: var(--accent);
            border-radius: 50%;
            position: fixed;
            pointer-events: none;
            z-index: 10000;
            transition: transform 0.12s ease;
            box-shadow: 0 0 10px var(--accent);
        }
        #cursor.active { transform: scale(2.5); }
        
        #canvas3d {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }
        
        #ui-layer {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
        }
        #ui-layer > * { 
            pointer-events: auto; 
        }
        
        .screen {
            position: absolute;
            width: 100%;
            height: 100%;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.6s ease, visibility 0.6s;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
            pointer-events: none;
        }
        .screen.active { 
            opacity: 1; 
            visibility: visible;
            pointer-events: auto;
            z-index: 10;
        }
        
        #lang-switch {
            position: fixed;
            top: 1rem;
            right: 1rem;
            z-index: 100;
            display: flex;
            gap: 1px;
            background: var(--gray);
        }
        
        @media (max-width: 768px) {
            #lang-switch {
                top: 0.75rem;
                right: 0.75rem;
            }
        }
        
        .lang-btn {
            background: transparent;
            border: none;
            color: var(--fg);
            padding: 0.4rem 0.8rem;
            cursor: pointer;
            font-size: 0.65rem;
            letter-spacing: 0.1em;
            transition: all 0.3s;
            font-weight: 500;
        }
        .lang-btn.active {
            background: var(--accent);
            color: var(--bg);
        }
        
        #welcome-screen {
            flex-direction: column;
            padding: 2rem 1rem;
            pointer-events: auto;
        }
        
        .welcome-logo {
            font-size: clamp(2.5rem, 12vw, 8rem);
            font-weight: 400;
            letter-spacing: 0.02em;
            color: var(--fg);
            margin-bottom: 0.5rem;
            line-height: 0.95;
            text-shadow: 0 0 30px rgba(192, 38, 37, 0.3);
        }
        
        .welcome-subtitle {
            font-size: clamp(0.7rem, 1.8vw, 0.95rem);
            color: rgba(42, 42, 42, 0.6);
            letter-spacing: 0.08em;
            margin-bottom: 3rem;
            text-transform: uppercase;
            font-weight: 300;
            text-align: center;
        }
        
        .btn {
            background: transparent;
            border: 1px solid var(--fg);
            color: var(--fg);
            padding: 0.9rem 2rem;
            font-size: 0.7rem;
            letter-spacing: 0.2em;
            cursor: pointer;
            transition: all 0.4s;
            text-transform: uppercase;
            font-weight: 400;
            pointer-events: auto;
        }
        .btn:hover, .btn:active {
            background: var(--fg);
            color: var(--bg);
            box-shadow: 0 0 20px rgba(42, 42, 42, 0.2);
        }
        .btn.accent {
            border-color: var(--accent);
            color: var(--accent);
        }
        .btn.accent:hover, .btn.accent:active {
            background: var(--accent);
            color: var(--bg);
            box-shadow: 0 0 20px rgba(192, 38, 37, 0.3);
        }
        
        @media (max-width: 768px) {
            .btn {
                padding: 1rem 2rem;
                font-size: 0.75rem;
            }
        }
        
        .info-container {
            max-width: 520px;
            width: 90%;
            padding: 3rem 2rem;
            position: relative;
            background: rgba(255, 255, 255, 0.15);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            box-shadow: 0 0 50px rgba(192, 38, 37, 0.15);
            border: 1px solid rgba(192, 38, 37, 0.2);
            pointer-events: auto;
        }
        
        .info-container::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 2px;
            background: linear-gradient(90deg, transparent, var(--accent), transparent);
            pointer-events: none;
        }
        
        .info-container::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 2px;
            background: linear-gradient(90deg, transparent, var(--accent), transparent);
            pointer-events: none;
        }
        
        @media (max-width: 768px) {
            .info-container {
                width: 95%;
                padding: 2rem 1.5rem;
            }
        }
        
        .form-title {
            font-size: clamp(1.8rem, 6vw, 2.8rem);
            margin-bottom: 3rem;
            letter-spacing: 0.02em;
            font-weight: 400;
            text-align: center;
            position: relative;
            color: var(--fg);
            pointer-events: none;
        }
        
        .form-title::after {
            content: '';
            position: absolute;
            bottom: -1rem;
            left: 50%;
            transform: translateX(-50%);
            width: 60px;
            height: 1px;
            background: var(--accent);
            box-shadow: 0 0 10px var(--accent);
            pointer-events: none;
        }
        
        .form-field {
            margin-bottom: 2.5rem;
            position: relative;
            pointer-events: auto;
        }
        
        .form-field label {
            display: block;
            font-size: 0.65rem;
            color: rgba(42, 42, 42, 0.7);
            margin-bottom: 0.8rem;
            letter-spacing: 0.15em;
            text-transform: uppercase;
            font-weight: 500;
            pointer-events: none;
        }
        
        .form-field input,
        .form-field select {
            width: 100%;
            background: rgba(255, 255, 255, 0.9);
            border: none;
            border-bottom: 1px solid rgba(192, 38, 37, 0.3);
            color: var(--fg);
            padding: 1rem 0;
            font-size: 1.1rem;
            font-family: 'Inter', sans-serif;
            font-weight: 300;
            transition: border-color 0.3s, box-shadow 0.3s;
            -webkit-appearance: none;
            appearance: none;
            border-radius: 0;
            pointer-events: auto;
        }
        
        .form-field input {
            cursor: text;
        }
        
        .form-field select {
            cursor: pointer;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath fill='%232a2a2a' d='M6 9L1 4h10z'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right center;
            padding-right: 2rem;
        }
        
        .form-field input:focus,
        .form-field select:focus {
            outline: none;
            border-bottom-color: var(--accent);
            box-shadow: 0 2px 10px rgba(192, 38, 37, 0.2);
        }
        
        .form-field input::placeholder {
            color: rgba(42, 42, 42, 0.4);
            font-weight: 300;
        }

        #scent-screen {
            flex-direction: column;
            padding: 1.5rem 1rem;
            overflow: hidden;
            align-items: stretch;
        }
        
        @media (max-width: 768px) {
            #scent-screen {
                padding: 1rem 0.5rem;
            }
            .lumen-name { font-size: 0.9rem; letter-spacing: 0.05em; }
            .lumen-value { font-size: 1.5rem; }
        }
        
        .scent-header {
            text-align: center;
            margin-bottom: 1rem;
            flex-shrink: 0;
        }
        
        @media (max-width: 768px) {
            .scent-header {
                margin-bottom: 0.75rem;
            }
        }
        
        .scent-header h2 {
            font-size: clamp(1.5rem, 6vw, 2.5rem);
            font-weight: 400;
            margin-bottom: 0.5rem;
            letter-spacing: 0.02em;
            text-shadow: 0 0 20px rgba(192, 38, 37, 0.2);
        }

        .scent-intro-box {
            font-size: clamp(0.7rem, 2vw, 0.85rem);
            line-height: 1.6;
            color: rgba(42, 42, 42, 0.75);
            width: 100%;
            margin: 1.5rem auto 0;
            padding: 1.2rem 1.5rem;
            border-left: 2px solid var(--accent);
            text-align: left;
            white-space: pre-wrap;
            background: rgba(192, 38, 37, 0.08);
            flex-shrink: 0;
        }
        
        @media (max-width: 768px) {
            .scent-intro-box {
                font-size: 0.7rem;
                padding: 1rem 1.2rem;
                margin: 1rem auto 0;
            }
        }
        
        .scent-header p {
            font-size: clamp(0.7rem, 2vw, 0.85rem);
            color: rgba(42, 42, 42, 0.6);
            letter-spacing: 0.05em;
        }
        
        #scent-pages {
            position: relative;
            width: 100%;
            max-width: 600px;
            flex: 1;
            margin: 0 auto 1rem;
            overflow: hidden;
            min-height: 500px;
        }
        
        @media (max-width: 768px) {
            #scent-pages {
                min-height: 550px;
            }
        }
        
        .scent-page {
            position: absolute;
            width: 100%;
            height: 100%;
            opacity: 0;
            visibility: hidden;
            transform: translateX(100%);
            transition: all 0.6s cubic-bezier(0.4, 0, 0.2, 1);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            padding: 2rem 1rem 1rem;
            overflow-y: auto;
        }
        
        @media (max-width: 768px) {
            .scent-page {
                padding: 1.5rem 0.75rem 0.75rem;
            }
        }
        
        .scent-page.active {
            opacity: 1;
            visibility: visible;
            transform: translateX(0);
        }
        
        .scent-page.prev {
            transform: translateX(-100%);
        }
        
        .lumen-canvas {
        }
        
        .lumen-label {
            text-align: center;
            pointer-events: none;
            margin-top: 1rem;
            padding: 0 1rem;
            flex-shrink: 0;
        }
        
        .lumen-instruction {
            font-size: 0.7rem;
            color: rgba(42, 42, 42, 0.6);
            margin-top: 0.8rem;
            text-align: center;
            line-height: 1.4;
        }
        
        .lumen-name {
            font-size: clamp(0.9rem, 3vw, 1.1rem);
            font-weight: 400;
            margin-bottom: 0.5rem;
            letter-spacing: 0.08em;
            text-transform: uppercase;
        }
        
        .lumen-value {
            font-size: clamp(1.8rem, 7vw, 2.5rem);
            color: var(--accent);
            font-weight: 500;
            opacity: 0.9;
            text-shadow: 0 0 10px rgba(192, 38, 37, 0.3);
            margin-bottom: 0.3rem;
        }
        
        .scent-pagination {
            display: flex;
            justify-content: center;
            gap: 0.8rem;
            margin: 0.75rem 0;
            flex-shrink: 0;
        }
        
        .page-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: rgba(42, 42, 42, 0.3);
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .page-dot.active {
            background: var(--accent);
            transform: scale(1.3);
            box-shadow: 0 0 10px var(--accent);
        }
        
        .scent-controls {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 1rem;
            flex-wrap: wrap;
            padding: 1rem 1rem 1.5rem;
            flex-shrink: 0;
        }
        
        @media (max-width: 768px) {
            .scent-controls {
                gap: 0.5rem;
                padding: 0.75rem 0.5rem 1rem;
            }
            .scent-controls .btn {
                padding: 0.8rem 1.5rem;
                font-size: 0.65rem;
            }
        }
        
        #module-selection-screen {
            padding: 2rem 1rem;
            align-items: flex-start;
        }
        
        @media (max-width: 768px) {
            #module-selection-screen {
                padding: 1.5rem 0.5rem;
            }
        }
        
        .module-wrapper {
            width: 100%;
            max-width: 1100px;
            margin: 0 auto;
        }
        
        .module-header {
            text-align: center;
            margin-bottom: 2rem;
        }
        
        .module-header h2 {
            font-size: clamp(1.5rem, 6vw, 2.5rem);
            font-weight: 400;
            margin-bottom: 1.5rem;
            letter-spacing: 0.02em;
            text-shadow: 0 0 20px rgba(192, 38, 37, 0.2);
        }
        
        .difficulty-control {
            max-width: 450px;
            margin: 0 auto 2.5rem;
            padding: 1.5rem 1.5rem;
            background: rgba(192, 38, 37, 0.08);
            border-radius: 2px;
            border: 1px solid rgba(192, 38, 37, 0.2);
        }
        
        @media (max-width: 768px) {
            .difficulty-control {
                padding: 1.2rem 1rem;
                margin-bottom: 2rem;
            }
        }
        
        .difficulty-control label {
            display: block;
            font-size: 0.65rem;
            color: rgba(42, 42, 42, 0.7);
            letter-spacing: 0.1em;
            text-transform: uppercase;
            font-weight: 500;
            margin-bottom: 0.3rem;
        }
        
        .difficulty-desc {
            font-size: 0.6rem;
            color: rgba(42, 42, 42, 0.6);
            margin-bottom: 1rem;
            line-height: 1.4;
        }
        
        .slider-container {
            display: flex;
            align-items: center;
            gap: 1rem;
        }
        
        .difficulty-slider {
            flex: 1;
            height: 2px;
            background: var(--gray);
            -webkit-appearance: none;
            appearance: none;
            outline: none;
            cursor: pointer;
        }
        
        .difficulty-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            background: var(--accent);
            cursor: pointer;
            border-radius: 50%;
            box-shadow: 0 0 10px var(--accent);
        }
        
        .difficulty-slider::-moz-range-thumb {
            width: 18px;
            height: 18px;
            background: var(--accent);
            cursor: pointer;
            border: none;
            border-radius: 50%;
            box-shadow: 0 0 10px var(--accent);
        }
        
        .difficulty-value {
            font-size: 1.2rem;
            color: var(--accent);
            font-weight: 500;
            min-width: 3rem;
            text-align: right;
            text-shadow: 0 0 10px rgba(192, 38, 37, 0.3);
        }
        
        .module-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(min(260px, 100%), 1fr));
            gap: 0;
            border: 1px solid rgba(192, 38, 37, 0.2);
            background: var(--bg);
            margin-bottom: 2rem;
        }
        
        @media (max-width: 580px) {
            .module-grid {
                grid-template-columns: 1fr;
            }
        }
        
        .module-cell {
            background: rgba(255, 255, 255, 0.9);
            padding: 2rem 1.5rem;
            cursor: pointer;
            transition: all 0.3s;
            position: relative;
            min-height: 160px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            border-right: 1px solid rgba(192, 38, 37, 0.2);
            border-bottom: 1px solid rgba(192, 38, 37, 0.2);
        }
        
        @media (min-width: 1100px) {
             .module-grid { grid-template-columns: repeat(3, 1fr); }
             .module-cell:nth-child(3n) { border-right: none; }
        }
        @media (min-width: 581px) and (max-width: 1099px) {
             .module-grid { grid-template-columns: repeat(2, 1fr); }
             .module-cell:nth-child(2n) { border-right: none; }
        }
        
        @media (max-width: 580px) {
            .module-cell {
                border-right: none;
                padding: 1.8rem 1.2rem;
            }
        }
        
        .module-cell:hover, .module-cell:active {
            background: rgba(192, 38, 37, 0.15);
            box-shadow: inset 0 0 30px rgba(192, 38, 37, 0.2);
        }
        
        .module-cell.completed::after {
            content: '✓';
            position: absolute;
            top: 1rem;
            right: 1rem;
            color: var(--accent);
            font-size: 1.2rem;
        }
        
        .module-cell h3 {
            font-size: clamp(1.3rem, 4vw, 1.8rem);
            font-weight: 400;
            margin-bottom: 0.4rem;
            letter-spacing: 0.02em;
        }
        
        .module-cell .subtitle {
            font-size: 0.65rem;
            color: rgba(42, 42, 42, 0.6);
            margin-bottom: 0.8rem;
            letter-spacing: 0.15em;
            text-transform: uppercase;
        }
        
        .module-cell .description {
            font-size: 0.8rem;
            line-height: 1.5;
            color: rgba(42, 42, 42, 0.75);
        }
        
        #game-ui {
            position: absolute;
            top: 2rem;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            opacity: 0;
            transition: opacity 0.5s;
            max-width: 85%;
            pointer-events: none;
        }
        
        @media (max-width: 768px) {
            #game-ui {
                top: 6rem;
                max-width: 90%;
            }
        }
        
        #game-ui.active { opacity: 1; }
        
        #game-ui h3 {
            font-size: clamp(1.3rem, 5vw, 2rem);
            font-weight: 400;
            margin-bottom: 0.5rem;
            letter-spacing: 0.05em;
            text-shadow: 0 0 20px rgba(192, 38, 37, 0.2);
        }
        
        #game-ui p {
            font-size: clamp(0.7rem, 2vw, 0.9rem);
            color: rgba(42, 42, 42, 0.7);
        }
        
        #game-stats {
            position: absolute;
            top: 2rem;
            right: 1rem;
            text-align: right;
            opacity: 0;
            transition: opacity 0.5s;
            pointer-events: none;
        }
        
        @media (max-width: 768px) {
            #game-stats {
                top: 1.5rem;
                right: 0.75rem;
            }
        }
        
        #game-stats.active { opacity: 1; }
        
        .stat-row {
            font-size: 0.65rem;
            color: rgba(42, 42, 42, 0.7);
            margin-bottom: 0.4rem;
            letter-spacing: 0.1em;
            font-weight: 400;
        }
        
        .stat-value {
            color: var(--accent);
            font-weight: 500;
            margin-left: 0.5rem;
            text-shadow: 0 0 10px rgba(192, 38, 37, 0.3);
        }
        
        #back-btn {
            position: absolute;
            top: 2rem;
            left: 1rem;
            opacity: 0;
            transition: opacity 0.5s;
            padding: 0.7rem 1.5rem;
            font-size: 0.65rem;
            pointer-events: auto;
        }
        
        @media (max-width: 768px) {
            #back-btn {
                top: 1.5rem;
                left: 0.75rem;
                padding: 0.65rem 1.2rem;
            }
        }
        
        #back-btn.active { opacity: 1; }
        
        #tutorial-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(245, 245, 240, 0.96);
            z-index: 99;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.5s ease, visibility 0.5s;
            pointer-events: none;
            backdrop-filter: blur(8px);
        }
        #tutorial-overlay.active {
            opacity: 1;
            visibility: visible;
            pointer-events: auto;
        }
        .tutorial-card {
            max-width: 500px;
            width: 90%;
            padding: 2.5rem 1.5rem;
            border: 2px solid var(--accent);
            text-align: center;
            background: rgba(255, 255, 255, 0.98);
            box-shadow: 0 0 50px rgba(192, 38, 37, 0.3);
        }
        .tutorial-card h3 {
            font-size: clamp(1.5rem, 5vw, 2rem);
            margin-bottom: 1rem;
            text-shadow: 0 0 20px rgba(192, 38, 37, 0.2);
        }
        .tutorial-card p {
            font-size: clamp(0.85rem, 3vw, 1.1rem);
            line-height: 1.5;
            margin-bottom: 1.5rem;
            color: var(--fg);
        }
        .tutorial-card button {
            margin-top: 1rem;
        }

        .game-intro-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            max-width: 80%;
            font-size: clamp(0.85rem, 2.5vw, 1.1rem);
            color: var(--fg);
            text-align: center;
            z-index: 50;
            pointer-events: none;
            opacity: 0;
            transition: opacity 1.0s;
            line-height: 1.5;
            letter-spacing: 0.05em;
        }
        
        #question-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 255, 255, 0.98);
            border: 2px solid var(--accent);
            padding: 2rem;
            max-width: 500px;
            width: 90%;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s, visibility 0.3s;
            z-index: 100;
            pointer-events: auto;
            box-shadow: 0 0 50px rgba(192, 38, 37, 0.3);
        }
        
        @media (max-width: 768px) {
            #question-overlay {
                padding: 1.5rem;
                width: 95%;
            }
        }
        
        #question-overlay.active {
            opacity: 1;
            visibility: visible;
        }
        
        #question-text {
            font-size: clamp(1rem, 3vw, 1.2rem);
            margin-bottom: 1.5rem;
            font-weight: 400;
            text-align: center;
            line-height: 1.4;
        }
        
        .answer-option {
            background: transparent;
            border: 1px solid rgba(192, 38, 37, 0.3);
            padding: 1rem;
            margin-bottom: 0.8rem;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 0.9rem;
            width: 100%;
            text-align: left;
            color: var(--fg);
        }
        
        .answer-option:hover, .answer-option:active {
            background: rgba(192, 38, 37, 0.2);
            border-color: var(--accent);
            box-shadow: 0 0 20px rgba(192, 38, 37, 0.2);
        }
        
        .results-wrapper {
            max-width: 800px;
            width: 95%;
            padding: 2rem 1rem;
            align-self: flex-start;
            margin-top: 2rem;
        }
        
        @media (max-width: 768px) {
            .results-wrapper {
                width: 98%;
                padding: 1rem 0.5rem;
            }
        }
        
        .results-header {
            font-size: clamp(1.8rem, 7vw, 3rem);
            font-weight: 400;
            text-align: center;
            margin-bottom: 2rem;
            letter-spacing: 0.02em;
            text-shadow: 0 0 30px rgba(192, 38, 37, 0.3);
        }
        
        .results-summary {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
            gap: 1px;
            background: rgba(192, 38, 37, 0.2);
            border: 1px solid rgba(192, 38, 37, 0.2);
            margin-bottom: 2rem;
        }
        
        .summary-item {
            background: rgba(255, 255, 255, 0.9);
            padding: 1rem;
            text-align: center;
        }
        
        @media (max-width: 768px) {
            .summary-item {
                padding: 0.8rem 0.5rem;
            }
            .summary-item h4 {
                 font-size: 0.55rem;
            }
             .summary-item .value {
                font-size: clamp(1.2rem, 4vw, 2rem);
            }
        }
        
        .summary-item h4 {
            font-size: 0.65rem;
            color: rgba(42, 42, 42, 0.7);
            margin-bottom: 0.6rem;
            letter-spacing: 0.15em;
            text-transform: uppercase;
            font-weight: 500;
        }
        
        .summary-item .value {
            font-size: clamp(1.5rem, 5vw, 2.6rem);
            font-weight: 400;
            color: var(--accent);
            text-shadow: 0 0 10px rgba(192, 38, 37, 0.3);
        }
        
        .results-details {
            margin-bottom: 2rem;
        }
        
        .detail-row {
            display: flex;
            justify-content: space-between;
            padding: 0.8rem 0.2rem;
            border-bottom: 1px solid rgba(192, 38, 37, 0.2);
            gap: 1rem;
            flex-wrap: wrap;
        }
        
        .detail-row:last-child {
            border-bottom: none;
        }
        
        .detail-label {
            font-size: 0.8rem;
            font-weight: 400;
        }
        
        .detail-value {
            font-size: 0.8rem;
            color: var(--accent);
            font-weight: 500;
            text-align: right;
            text-shadow: 0 0 10px rgba(192, 38, 37, 0.3);
        }
        
        #scent-wheel-container {
            text-align: center;
            margin-bottom: 2rem;
        }
        
        #scent-wheel {
            width: 100%;
            max-width: 400px;
            height: 400px;
            margin: 0 auto;
        }
        
        @media (max-width: 768px) {
            #scent-wheel {
                max-width: 320px;
                height: 320px;
            }
        }
        
        #report-visualization {
            width: 100%;
            height: 300px;
            margin-bottom: 2rem;
        }

        .recommendation-box {
            background: rgba(192, 38, 37, 0.08);
            padding: 2rem 1.5rem;
            text-align: center;
            margin-bottom: 2rem;
            border: 1px solid rgba(192, 38, 37, 0.2);
        }
        
        @media (max-width: 768px) {
            .recommendation-box {
                padding: 1.5rem 1rem;
            }
        }
        
        .recommendation-box h3 {
            font-size: clamp(0.95rem, 3vw, 1.2rem);
            font-weight: 400;
            margin-bottom: 1rem;
            letter-spacing: 0.05em;
        }
        
        .recommendation-box p {
            font-size: clamp(0.95rem, 3vw, 1.3rem);
            line-height: 1.6;
        }
        
        .dot-pattern {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 25%;
            background-image: radial-gradient(circle, rgba(42, 42, 42, 0.1) 1px, transparent 1px);
            background-size: 18px 18px;
            opacity: 0.3;
            pointer-events: none;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .fade-in {
            animation: fadeIn 0.8s ease forwards;
        }
        
        ::-webkit-scrollbar { width: 6px; }
        ::-webkit-scrollbar-track { background: var(--gray); }
        ::-webkit-scrollbar-thumb { background: var(--accent); }

        #pattern-countdown {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: clamp(3rem, 10vw, 6rem);
            color: var(--accent);
            font-weight: 500;
            opacity: 0;
            transition: opacity 0.3s;
            z-index: 50;
            pointer-events: none;
            text-shadow: 0 0 30px rgba(192, 38, 37, 0.5);
        }
        
        #pattern-countdown.active {
            opacity: 1;
        }
        
        #crystal-container {
            width: 100%;
            height: 100%;
            max-width: 800px;
            max-height: 600px;
            display: flex;
            align-items: center;
            justify-content: center;
            pointer-events: auto;
            position: relative;
        }
        
        #crystal-canvas {
            width: 100%;
            height: 100%;
        }
        
        #crystal-indicator {
            position: absolute;
            bottom: 2rem;
            left: 50%;
            transform: translateX(-50%);
            font-size: 0.9rem;
            color: var(--accent);
            text-shadow: 0 0 10px rgba(192, 38, 37, 0.3);
            pointer-events: none;
        }

        #reflex-canvas {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            max-width: 90vmin;
            max-height: 90vmin;
            aspect-ratio: 1 / 1;
            z-index: 5;
            border: 2px solid rgba(192, 38, 37, 0.3);
            background: transparent;
        }

        #game-countdown {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: clamp(4rem, 15vw, 8rem);
            color: var(--accent);
            font-weight: 700;
            opacity: 0;
            z-index: 200;
            pointer-events: none;
            transition: opacity 0.2s;
            text-shadow: 0 0 50px rgba(192, 38, 37, 0.5);
        }
        
        .game-intro-text.active-intro {
            opacity: 1;
        }

        #report-visualization .bar {
            transition: fill 0.3s, opacity 0.3s;
        }
        #report-visualization .tick line, #report-visualization .domain {
            stroke: rgba(192, 38, 37, 0.3);
        }
        #report-visualization text {
            fill: #2a2a2a; 
        }
        
        #mod4-canvas {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            max-width: 90vw;
            max-height: 80vh;
            border: 2px solid rgba(192, 38, 37, 0.3);
            background: #1a1a1a;
        }

    </style>
</head>
<body>
    <div id="cursor"></div>
    <canvas id="canvas3d"></canvas>
    
    <div id="lang-switch">
        <button class="lang-btn active" data-lang="en">EN</button>
        <button class="lang-btn" data-lang="zh">中</button>
    </div>
    
    <div id="ui-layer">
        <div id="welcome-screen" class="screen active">
            <h1 class="welcome-logo serif">NeuroScent</h1>
            <p class="welcome-subtitle" data-i18n="welcome_sub">Personalized Olfactory-Cognitive Training</p>
            <p style="font-size: 0.65rem; color: rgba(42, 42, 42, 0.5); letter-spacing: 0.1em; margin-top: 2rem;">
                TAP ANYWHERE TO BEGIN
            </p>
            <div class="dot-pattern"></div>
        </div>
        
        <div id="info-screen" class="screen" style="pointer-events: none;">
            <div class="info-container fade-in" style="pointer-events: auto;">
                <h2 class="form-title serif" data-i18n="info_title">Profile</h2>
                <div class="form-field">
                    <label data-i18n="info_name">Name</label>
                    <input type="text" id="user-name" placeholder="Enter your name" autocomplete="name">
                </div>
                <div class="form-field">
                    <label data-i18n="info_age">Age</label>
                    <input type="number" id="user-age" placeholder="Enter your age" min="1" max="120" autocomplete="age">
                </div>
                <div class="form-field">
                    <label data-i18n="info_gender">Gender</label>
                    <select id="user-gender">
                        <option value="">Select gender</option>
                        <option value="male" data-i18n="info_male">Male / 男</option>
                        <option value="female" data-i18n="info_female">Female / 女</option>
                        <option value="nonbinary" data-i18n="info_nonbinary">Nonbinary / 非二元</option>
                        <option value="prefer-not" data-i18n="info_prefer_not">Prefer not to say / 不愿透露</option>
                    </select>
                </div>
                <div class="form-field">
                    <label data-i18n="info_status">Status</label>
                    <select id="user-status">
                        <option value="">Select status</option>
                        <option value="early-stage" data-i18n="info_early">Early Stage / 早期</option>
                        <option value="moderate" data-i18n="info_moderate">Moderate / 中度</option>
                        <option value="control" data-i18n="info_control">Control / 对照</option>
                    </select>
                </div>
                <button class="btn accent" id="info-submit" style="display: block; width: 100%; margin-top: 2rem;">
                    <span data-i18n="btn_continue">CONTINUE</span>
                </button>
            </div>
        </div>
        
        <div id="scent-screen" class="screen">
            <div class="scent-header fade-in">
                <h2 class="serif" data-i18n="scent_title">Olfactory Profile</h2>
                <p data-i18n="scent_desc">Drag outward from center to set preference</p>
            </div>

            <div id="scent-pages">
                <div class="scent-page active" data-page="0"></div>
                <div class="scent-page" data-page="1"></div>
                <div class="scent-page" data-page="2"></div>
                <div class="scent-page" data-page="3"></div>
                <div class="scent-page" data-page="4"></div>
                <div class="scent-page" data-page="5"></div>
            </div>
            <div class="scent-pagination">
                <div class="page-dot active" data-page="0"></div>
                <div class="page-dot" data-page="1"></div>
                <div class="page-dot" data-page="2"></div>
                <div class="page-dot" data-page="3"></div>
                <div class="page-dot" data-page="4"></div>
                <div class="page-dot" data-page="5"></div>
            </div>
            <div class="scent-controls">
                <button class="btn" id="scent-prev" style="opacity: 0.3;">
                    <span>← PREV</span>
                </button>
                <button class="btn accent" id="scent-submit">
                    <span data-i18n="btn_continue">CONTINUE</span>
                </button>
                <button class="btn" id="scent-next">
                    <span>NEXT →</span>
                </button>
            </div>
        </div>
        
        <div id="module-selection-screen" class="screen">
            <div class="module-wrapper">
                <div class="module-header">
                    <h2 class="serif" data-i18n="modules_title">Training Modules</h2>
                    <div class="difficulty-control">
                        <label data-i18n="difficulty_label">Simulate Patient tOC (Total Outlier Count)</label>
                        <p class="difficulty-desc" data-i18n="difficulty_desc">Higher tOC increases module difficulty.</p>
                        <div class="slider-container">
                            <input type="range" class="difficulty-slider" id="toc-slider" min="0" max="100" value="20">
                            <div class="difficulty-value" id="toc-value">20</div>
                        </div>
                    </div>
                </div>
                <div class="module-grid" id="module-gallery"></div>
                <button class="btn accent" id="finish-btn" style="display: block; margin: 0 auto;">
                    <span data-i18n="btn_finish">COMPLETE SESSION</span>
                </button>
            </div>
        </div>
        
        <div id="game-screen" class="screen">
            <button class="btn" id="back-btn">
                <span data-i18n="btn_back">← BACK</span>
            </button>
            <div id="game-ui">
                <h3 class="serif" id="game-title"></h3>
                <p id="game-instruction"></p>
            </div>
            <div id="game-stats">
                <div class="stat-row"><span data-i18n="stat_time">Time</span><span class="stat-value" id="stat-time">0s</span></div>
                <div class="stat-row"><span data-i18n="stat_score">Score</span><span class="stat-value" id="stat-score">0</span></div>
                <div class="stat-row"><span data-i18n="stat_progress">Progress</span><span class="stat-value" id="stat-progress">0%</span></div>
            </div>
            <div id="game-intro-text" class="game-intro-text zh"></div>
            <div id="game-countdown"></div>
            
            <div id="question-overlay">
                <h3 id="question-text"></h3>
                <div id="answer-options"></div>
            </div>
            
            <div id="pattern-countdown"></div>
            
            <div id="crystal-container" style="display: none;">
                <canvas id="crystal-canvas"></canvas>
                <div id="crystal-indicator"></div>
            </div>

            <canvas id="reflex-canvas" style="display: none;"></canvas>
            <canvas id="mod4-canvas" style="display: none;"></canvas>
            
            <div id="tutorial-overlay">
                <div class="tutorial-card">
                    <h3 class="serif" id="tutorial-title"></h3>
                    <p id="tutorial-text"></p>
                    <button class="btn accent" id="tutorial-start-btn">
                        <span data-i18n="btn_start_game">START TRAINING</span>
                    </button>
                </div>
            </div>

            <div class="dot-pattern"></div>
        </div>
        
        <div id="results-screen" class="screen">
            <div class="results-wrapper fade-in">
                <h2 class="results-header serif" data-i18n="results_title">Session Report</h2>
                <div class="results-summary" id="results-summary"></div>
                <div class="results-details" id="results-details"></div>
                <div id="scent-wheel-container">
                    <div id="scent-wheel"></div>
                </div>
                <div id="report-visualization"></div>

                <div class="recommendation-box">
                    <h3 class="serif" data-i18n="results_scent">Recommended Scent Profile</h3>
                    <p id="scent-result"></p>
                </div>
                <button class="btn accent" id="restart-btn" style="display: block; margin: 0 auto;">
                    <span data-i18n="btn_restart">NEW SESSION</span>
                </button>
            </div>
        </div>
    </div>
    
    <script>
    document.addEventListener('DOMContentLoaded', () => {
        
        const PerformanceUtils = {
            throttle(func, limit) {
                let inThrottle;
                return function(...args) {
                    if (!inThrottle) {
                        func.apply(this, args);
                        inThrottle = true;
                        setTimeout(() => inThrottle = false, limit);
                    }
                };
            },
            
            debounce(func, delay) {
                let timeoutId;
                return function(...args) {
                    clearTimeout(timeoutId);
                    timeoutId = setTimeout(() => func.apply(this, args), delay);
                };
            }
        };
        
        // Haptic Feedback Utility
        const Haptic = {
            isSupported: 'vibrate' in navigator,
            
            light() {
                if (this.isSupported) {
                    navigator.vibrate(10);
                }
            },
            
            medium() {
                if (this.isSupported) {
                    navigator.vibrate(20);
                }
            },
            
            heavy() {
                if (this.isSupported) {
                    navigator.vibrate(50);
                }
            },
            
            success() {
                if (this.isSupported) {
                    navigator.vibrate([30, 50, 30]);
                }
            },
            
            error() {
                if (this.isSupported) {
                    navigator.vibrate([50, 100, 50, 100, 50]);
                }
            },
            
            selection() {
                if (this.isSupported) {
                    navigator.vibrate(5);
                }
            }
        };
        
        const Sound = {
            synths: {},
            ambient: null,
            noiseFilter: null,
            ambientLoop: null,
            initialized: false,
            ambientPianoLoop: null,
            
            init() {
                if (this.initialized) return;
                try {
                    const reverb = new Tone.Reverb({ decay: 10, wet: 0.6, preDelay: 0.05 }).toDestination();
                    const filter = new Tone.Filter({ type: 'lowpass', frequency: 1200, rolloff: -24 }).connect(reverb);
                    const chorus = new Tone.Chorus({ frequency: 0.5, delayTime: 3.5, depth: 0.7, wet: 0.5 }).connect(filter);
                    const delay = new Tone.FeedbackDelay({ delayTime: '4n', feedback: 0.5, wet: 0.25 }).connect(chorus);
                    
                    this.noiseFilter = new Tone.Filter({ frequency: 800, type: 'bandpass', Q: 0.5 }).connect(reverb);
                    this.vinylNoise = new Tone.Noise({ type: 'pink', volume: -100 }).connect(this.noiseFilter);
                    this.vinylNoise.start();
                    
                    setTimeout(() => {
                        if (this.vinylNoise) {
                            this.vinylNoise.volume.rampTo(-34, 15);
                        }
                    }, 3000);
                    
                    this.ambient = new Tone.PolySynth(Tone.DuoSynth, {
                        volume: -26,
                        voice0: {
                            oscillator: { type: 'sine' },
                            envelope: { attack: 5, decay: 7, sustain: 0.25, release: 9 },
                            filter: { type: 'lowpass', frequency: 550 }
                        },
                        voice1: {
                            oscillator: { type: 'triangle' },
                            envelope: { attack: 9, decay: 5, sustain: 0.15, release: 11 },
                            filter: { type: 'lowpass', frequency: 350 }
                        }
                    }).connect(reverb);
                    
                    this.ambientPiano = new Tone.Sampler({
                        urls: { C4: "data:audio/wav;base64,UklGRiQAAABXQVZFZm10IBAAAAABAAEAQB8AAAB9AAACABAAZGF0YQAAAAA=" },
                        volume: -30,
                        release: 6
                    }).connect(reverb);
                    
                    this.scentPanner = new Tone.Panner3D({ 
                        positionX: 0, 
                        positionY: 0, 
                        positionZ: 0 
                    }).connect(reverb);
                    
                    this.synths = {
                        click: new Tone.MembraneSynth({ volume: -28, pitchDecay: 0.02, octaves: 1, envelope: { attack: 0.005, decay: 0.15, sustain: 0, release: 0.1 } }).connect(delay),
                        hover: new Tone.Synth({ volume: -36, oscillator: { type: 'triangle' }, envelope: { attack: 0.01, decay: 0.05, sustain: 0, release: 0.04 } }).connect(filter),
                        success: new Tone.PolySynth(Tone.FMSynth, { 
                            volume: -22, 
                            harmonicity: 3.5, 
                            modulationIndex: 12,
                            envelope: { attack: 0.06, decay: 1.8, sustain: 0.12, release: 2.5 } 
                        }).connect(reverb),
                        slider: new Tone.Synth({ 
                            volume: -32, 
                            oscillator: { type: 'sine' }, 
                            envelope: { attack: 0.015, decay: 0.12, sustain: 0.08, release: 0.25 } 
                        }).connect(this.scentPanner),
                        scentDrag: new Tone.Synth({ 
                            volume: -28, 
                            oscillator: { type: 'triangle' }, 
                            envelope: { attack: 0.01, decay: 0.2, sustain: 0.3, release: 0.4 } 
                        }).connect(this.scentPanner),
                        module1: new Tone.PluckSynth({ volume: -26, dampening: 3500, resonance: 0.96 }).connect(delay),
                        module2: new Tone.MonoSynth({ volume: -28, oscillator: { type: 'square' }, envelope: { attack: 0.1, decay: 0.2, sustain: 0.5, release: 0.5 } }).connect(chorus),
                        breakthrough: new Tone.PolySynth(Tone.AMSynth, { 
                            volume: -20, 
                            harmonicity: 1.8, 
                            modulationType: 'square',
                            envelope: { attack: 0.06, decay: 4.5, sustain: 0.15, release: 5.5 } 
                        }).connect(reverb),
                        module3_hit: new Tone.MetalSynth({ volume: -22, frequency: 150, envelope: { attack: 0.001, decay: 0.08, release: 0.05 }, harmonicity: 5, modulationIndex: 10 }).connect(filter),
                        module3_unstable: new Tone.NoiseSynth({ volume: -30, noise: { type: 'white' }, envelope: { attack: 0.01, decay: 0.1, sustain: 0.2, release: 0.2 } }).connect(filter),
                        crystal_ring: new Tone.FMSynth({ volume: -24, harmonicity: 2.5, modulationIndex: 8, envelope: { attack: 0.001, decay: 0.4, sustain: 0.1, release: 0.5 } }).connect(reverb),
                        reflex_start: new Tone.MembraneSynth({ volume: -18, pitchDecay: 0.01, octaves: 1.5, envelope: { attack: 0.005, decay: 0.3, sustain: 0, release: 0.1 } }).connect(delay),
                        reflex_cue: new Tone.FMSynth({ volume: -20, harmonicity: 0.5, modulationIndex: 5, envelope: { attack: 0.001, decay: 0.05, sustain: 0, release: 0.02 } }).connect(filter),
                        reflex_hit: new Tone.Synth({ volume: -15, oscillator: { type: 'sine' }, envelope: { attack: 0.001, decay: 0.1, sustain: 0, release: 0.05 } }).connect(reverb),
                        reflex_miss: new Tone.NoiseSynth({ volume: -25, noise: { type: 'brown' }, envelope: { attack: 0.01, decay: 0.1, sustain: 0, release: 0.05 } }).connect(filter),
                        flow_pacer: new Tone.Synth({ volume: -28, oscillator: { type: 'sine' }, envelope: { attack: 1.0, decay: 0.5, sustain: 0.8, release: 1.5 } }).connect(reverb),
                    };
                    
                    this.initialized = true;
                    this.playAmbientLoop();
                    this.playAmbientPianoLayer();
                } catch(e) { console.warn('Sound init error:', e); }
            },
            
            stopAmbient() {
                if (this.ambientLoop) {
                    this.ambientLoop.dispose();
                    this.ambientLoop = null;
                }
                if (this.ambientPianoLoop) {
                    this.ambientPianoLoop.dispose();
                    this.ambientPianoLoop = null;
                }
                if (Tone.Transport.state !== 'stopped') {
                    Tone.Transport.stop();
                }
                if (this.vinylNoise) {
                    this.vinylNoise.stop();
                    this.vinylNoise.dispose();
                    this.vinylNoise = null;
                }
            },

            playAmbientLoop() {
                if (!this.ambient || this.ambientLoop) return;
                this.ambientLoop = new Tone.Loop((time) => {
                    this.ambient.triggerAttackRelease(['C3', 'Eb3', 'G3', 'Bb3'], '8m', time, 0.25);
                }, '8m');
                this.ambientLoop.start(0);
                Tone.Transport.start();
            },
            
            playAmbientPianoLayer() {
                if (!this.ambientPiano || this.ambientPianoLoop) return;
                const etherealChords = [
                    ['C4', 'E4', 'G4', 'B4'],
                    ['D4', 'F#4', 'A4', 'C5'],
                    ['G3', 'B3', 'D4', 'F#4'],
                    ['A3', 'C#4', 'E4', 'G#4']
                ];
                
                let chordIndex = 0;
                this.ambientPianoLoop = new Tone.Loop((time) => {
                    if (Math.random() > 0.65) {
                        const chord = etherealChords[chordIndex % etherealChords.length];
                        chord.forEach((note, i) => {
                            this.ambientPiano.triggerAttackRelease(note, '2m', time + i * 0.1, 0.4);
                        });
                        chordIndex++;
                    }
                }, '4m');
                this.ambientPianoLoop.start('+2m');
            },
            
            play(type, note = 'C4', velocity = 0.7) {
                if (!this.initialized || Tone.context.state !== 'running') return;
                try {
                    const now = Tone.now();
                    switch(type) {
                        case 'click': 
                            this.synths.click.triggerAttackRelease('C3', '8n', now, velocity * 0.5); 
                            break;
                        case 'hover': 
                            this.synths.hover.triggerAttackRelease('C6', '64n', now, 0.12); 
                            break;
                        case 'success': 
                            this.synths.success.triggerAttackRelease(['C5', 'Eb5', 'G5'], '2s', now, velocity * 0.6); 
                            break;
                        case 'slider': 
                            this.synths.slider.triggerAttackRelease(note, '32n', now, velocity * 0.5); 
                            break;
                        case 'breakthrough': 
                            this.synths.breakthrough.triggerAttackRelease(['C4', 'E4', 'G4', 'B4'], '3s', now, velocity * 0.7); 
                            break;
                        case 'module3_hit': 
                            this.synths.module3_hit.triggerAttackRelease('C3', '8n', now, velocity * 0.6);
                            break;
                        case 'reflex_cue': 
                            this.synths.reflex_cue.triggerAttackRelease('A5', '64n', now, 1.0);
                            break;
                        case 'reflex_hit':
                            this.synths.reflex_hit.triggerAttackRelease('G5', '16n', now, 0.9);
                            break;
                        default: 
                            if (this.synths[type]) this.synths[type].triggerAttackRelease(note, '16n', now, velocity * 0.6);
                    }
                } catch(e) { console.warn('Sound play error:', e); }
            },
            
            playScentDrag(distance, angle) {
                if (!this.initialized || Tone.context.state !== 'running') return;
                try {
                    const freq = 200 + distance * 600;
                    const note = Tone.Frequency(freq, "hz").toNote();
                    
                    const pan = Math.cos(angle);
                    if (this.scentPanner) {
                        this.scentPanner.positionX.rampTo(pan, 0.05);
                    }
                    
                    this.synths.scentDrag.frequency.rampTo(freq, 0.05);
                    if (this.synths.scentDrag.envelope.value === 0) {
                        this.synths.scentDrag.triggerAttack(note, Tone.now(), 0.5);
                    }
                } catch(e) { console.warn('Scent drag sound error:', e); }
            },
            
            stopScentDrag() {
                if (this.synths.scentDrag) {
                    this.synths.scentDrag.triggerRelease();
                }
            },
            
            start(type, note = 'C4', velocity = 0.7) {
                if (!this.initialized || Tone.context.state !== 'running') return;
                try {
                    if (this.synths[type] && this.synths[type].triggerAttack) {
                        this.synths[type].triggerAttack(note, Tone.now(), velocity * 0.6);
                    }
                } catch(e) { console.warn('Sound start error:', e); }
            },

            release(type) {
                if (!this.initialized || !this.synths[type] || !this.synths[type].triggerRelease) return;
                try { 
                    this.synths[type].triggerRelease();
                }
                catch(e) { console.warn('Sound release error:', e); }
            }
        };
        
        const I18N = {
            lang: 'en',
            data: {
                en: {
                    welcome_sub: 'Personalized Olfactory-Cognitive Training',
                    btn_begin: 'BEGIN',
                    btn_continue: 'CONTINUE',
                    btn_back: '← BACK',
                    btn_finish: 'COMPLETE SESSION',
                    btn_restart: 'NEW SESSION',
                    btn_start_game: 'START TRAINING',
                    info_title: 'Profile',
                    info_name: 'Name',
                    info_age: 'Age',
                    info_gender: 'Gender',
                    info_status: 'Status',
                    info_male: 'Male',
                    info_female: 'Female',
                    info_nonbinary: 'Nonbinary',
                    info_prefer_not: 'Prefer not to say',
                    info_early: 'Early Stage',
                    info_moderate: 'Moderate',
                    info_control: 'Control',
                    scent_title: 'Olfactory Profile',
                    scent_desc: 'Drag outward from center to set preference',
                    modules_title: 'Training Modules',
                    difficulty_label: 'Simulate Patient tOC (Total Outlier Count)',
                    difficulty_desc: 'Higher tOC increases module difficulty.',
                    stat_time: 'Time',
                    stat_score: 'Score',
                    stat_progress: 'Progress',
                    results_title: 'Session Report',
                    results_scent: 'Recommended Scent Profile',
                    total_time: 'Total Time',
                    avg_score: 'Average Score',
                    modules_completed: 'Modules Completed',
                    floral_desc: 'ETHEREAL, EMOTIONAL, MEMORY\n\nDelicate petals unfolding in soft whispers. Linked to emotional warmth and nostalgic recall.\nExamples: Rose, Jasmine, Ylang-Ylang, Neroli',
                    woody_desc: 'GROUNDED, ENDURING, FOCUS\n\nDeep timber essence. Anchors attention and provides steady mental foundation.\nExamples: Cedarwood, Sandalwood, Oud, Vetiver',
                    citrus_desc: 'SHARP, VIBRANT, ALERTNESS\n\nA sudden, zesty burst used to enhance cognitive speed and refresh attention.\nExamples: Lemon, Bergamot, Grapefruit, Lime',
                    earthy_desc: 'ROOTED, CALM, PRESENCE\n\nMoss-covered stones and ancient soil. Cultivates deep presence and stability.\nExamples: Patchouli, Oakmoss, Earth, Mushroom',
                    fresh_desc: 'CRISP, CLEAR, RENEWAL\n\nCool morning air and mountain springs. Clears mental fog and stimulates clarity.\nExamples: Eucalyptus, Marine, Mint, Pine',
                    spicy_desc: 'WARM, INTENSE, STIMULATION\n\nFiery heat that awakens. Sharpens reflexes and accelerates processing.\nExamples: Cinnamon, Clove, Ginger, Black Pepper',
                    mod1_intro: 'Count the flowing school',
                    mod2_intro: 'Capture the signal through noise',
                    mod3_intro: 'Stabilize reality, solve the pattern',
                    mod4_intro: 'Align the frequency waves', 
                    mod5_intro: 'React to the black targets',
                    mod6_intro: 'Flow with the cosmic vortex breath',
                    mod1_desc: 'Memory: Count fish in passing schools',
                    mod2_desc: 'Signal: Maintain focus through noise',
                    mod3_desc: 'Pattern: Stabilize and solve the core',
                    mod4_desc: 'Wave Match: Align oscillating frequencies', 
                    mod5_desc: 'Reflex: Hit black dots, avoid red distractions',
                    mod6_desc: 'Flow: Synchronize with Kármán vortex (4-7-8)',
                    mod1_tut_title: 'Memory: Fish School Counter',
                    mod1_tut_desc: 'Watch fish swim across the screen. Count how many you see! First round: count 1 school. Later rounds: count 2 schools separately.',
                    mod2_tut_title: 'Signal',
                    mod2_tut_desc: 'A signal moves through noise. CAPTURE and HOLD it precisely with your finger/mouse until breakthrough energy builds.',
                    mod3_tut_title: 'Pattern Recognition',
                    mod3_tut_desc: 'PRESS AND HOLD (two fingers on mobile, click/press on desktop) to stabilize the core. Answer the cognitive question quickly. Errors incur penalties.',
                    mod4_tut_title: 'Frequency Wave Match',
                    mod4_tut_desc: 'On a retro screen, several wave patterns oscillate. Adjust the red control wave\'s frequency and amplitude using sliders until it matches the green target wave. Match all waves to complete.',
                    mod5_tut_title: 'Reflex: Target Practice',
                    mod5_tut_desc: 'After 3-2-1 countdown, dots will light up. Tap BLACK dots quickly for points. AVOID RED dots (they subtract points). Miss a black dot and lose points too. Stay sharp!',
                    mod6_tut_title: 'Flow: Kármán Vortex',
                    mod6_tut_desc: 'Guided 4-7-8 breathing synchronized with fluid dynamics. Inhale (4s, HOLD), Pause (7s), Exhale (8s, RELEASE). Follow the Kármán vortex street pattern. Only synchronization matters.',
                },
                zh: {
                    welcome_sub: '个性化嗅觉-认知训练',
                    btn_begin: '开始',
                    btn_continue: '继续',
                    btn_back: '← 返回',
                    btn_finish: '完成会话',
                    btn_restart: '新会话',
                    btn_start_game: '开始训练',
                    info_title: '个人档案',
                    info_name: '姓名',
                    info_age: '年龄',
                    info_gender: '性别',
                    info_status: '状态',
                    info_male: '男性',
                    info_female: '女性',
                    info_nonbinary: '非二元',
                    info_prefer_not: '不愿透露',
                    info_early: '早期',
                    info_moderate: '中度',
                    info_control: '可控范围内',
                    scent_title: '气味偏好档案',
                    scent_desc: '从中心向外拖动以设置偏好度',
                    modules_title: '训练模块',
                    difficulty_label: '模拟患者tOC(总离群值计数)',
                    difficulty_desc: '更高的tOC值将增加模块难度。',
                    stat_time: '耗时',
                    stat_score: '得分',
                    stat_progress: '进度',
                    results_title: '会话报告',
                    results_scent: '推荐气味档案',
                    total_time: '总耗时',
                    avg_score: '平均得分',
                    modules_completed: '已完成模块',
                    floral_desc: '空灵、情感、记忆\n\n轻柔的花瓣在低语中绽放。与情感温暖和怀旧回忆相联系。\n例如: 玫瑰、茉莉、依兰、橙花',
                    woody_desc: '扎根、持久、专注\n\n深沉的木质本质。锚定注意力并提供稳定的心智基础。\n例如: 雪松、檀香、沉香、岩兰草',
                    citrus_desc: '锐利、活力、警觉\n\n突如其来的清新爆发,用于增强认知速度和刷新注意力。\n例如: 柠檬、佛手柑、葡萄柚、青柠',
                    earthy_desc: '根植、平静、临在\n\n苔藓覆盖的石头和古老的土壤。培养深层临在感和稳定性。\n例如: 广藿香、橡苔、泥土、蘑菇',
                    fresh_desc: '清爽、清晰、更新\n\n清晨的空气和山泉。清除思维迷雾并刺激清晰度。\n例如: 桉树、海洋、薄荷、松树',
                    spicy_desc: '温暖、强烈、刺激\n\n唤醒的炽热。磨砺反射并加速处理。\n例如: 肉桂、丁香、生姜、黑胡椒',
                    mod1_intro: '数清游过的鱼群',
                    mod2_intro: '在噪声中捕捉信号',
                    mod3_intro: '稳定现实,破解模式',
                    mod4_intro: '对齐频率波形',
                    mod5_intro: '响应黑色目标',
                    mod6_intro: '跟随宇宙涡旋呼吸流动',
                    mod1_desc: '记忆: 计算游过的鱼群数量',
                    mod2_desc: '信号: 在噪声中保持专注力',
                    mod3_desc: '模式: 稳定并解决核心认知问题',
                    mod4_desc: '波形匹配: 对齐振荡频率',
                    mod5_desc: '反射: 击打黑点,避开红色干扰',
                    mod6_desc: '流动: 同步卡门涡街 (4-7-8)',
                    mod1_tut_title: '记忆:鱼群计数',
                    mod1_tut_desc: '观察鱼群游过屏幕。数清你看到了几条!第一轮:数1群。后续轮次:分别数2群。',
                    mod2_tut_title: '信号',
                    mod2_tut_desc: '信号在噪声中移动。用手指/鼠标精确捕捉并按住它,直到突破能量积累完成。',
                    mod3_tut_title: '模式识别',
                    mod3_tut_desc: '按住(移动设备双指按住,桌面端点击/按住)以稳定核心。快速回答认知问题。错误将受到惩罚。',
                    mod4_tut_title: '频率波形匹配',
                    mod4_tut_desc: '复古屏幕上,多条波形振荡。使用滑块调整红色控制波的频率和振幅,直到它匹配绿色目标波。匹配所有波形即可完成。',
                    mod5_tut_title: '反射:目标练习',
                    mod5_tut_desc: '3-2-1倒计时后,点会亮起。快速点击黑色点得分。避开红色点(会扣分)。错过黑点也会扣分。保持警觉!',
                    mod6_tut_title: '流动:卡门涡街',
                    mod6_tut_desc: '引导式4-7-8呼吸与流体动力学同步。吸气(4秒,按住)、屏息(7秒)、呼气(8秒,释放)。跟随卡门涡街模式。只有同步率。',
                }
            },
            set(lang) {
                this.lang = lang;
                document.querySelectorAll('[data-i18n]').forEach(el => {
                    const key = el.getAttribute('data-i18n');
                    if (this.data[lang][key]) el.textContent = this.data[lang][key];
                });
                
                document.querySelectorAll('#user-gender option').forEach(option => {
                    const key = option.dataset.i18n;
                    if (key) {
                        const baseText = option.value === '' ? (this.lang === 'zh' ? '选择性别' : 'Select gender') : (this.data.en[key] || '');
                        option.textContent = baseText + (this.lang === 'zh' ? ` / ${this.data.zh[key]}` : '');
                    }
                });
                document.querySelectorAll('#user-status option').forEach(option => {
                    const key = option.dataset.i18n;
                    if (key) {
                        const baseText = option.value === '' ? (this.lang === 'zh' ? '选择状态' : 'Select status') : (this.data.en[key] || '');
                        option.textContent = baseText + (this.lang === 'zh' ? ` / ${this.data.zh[key]}` : '');
                    }
                });

                if (App.state === 'MODULES') {
                    setTimeout(() => App.updateModules(), 10);
                }
                if (App.state === 'SCENT') LumenScent.updateLabels();
            },
            t(key) { return this.data[this.lang][key] || key; }
        };
        
        const LumenScent = {
            scents: [
                { 
                    id: 'floral', 
                    en: 'Floral', 
                    zh: '花香', 
                    shape: 'flower', 
                    colors: [
                        { r: 255, g: 220, b: 220 },
                        { r: 255, g: 120, b: 160 },
                        { r: 200, g: 80, b: 120 }
                    ] 
                },
                { 
                    id: 'woody', 
                    en: 'Woody', 
                    zh: '木质', 
                    shape: 'trunk', 
                    colors: [
                        { r: 139, g: 69, b: 19 },
                        { r: 131, g: 90, b: 60 },
                        { r: 44, g: 23, b: 8 }
                    ] 
                },
                { 
                    id: 'citrus', 
                    en: 'Citrus', 
                    zh: '柑橘', 
                    shape: 'burst', 
                    colors: [
                        { r: 255, g: 240, b: 100 },
                        { r: 255, g: 190, b: 0 },
                        { r: 255, g: 120, b: 0 }
                    ] 
                },
                { 
                    id: 'earthy', 
                    en: 'Earthy', 
                    zh: '土壤', 
                    shape: 'moss', 
                    colors: [
                        { r: 150, g: 170, b: 130 },
                        { r: 7, g: 90, b: 70 },
                        { r: 40, g: 60, b: 30 }
                    ] 
                },
                { 
                    id: 'fresh', 
                    en: 'Fresh', 
                    zh: '清新', 
                    shape: 'wave', 
                    colors: [
                        { r: 155, g: 183, b: 212 },
                        { r: 100, g: 140, b: 180 },
                        { r: 58, g: 78, b: 107 }
                    ] 
                },
                { 
                    id: 'spicy', 
                    en: 'Spicy', 
                    zh: '辛香', 
                    shape: 'chili', 
                    colors: [
                        { r: 178, g: 34, b: 34 },
                        { r: 124, g: 34, b: 32 },
                        { r: 95, g: 33, b: 25 }
                    ] 
                }
            ],
            values: {},
            instances: [],
            currentPage: 0,
            dragging: null,

            init() {
                this.scents.forEach(scent => {
                    this.values[scent.id] = 0;
                });
                
                this.instances = [];
                
                this.scents.forEach((scent, idx) => {
                    const pageEl = document.querySelector(`.scent-page[data-page="${idx}"]`);
                    if (!pageEl) return; 

                    pageEl.innerHTML = '';
                    
                    const container = document.createElement('div');
                    container.style.cssText = 'width: 100%; display: flex; flex-direction: column; align-items: center; flex: 1;';
                    
                    const canvasWrapper = document.createElement('div');
                    canvasWrapper.style.cssText = 'position: relative; flex-shrink: 0; margin-bottom: 1rem;';
                    
                    const canvas = document.createElement('canvas');
                    canvas.className = 'lumen-canvas';
                    
                    const isMobile = window.innerWidth <= 768;
                    const size = isMobile ? Math.min(280, window.innerWidth - 40) : Math.min(350, window.innerWidth - 60);
                    canvas.width = size;
                    canvas.height = size;
                    canvasWrapper.appendChild(canvas);
                    container.appendChild(canvasWrapper);
                    
                    const label = document.createElement('div');
                    label.className = 'lumen-label';
                    label.innerHTML = `
                        <div class="lumen-name ${I18N.lang === 'zh' ? 'zh' : ''}" data-scent="${scent.id}">${scent[I18N.lang]}</div>
                        <div class="lumen-value" data-value="${scent.id}">0</div>
                        <p class="lumen-instruction">
                            ${I18N.lang === 'en' ? 'Drag outward from center' : '从中心向外拖动'}
                        </p>
                    `;
                    container.appendChild(label);
                    
                    const introBox = document.createElement('div');
                    introBox.className = `scent-intro-box ${I18N.lang === 'zh' ? 'zh' : ''}`;
                    introBox.dataset.scent = scent.id;
                    const key = `${scent.id}_desc`;
                    introBox.textContent = I18N.t(key);
                    container.appendChild(introBox);
                    
                    pageEl.appendChild(container);
                    
                    const instance = new LumenOrganicParticles(canvas, scent, this);
                    this.instances.push(instance);
                    
                    this.addRadialInteraction(canvas, scent.id, instance);
                });
                
                this.updateLabels();
            },

            update(deltaTime = 16.6) {
                if (App.state !== 'SCENT') return;
                try {
                    this.instances.forEach(inst => inst.update(deltaTime));
                } catch(e) {
                    console.error('LumenScent update error:', e);
                    // Don't throw - continue rendering
                }
            },

            addRadialInteraction(canvas, scentId, instance) {
                const getPointer = (e) => {
                    const rect = canvas.getBoundingClientRect();
                    const x = (e.clientX || (e.touches && e.touches[0].clientX)) - rect.left;
                    const y = (e.clientY || (e.touches && e.touches[0].clientY)) - rect.top;
                    return { x, y };
                };
                
                const onStart = (e) => {
                    this.dragging = scentId;
                    instance.isDragging = true;
                    Haptic.light();
                    e.preventDefault();
                };
                
                const onMove = PerformanceUtils.throttle((e) => {
                    if (this.dragging !== scentId) return;
                    
                    const pos = getPointer(e);
                    const centerX = canvas.width / 2;
                    const centerY = canvas.height / 2;
                    
                    const dx = pos.x - centerX;
                    const dy = pos.y - centerY;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    const maxDist = Math.min(centerX, centerY) * 0.8;
                    
                    const value = Math.min(100, Math.max(0, (dist / maxDist) * 100));
                    this.values[scentId] = Math.round(value);
                    
                    document.querySelector(`[data-value="${scentId}"]`).textContent = this.values[scentId];
                    
                    instance.targetIntensity = this.values[scentId] / 100;
                    instance.dragAngle = Math.atan2(dy, dx);
                    instance.dragDist = dist / maxDist;
                    
                    Sound.playScentDrag(instance.dragDist, instance.dragAngle);
                    
                    e.preventDefault();
                }, 16);
                
                const onEnd = () => {
                    if (this.dragging === scentId) {
                        this.dragging = null;
                        instance.isDragging = false;
                        Sound.stopScentDrag();
                    }
                };
                
                canvas.addEventListener('mousedown', onStart);
                canvas.addEventListener('touchstart', onStart, { passive: false });
                
                document.addEventListener('mousemove', onMove);
                document.addEventListener('touchmove', onMove, { passive: false });
                
                document.addEventListener('mouseup', onEnd);
                document.addEventListener('touchend', onEnd);
                
                canvas.addEventListener('contextmenu', e => e.preventDefault());

                canvas.eventListeners = { onStart, onMove, onEnd };
            },
            
            prevPage() {
                if (this.currentPage > 0) {
                    this.goToPage(this.currentPage - 1);
                    Sound.play('click');
                }
            },
            
            nextPage() {
                if (this.currentPage < 5) {
                    this.goToPage(this.currentPage + 1);
                    Sound.play('click');
                }
            },
            
            goToPage(page) {
                const pages = document.querySelectorAll('.scent-page');
                const dots = document.querySelectorAll('.page-dot');
                
                pages[this.currentPage].classList.remove('active');
                pages[this.currentPage].classList.add('prev');
                
                pages[page].classList.remove('prev');
                pages[page].classList.add('active');
                
                dots[this.currentPage].classList.remove('active');
                dots[page].classList.add('active');
                
                this.currentPage = page;
                
                document.getElementById('scent-prev').style.opacity = page === 0 ? '0.3' : '1';
                document.getElementById('scent-next').style.opacity = page === 5 ? '0.3' : '1';
                
                this.updateLabels();
            },
            
            updateLabels() {
                document.querySelectorAll('.scent-intro-box').forEach(introEl => {
                    const scentId = introEl.dataset.scent;
                    if (scentId) {
                        introEl.classList.toggle('zh', I18N.lang === 'zh');
                        const key = `${scentId}_desc`;
                        introEl.textContent = I18N.t(key);
                    }
                });

                this.scents.forEach(scent => {
                    const el = document.querySelector(`[data-scent="${scent.id}"]`);
                    if (el && el.classList.contains('lumen-name')) {
                        el.textContent = scent[I18N.lang];
                        el.className = `lumen-name ${I18N.lang === 'zh' ? 'zh' : ''}`;
                    }
                });
                
                document.querySelectorAll('.lumen-instruction').forEach(instr => {
                    instr.textContent = I18N.lang === 'en' ? 'Drag outward from center' : '从中心向外拖动';
                });
            },
            
            cleanup() {
                this.instances.forEach(instance => {
                    const { onStart, onMove, onEnd } = instance.canvas.eventListeners || {};

                    if (onStart) {
                        instance.canvas.removeEventListener('mousedown', onStart);
                        instance.canvas.removeEventListener('touchstart', onStart);
                        document.removeEventListener('mousemove', onMove);
                        document.removeEventListener('touchmove', onMove);
                        document.removeEventListener('mouseup', onEnd);
                        document.removeEventListener('touchend', onEnd);
                    }
                });
                this.instances = [];
            }
        };
        
        class LumenOrganicParticles {
            constructor(canvas, scent, parent) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d', { alpha: true, willReadFrequently: false });
                this.scent = scent;
                this.parent = parent;
                this.particles = [];
                this.time = 0;
                this.intensity = 0;
                this.targetIntensity = 0;
                this.isDragging = false;
                this.dragAngle = 0;
                this.dragDist = 0;
                
                const numParticles = 1000;
                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;
                
                for (let i = 0; i < numParticles; i++) {
                    const layer = Math.random();
                    const angle = Math.random() * Math.PI * 2;
                    
                    let radius, distribution, sizeBase;
                    
                    switch(scent.shape) {
                        case 'flower':
                            const petalIndex = Math.floor(Math.random() * 6);
                            const petalAngle = (petalIndex / 6) * Math.PI * 2;
                            const petalOffset = Math.sin((angle - petalAngle) * 6) * 0.4 + 0.6;
                            radius = Math.pow(Math.random(), 0.4) * 90 * petalOffset;
                            distribution = Math.sin(angle * 6) * 0.4 + 0.8;
                            sizeBase = 1.8;
                            break;
                        case 'trunk':
                            const grainLayer = Math.floor(Math.random() * 15);
                            const grainNoise = (Math.sin(angle * 20 + grainLayer * 0.5) + Math.cos(angle * 15)) * 0.15;
                            radius = (grainLayer / 15) * 80 + grainNoise * 10 + Math.random() * 4;
                            distribution = Math.abs(Math.sin(angle * 18 + grainLayer * 0.3)) * 0.3 + 0.75;
                            sizeBase = 1.4;
                            break;
                        case 'burst':
                            const burstRing = Math.floor(Math.random() * 8);
                            radius = Math.pow(Math.random(), 0.25) * 95 * (0.7 + burstRing / 16);
                            distribution = 1;
                            sizeBase = 1.6;
                            break;
                        case 'moss':
                            const mossCluster = Math.sin(angle * 7 + Math.random() * 3) * 0.3;
                            radius = Math.pow(Math.random(), 0.8) * 75 + mossCluster * 15;
                            distribution = (Math.sin(angle * 6) + Math.cos(angle * 9)) * 0.25 + 0.7;
                            sizeBase = 2.2;
                            break;
                        case 'wave':
                            const waveLayer = Math.floor(Math.random() * 8);
                            radius = Math.pow(Math.random(), 0.65) * 65 * (0.5 + waveLayer / 16);
                            distribution = Math.abs(Math.cos(angle * 5 + Math.sin(angle * 2) * 2)) * 0.35 + 0.7;
                            sizeBase = 1.4;
                            break;
                        case 'chili':
                            const spiceIntensity = Math.pow(Math.random(), 0.5);
                            radius = spiceIntensity * 80;
                            distribution = Math.pow(Math.abs(Math.sin(angle * 10)), 1.5) * 0.6 + 0.5;
                            sizeBase = 1.3;
                            break;
                        default:
                            radius = Math.pow(Math.random(), 0.6) * 70;
                            distribution = 1;
                            sizeBase = 2.0;
                    }
                    
                    radius *= distribution;
                    
                    const x = centerX + Math.cos(angle) * radius;
                    const y = centerY + Math.sin(angle) * radius;
                    
                    this.particles.push({
                        baseX: x,
                        baseY: y,
                        x: x,
                        y: y,
                        angle: angle,
                        radius: radius,
                        size: Math.random() * sizeBase + 0.8,
                        speedX: (Math.random() - 0.5) * 0.2,
                        speedY: (Math.random() - 0.5) * 0.2,
                        breathPhase: Math.random() * Math.PI * 2,
                        layer: layer,
                        energy: Math.random(),
                        noiseOffset: Math.random() * 100
                    });
                }
            }
            
            update(deltaTime = 16.6) {
                this.time += deltaTime / 1000;
                
                const diff = this.targetIntensity - this.intensity;
                this.intensity += diff * 0.12;
                
                const ctx = this.ctx;
                const w = this.canvas.width;
                const h = this.canvas.height;
                const centerX = w / 2;
                const centerY = h / 2;
                
                ctx.fillStyle = 'rgba(245, 245, 240, 0.95)';
                ctx.fillRect(0, 0, w, h);
                
                const colors = this.scent.colors;
                
                const globalBreath = Math.sin(this.time * 0.5) * 0.5 + 0.5;
                
                this.particles.forEach(p => {
                    const breathe = Math.sin(this.time * 0.7 + p.breathPhase) * 0.5 + 0.5;
                    const breathScale = 1 + (breathe * 0.1 + globalBreath * 0.05);
                    
                    const maxExpansion = this.scent.shape === 'wave' ? 1.8 : 2.5;
                    const expansion = this.intensity * maxExpansion;
                    
                    let targetX = centerX + (p.baseX - centerX) * (1 + expansion) * breathScale;
                    let targetY = centerY + (p.baseY - centerY) * (1 + expansion) * breathScale;
                    
                    if (this.isDragging) {
                        const dragInfluence = this.intensity * 0.6;
                        const particleAngleToDrag = Math.atan2(p.baseY - centerY, p.baseX - centerX);
                        const angleDiff = Math.abs(particleAngleToDrag - this.dragAngle);
                        const angleProximity = Math.cos(angleDiff);
                        
                        const dragForce = dragInfluence * angleProximity * (1 - p.layer * 0.5);
                        targetX += Math.cos(this.dragAngle) * this.dragDist * dragForce * 180;
                        targetY += Math.sin(this.dragAngle) * this.dragDist * dragForce * 180;
                    }
                    
                    p.x += (targetX - p.x) * 0.2 + p.speedX * (1 - this.intensity * 0.7);
                    p.y += (targetY - p.y) * 0.2 + p.speedY * (1 - this.intensity * 0.7);
                    
                    let r, g, b;
                    const energyBoost = p.energy * 0.2;
                    
                    if (this.intensity < 0.5) {
                        const t = this.intensity / 0.5;
                        r = colors[0].r + (colors[1].r - colors[0].r) * t;
                        g = colors[0].g + (colors[1].g - colors[0].g) * t;
                        b = colors[0].b + (colors[1].b - colors[0].b) * t;
                    } else {
                        const t = (this.intensity - 0.5) / 0.5;
                        r = colors[1].r + (colors[2].r - colors[1].r) * t;
                        g = colors[1].g + (colors[2].g - colors[1].g) * t;
                        b = colors[1].b + (colors[2].b - colors[1].b) * t;
                    }
                    
                    r = Math.min(255, r + energyBoost * 30);
                    g = Math.min(255, g + energyBoost * 25);
                    b = Math.min(255, b + energyBoost * 20);
                    
                    const baseSize = p.size * (0.8 + this.intensity * 2.0);
                    const size = baseSize * (1 + breathe * 0.3) * (0.7 + p.layer * 0.6);
                    
                    const baseAlpha = 0.2 + this.intensity * 0.85;
                    const alpha = baseAlpha * (0.6 + p.layer * 0.7);
                    
                    ctx.fillStyle = `rgba(${Math.round(r)}, ${Math.round(g)}, ${Math.round(b)}, ${alpha})`;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, size, 0, Math.PI * 2);
                    ctx.fill();
                    
                    if (this.intensity > 0.4) {
                        const glowAlpha = (this.intensity - 0.4) * 0.3 * alpha;
                        ctx.fillStyle = `rgba(${Math.round(r)}, ${Math.round(g)}, ${Math.round(b)}, ${glowAlpha})`;
                        ctx.beginPath();
                        ctx.arc(p.x, p.y, size * 4, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    
                    if (this.intensity > 0.75) {
                        const outerGlow = (this.intensity - 0.75) * 0.2;
                        ctx.fillStyle = `rgba(${Math.round(r)}, ${Math.round(g)}, ${Math.round(b)}, ${outerGlow})`;
                        ctx.beginPath();
                        ctx.arc(p.x, p.y, size * 7, 0, Math.PI * 2);
                        ctx.fill();
                    }
                });
                
                if (this.intensity > 0.7) {
                    const gradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, 200);
                    const c = colors[Math.min(2, Math.floor(this.intensity * 3))];
                    const bloomIntensity = (this.intensity - 0.7) * 0.5;
                    gradient.addColorStop(0, `rgba(${c.r}, ${c.g}, ${c.b}, ${bloomIntensity})`);
                    gradient.addColorStop(0.5, `rgba(${c.r}, ${c.g}, ${c.b}, ${bloomIntensity * 0.3})`);
                    gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, w, h);
                }
            }
        }
        
        const App = {
            state: 'WELCOME',
            patient: {},
            scents: {},
            modules: {},
            completed: new Set(),
            current: null,
            tOC: 20,
            
            screens: {
                WELCOME: 'welcome-screen',
                INFO: 'info-screen', 
                SCENT: 'scent-screen',
                MODULES: 'module-selection-screen',
                GAME: 'game-screen',
                RESULTS: 'results-screen'
            },

            resetAllResources() {
                LumenScent.cleanup();
                if (GameEngine.module) {
                    GameEngine.module.cleanup();
                    GameEngine.module = null;
                }
            },
            
            setState(s) {
                // Cleanup previous state
                if (this.state === 'GAME' && GameEngine.module) {
                    try {
                        GameEngine.module.cleanup();
                        GameEngine.module = null;
                    } catch(e) {
                        console.error('Cleanup error on state change:', e);
                    }
                }
                
                if (this.state === 'SCENT') {
                    try {
                        LumenScent.cleanup();
                    } catch(e) {
                        console.error('LumenScent cleanup error:', e);
                    }
                }
                
                document.querySelectorAll('.screen').forEach(el => el.classList.remove('active'));
                
                document.getElementById(this.screens[s]).classList.add('active');
                this.state = s;
                
                document.getElementById('crystal-container').style.display = 'none';
                document.getElementById('reflex-canvas').style.display = 'none';
                document.getElementById('mod4-canvas').style.display = 'none';
                
                if (s === 'GAME') {
                    document.getElementById('game-ui').classList.add('active');
                    document.getElementById('game-stats').classList.add('active');
                    document.getElementById('back-btn').classList.add('active');
                } else {
                    document.getElementById('game-ui').classList.remove('active');
                    document.getElementById('game-stats').classList.remove('active');
                    document.getElementById('back-btn').classList.remove('active');
                    if (s !== 'SCENT') LumenScent.cleanup();
                }
                
                if (s === 'SCENT') setTimeout(() => LumenScent.init(), 100);
                if (s === 'MODULES') setTimeout(() => this.updateModules(), 10);
                
                try {
                    Visual.setScene(s);
                } catch(e) {
                    console.error('Visual.setScene error:', e);
                }
            },
            
            startModule(id) {
                this.current = id;
                this.setState('GAME');
                
                setTimeout(() => {
                    GameEngine.showTutorial(id);
                }, 100);
            },
            
            completeModule(id, data) {
                this.completed.add(id);
                this.modules[id] = data;
                Sound.play('success');
                Haptic.success();
                this.setState('MODULES');
                this.updateModules();
            },
            
            updateModules() {
                const grid = document.getElementById('module-gallery');
                grid.innerHTML = '';
                
                Object.entries(MODULES).forEach(([id, m]) => {
                    const cell = document.createElement('div');
                    cell.className = 'module-cell';
                    if (this.completed.has(id)) cell.classList.add('completed');
                    
                    const lang = I18N.lang;
                    cell.innerHTML = `
                        <h3 class="${lang === 'zh' ? 'zh' : 'serif'}">${m.title[lang]}</h3>
                        <p class="subtitle">${m.subtitle[lang]}</p>
                        <p class="description">${m.desc[lang]}</p>
                    `;
                    
                    cell.addEventListener('mouseenter', () => Sound.play('hover'));
                    cell.addEventListener('click', () => {
                        Sound.play('click');
                        Haptic.medium();
                        this.startModule(id);
                    });
                    grid.appendChild(cell);
                });
            },
            
            finish() {
                if (this.completed.size === 0) return;
                Sound.play('success');
                this.setState('RESULTS');
                setTimeout(() => this.showResults(), 100);
            },
            
            drawWheel() {
                const container = document.getElementById('scent-wheel');
                container.innerHTML = '';
                const canvas = document.createElement('canvas');
                const size = Math.min(400, container.clientWidth);
                canvas.width = size;
                canvas.height = size;
                container.appendChild(canvas);
                
                const ctx = canvas.getContext('2d');
                const cx = size / 2, cy = size / 2, r = size * 0.32;
                
                for (let i = 1; i <= 4; i++) {
                    ctx.beginPath();
                    ctx.arc(cx, cy, r * (i / 4), 0, Math.PI * 2);
                    ctx.strokeStyle = 'rgba(192, 38, 37, 0.2)';
                    ctx.lineWidth = 1;
                    ctx.stroke();
                }
                
                const cats = Object.keys(this.scents);
                const step = (Math.PI * 2) / cats.length;
                
                ctx.beginPath();
                cats.forEach((cat, i) => {
                    const angle = step * i - Math.PI / 2;
                    const val = this.scents[cat] / 100;
                    const x = cx + Math.cos(angle) * r * val;
                    const y = cy + Math.sin(angle) * r * val;
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                });
                ctx.closePath();
                ctx.fillStyle = 'rgba(192, 38, 37, 0.15)';
                ctx.fill();
                ctx.strokeStyle = '#c02625';
                ctx.lineWidth = 2.5;
                ctx.stroke();
                
                ctx.strokeStyle = 'rgba(192, 38, 37, 0.15)';
                ctx.lineWidth = 1;
                cats.forEach((cat, i) => {
                    const angle = step * i - Math.PI / 2;
                    ctx.beginPath();
                    ctx.moveTo(cx, cy);
                    ctx.lineTo(cx + Math.cos(angle) * r, cy + Math.sin(angle) * r);
                    ctx.stroke();
                });
                
                ctx.fillStyle = '#c02625';
                cats.forEach((cat, i) => {
                    const angle = step * i - Math.PI / 2;
                    const val = this.scents[cat] / 100;
                    const x = cx + Math.cos(angle) * r * val;
                    const y = cy + Math.sin(angle) * r * val;
                    
                    ctx.beginPath();
                    ctx.arc(x, y, 4, 0, Math.PI * 2);
                    ctx.fill();
                });
                
                ctx.fillStyle = '#2a2a2a';
                ctx.font = '11px Inter';
                ctx.textAlign = 'center';
                cats.forEach((cat, i) => {
                    const angle = step * i - Math.PI / 2;
                    const labelDist = r + 30;
                    const x = cx + Math.cos(angle) * labelDist;
                    const y = cy + Math.sin(angle) * labelDist + 4;
                    ctx.fillText(cat.toUpperCase(), x, y);
                });
            },

            drawReportVisualization() {
                const data = Object.entries(this.modules).map(([id, d]) => {
                    let normalizedScore = d.score;
                    if (id === '5' && d.score > 0) { 
                        normalizedScore = Math.min(100, Math.max(0, 100 - (d.score - 200) / 3));
                    }
                    return {
                        module: MODULES[id].title[I18N.lang],
                        score: normalizedScore,
                        rawScore: d.score,
                        id: id 
                    };
                });

                const container = document.getElementById('report-visualization');
                container.innerHTML = '';

                const margin = { top: 20, right: 20, bottom: 60, left: 40 };
                const width = container.clientWidth - margin.left - margin.right;
                const height = container.clientHeight - margin.top - margin.bottom;

                if (width <= 0 || height <= 0) return;

                const svg = d3.select(container)
                    .append("svg")
                    .attr("width", width + margin.left + margin.right)
                    .attr("height", height + margin.top + margin.bottom)
                    .append("g")
                    .attr("transform", `translate(${margin.left},${margin.top})`);

                const x = d3.scaleBand()
                    .domain(data.map(d => d.module))
                    .range([0, width])
                    .padding(0.1);

                const y = d3.scaleLinear()
                    .domain([0, 100])
                    .range([height, 0]);
                
                const colorScale = d3.scaleSequential(d3.interpolateInferno).domain([0, 100]);

                svg.append("g")
                    .attr("transform", `translate(0,${height})`)
                    .call(d3.axisBottom(x))
                    .selectAll("text")
                        .style("font-size", "10px")
                        .style("text-anchor", "end")
                        .attr("dx", "-.8em")
                        .attr("dy", ".15em")
                        .attr("transform", "rotate(-45)");

                svg.append("g")
                    .call(d3.axisLeft(y).tickFormat(d => `${d}%`))
                    .selectAll("text")
                    .style("fill", "#2a2a2a");

                svg.selectAll(".bar")
                    .data(data)
                    .enter().append("rect")
                    .attr("class", "bar")
                    .attr("x", d => x(d.module))
                    .attr("y", d => y(d.score))
                    .attr("width", x.bandwidth())
                    .attr("height", d => height - y(d.score))
                    .attr("fill", d => colorScale(d.score))
                    .on("mouseover", function(event, d) {
                        d3.select(this).attr("opacity", 0.8);
                        
                        const tooltipText = d.id === '5' ? `${Math.round(d.rawScore)} ms RT` : `${Math.round(d.score)}% Eff.`;
                        
                        svg.append("text")
                            .attr("id", "tooltip")
                            .attr("x", x(d.module) + x.bandwidth() / 2)
                            .attr("y", y(d.score) - 5)
                            .attr("text-anchor", "middle")
                            .style("font-size", "12px")
                            .style("fill", "#c02625")
                            .text(tooltipText);
                    })
                    .on("mouseout", function() {
                        d3.select(this).attr("opacity", 1.0);
                        d3.select("#tooltip").remove();
                    });
            },

            showResults() {
                const summary = document.getElementById('results-summary');
                summary.innerHTML = '';
                
                const totalTime = Object.values(this.modules).reduce((sum, d) => sum + (d.time || 0), 0);
                const avgScore = Object.values(this.modules).reduce((sum, d) => sum + (d.score || 0), 0) / this.completed.size;
                
                const summaryData = [
                    { key: 'modules_completed', value: this.completed.size },
                    { key: 'total_time', value: Math.round(totalTime) + 's' },
                    { key: 'avg_score', value: this.completed.has('5') ? 'N/A*' : Math.round(avgScore) }
                ];
                
                summaryData.forEach(item => {
                    const div = document.createElement('div');
                    div.className = 'summary-item';
                    div.innerHTML = `
                        <h4>${I18N.t(item.key)}</h4>
                        <div class="value">${item.value}</div>
                    `;
                    summary.appendChild(div);
                });
                
                const details = document.getElementById('results-details');
                details.innerHTML = '';
                
                Object.entries(this.modules).forEach(([id, data]) => {
                    const row = document.createElement('div');
                    row.className = 'detail-row';
                    const lang = I18N.lang;
                    const scoreText = id === '5' ? `${Math.round(data.score)} ms RT` : `${Math.round(data.score)} pts`;

                    row.innerHTML = `
                        <span class="detail-label ${lang === 'zh' ? 'zh' : ''}">${MODULES[id].title[lang]}</span>
                        <span class="detail-value">${scoreText} · ${Math.round(data.time)}s</span>
                    `;
                    details.appendChild(row);
                });
                
                let rec = [];
                const avgErrors = Object.values(this.modules).reduce((sum, d) => sum + (d.errors || 0), 0) / this.completed.size;
                const scentValues = this.scents;
                
                if (avgScore > 70) {
                    if (scentValues.floral > 60) rec.push('Jasmine');
                    if (scentValues.citrus > 60) rec.push('Bergamot');
                } else if (avgScore > 40) {
                    if (scentValues.woody > 50) rec.push('Sandalwood');
                    if (scentValues.earthy > 50) rec.push('Vetiver');
                    rec.push('Rosemary');
                } else {
                    rec.push('Lavender');
                    if (scentValues.fresh > 50) rec.push('Peppermint');
                    rec.push('Frankincense');
                }
                
                if (avgErrors > 10) rec.push('Chamomile');
                if (avgErrors < 3 && !rec.includes('Bergamot')) rec.push('Lemon');
                
                Object.entries(scentValues).forEach(([scent, value]) => {
                    if (value > 80) {
                        const map = {
                            floral: 'Rose',
                            woody: 'Cedar',
                            citrus: 'Orange',
                            earthy: 'Patchouli',
                            fresh: 'Eucalyptus',
                            spicy: 'Cinnamon'
                        };
                        if (!rec.includes(map[scent])) rec.push(map[scent]);
                    }
                });
                
                if (rec.length === 0) rec.push('Balanced Blend');
                
                document.getElementById('scent-result').textContent = rec.slice(0, 4).join(' + ');
                
                this.drawWheel();
                this.drawReportVisualization();
            },
        };
        
        const Visual = {
            scene: null,
            camera: null,
            renderer: null,
            current: null,
            animating: false,
            lastTime: 0,
            animationFrameId: null,
            errorCount: 0,
            maxErrors: 10,
            
            init() {
                try {
                    this.scene = new THREE.Scene();
                    this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                    this.camera.position.z = 5;
                    
                    const canvas = document.getElementById('canvas3d');
                    if (!canvas) throw new Error('Canvas not found');
                    
                    this.renderer = new THREE.WebGLRenderer({
                        canvas: canvas,
                        antialias: window.devicePixelRatio < 2,
                        alpha: true,
                        powerPreference: 'high-performance',
                        stencil: false,
                        depth: true
                    });
                    
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                    this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                    
                    const throttledResize = PerformanceUtils.throttle(() => this.resize(), 250);
                    window.addEventListener('resize', throttledResize);
                    
                    this.setScene('WELCOME');
                    this.lastTime = performance.now();
                    this.animating = true;
                    this.animate();
                    
                    return true;
                } catch(e) {
                    console.error('Visual init error:', e);
                    this.animating = false;
                    return false;
                }
            },
            
            resize() {
                if (!this.camera || !this.renderer) return;
                
                try {
                    this.camera.aspect = window.innerWidth / window.innerHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                    
                    if (App.state === 'RESULTS') App.drawReportVisualization(); 
                } catch(e) {
                    console.error('Resize error:', e);
                }
            },
            
            setScene(state) {
                try {
                    while (this.scene.children.length > 0) {
                        const obj = this.scene.children[0];
                        this.scene.remove(obj);
                        if (obj.geometry) obj.geometry.dispose();
                        if (obj.material) {
                            if (Array.isArray(obj.material)) {
                                obj.material.forEach(m => m.dispose());
                            } else {
                                obj.material.dispose();
                            }
                        }
                    }
                    
                    if (state === 'WELCOME' || state === 'INFO' || state === 'SCENT' || state === 'MODULES' || state === 'RESULTS') {
                        const geom = new THREE.BufferGeometry();
                        const particleCount = 500;
                        const pos = new Float32Array(particleCount * 3);
                        
                        for (let i = 0; i < particleCount; i++) {
                            pos[i*3] = (Math.random() - 0.5) * 20;
                            pos[i*3+1] = (Math.random() - 0.5) * 20;
                            pos[i*3+2] = (Math.random() - 0.5) * 20;
                        }
                        
                        geom.setAttribute('position', new THREE.BufferAttribute(pos, 3));
                        
                        const mat = new THREE.PointsMaterial({ 
                            size: 0.035, 
                            color: 0xc02625, 
                            transparent: true, 
                            opacity: 0.4
                        });
                        
                        this.current = new THREE.Points(geom, mat);
                        this.scene.add(this.current);
                    }
                } catch(e) {
                    console.error('setScene error:', e);
                }
            },
            
            animate() {
                if (!this.animating) return;
                
                this.animationFrameId = requestAnimationFrame(() => this.animate());
                
                const now = performance.now();
                let deltaTime = (now - this.lastTime) / 1000;
                
                // Prevent deltaTime anomalies
                if (deltaTime <= 0 || deltaTime > 1 || !isFinite(deltaTime)) {
                    deltaTime = 0.016; // Fallback to 60fps
                }
                
                this.lastTime = now;
                
                try {
                    if (this.current) {
                        this.current.rotation.y += 0.05 * deltaTime;
                        this.current.rotation.x += 0.02 * deltaTime;
                    }

                    if (App.state === 'GAME' && GameEngine.module) {
                        GameEngine.update(GameEngine.stats, deltaTime);
                    } else if (App.state === 'SCENT') {
                        LumenScent.update(deltaTime);
                    }
                    
                    if (this.renderer && this.scene && this.camera) {
                        this.renderer.render(this.scene, this.camera);
                    }
                    
                    // Reset error count on successful frame
                    this.errorCount = 0;
                    
                } catch(e) {
                    console.error('Render/Update error:', e);
                    this.errorCount++;
                    
                    // If too many errors, stop animation to prevent white screen
                    if (this.errorCount >= this.maxErrors) {
                        console.error('Too many render errors, stopping animation');
                        this.stop();
                        this.showRenderError();
                    }
                }
            },
            
            stop() {
                this.animating = false;
                if (this.animationFrameId) {
                    cancelAnimationFrame(this.animationFrameId);
                    this.animationFrameId = null;
                }
            },
            
            showRenderError() {
                const errorDiv = document.createElement('div');
                errorDiv.style.cssText = 'position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(255,255,255,0.95); padding: 2rem; border: 2px solid #c02625; z-index: 10000; text-align: center; max-width: 400px;';
                errorDiv.innerHTML = `
                    <h3 style="color: #c02625; margin-bottom: 1rem;">Rendering Error</h3>
                    <p style="margin-bottom: 1rem;">The visualization has encountered an error.</p>
                    <button onclick="location.reload()" style="padding: 0.8rem 2rem; background: #c02625; color: white; border: none; cursor: pointer; text-transform: uppercase;">
                        Restart Session
                    </button>
                `;
                document.body.appendChild(errorDiv);
            }
        };

        
        const GameEngine = {
            module: null,
            t0: 0,
            stats: { time: 0, score: 0, progress: 0, errors: 0 },
            
            start(id) {
                document.getElementById('crystal-container').style.display = 'none';
                document.getElementById('reflex-canvas').style.display = 'none';
                document.getElementById('mod4-canvas').style.display = 'none';

                this.module = MODULES[id].create();
                this.module.id = id;
                this.t0 = Date.now();
                this.stats = { time: 0, score: 0, progress: 0, errors: 0 }; 
                
                const lang = I18N.lang;
                document.getElementById('game-title').textContent = MODULES[id].title[lang];
                
                const introTextEl = document.getElementById('game-intro-text');
                introTextEl.textContent = I18N.t(`mod${id}_intro`);
                introTextEl.classList.add('active-intro');

                setTimeout(() => {
                    introTextEl.classList.remove('active-intro');
                }, 3000);
                
                this.module.init();
            },

            showTutorial(id) {
                const tutorial = document.getElementById('tutorial-overlay');
                const lang = I18N.lang;
                
                document.getElementById('tutorial-title').textContent = I18N.t(`mod${id}_tut_title`);
                document.getElementById('tutorial-text').textContent = I18N.t(`mod${id}_tut_desc`);

                tutorial.classList.add('active');

                document.getElementById('game-ui').classList.add('active');
                document.getElementById('game-stats').classList.add('active');
                document.getElementById('back-btn').classList.add('active');

                const startButton = document.getElementById('tutorial-start-btn');
                
                const newStartButton = startButton.cloneNode(true);
                startButton.parentNode.replaceChild(newStartButton, startButton);
                
                newStartButton.addEventListener('click', () => {
                    tutorial.classList.remove('active');
                    this.start(id);
                    Sound.play('click');
                });
            },
            
            update(stats, deltaTime) {
                if (!this.module || App.state !== 'GAME') return;
                
                try {
                    stats.time = (Date.now() - this.t0) / 1000;
                    this.module.update(stats, deltaTime);
                    
                    document.getElementById('stat-time').textContent = Math.round(stats.time) + 's';
                    
                    if (this.module.id === '5' && typeof stats.score === 'number' && stats.score > 0) {
                        document.getElementById('stat-score').textContent = `${Math.round(stats.score)}ms`;
                    } else if (this.module.id === '5') {
                        document.getElementById('stat-score').textContent = '0ms';
                    } else {
                        document.getElementById('stat-score').textContent = Math.round(stats.score);
                    }
                    
                    document.getElementById('stat-progress').textContent = Math.round(stats.progress) + '%';
                } catch(e) {
                    console.error('GameEngine update error:', e);
                    // Don't throw - just log and continue
                }
            },
            
            complete() {
                if (!this.module) return;
                
                const finalScore = this.stats.score;
                const data = { 
                    time: this.stats.time, 
                    score: finalScore || 0, 
                    errors: this.stats.errors 
                };
                
                this.module.cleanup();
                App.completeModule(this.module.id, data);
                this.module = null;
            }
        };
        
        const MODULES = {
            '1': { 
                title: { en: 'Memory Trace', zh: '记忆轨迹' }, 
                subtitle: { en: 'Fish School', zh: '鱼群' }, 
                desc: { en: I18N.data.en.mod1_desc, zh: I18N.data.zh.mod1_desc }, 
                create: () => new Module1() 
            },
            '2': { 
                title: { en: 'Signal', zh: '信号' }, 
                subtitle: { en: 'Sustained Attention', zh: '持续注意力' }, 
                desc: { en: I18N.data.en.mod2_desc, zh: I18N.data.zh.mod2_desc }, 
                create: () => new Module2() 
            },
            '3': { 
                title: { en: 'Pattern', zh: '模式' }, 
                subtitle: { en: 'Cognitive Recognition', zh: '认知识别' }, 
                desc: { en: I18N.data.en.mod3_desc, zh: I18N.data.zh.mod3_desc }, 
                create: () => new Module3() 
            },
            '4': { 
                title: { en: 'Wave Match', zh: '波形匹配' }, 
                subtitle: { en: 'Frequency Align', zh: '频率对齐' }, 
                desc: { en: I18N.data.en.mod4_desc, zh: I18N.data.zh.mod4_desc }, 
                create: () => new Module4() 
            },
            '5': { 
                title: { en: 'Reflex', zh: '反射' }, 
                subtitle: { en: 'Precision Target', zh: '精确目标' }, 
                desc: { en: I18N.data.en.mod5_desc, zh: I18N.data.zh.mod5_desc }, 
                create: () => new Module5() 
            },
            '6': { 
                title: { en: 'Flow', zh: '流动' }, 
                subtitle: { en: 'Deep Presence', zh: '深层临在' }, 
                desc: { en: I18N.data.en.mod6_desc, zh: I18N.data.zh.mod6_desc }, 
                create: () => new Module6() 
            }
        };
        
        // MODULE 1: Fish School Counter
        class Module1 {
            init() {
                this.isActive = true;
                this.canvas = document.createElement('canvas');
                this.canvas.style.cssText = 'position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); max-width: 90vw; max-height: 70vh; border: 2px solid rgba(192, 38, 37, 0.3); background: #f5f5f0;';
                
                const size = Math.min(window.innerWidth * 0.9, window.innerHeight * 0.7, 600);
                this.canvas.width = size;
                this.canvas.height = size;
                this.ctx = this.canvas.getContext('2d');
                
                document.getElementById('game-screen').appendChild(this.canvas);
                
                const difficulty = App.tOC;
                this.round = 0;
                this.maxRounds = 3 + Math.floor(difficulty / 30);
                this.currentPhase = 'showing';
                this.schools = [];
                this.userAnswers = [];
                this.correctAnswers = [];
                
                this.startRound();
            }
            
            startRound() {
                this.round++;
                this.currentPhase = 'showing';
                this.schools = [];
                this.correctAnswers = [];
                
                const numSchools = this.round === 1 ? 1 : 2;
                
                for (let s = 0; s < numSchools; s++) {
                    const numFish = 3 + Math.floor(Math.random() * 5);
                    this.correctAnswers.push(numFish);
                    
                    const school = {
                        fish: [],
                        shown: false,
                        showTime: s * 4000 + 1000
                    };
                    
                    const baseY = this.canvas.height / 2 + (s - 0.5) * 100;
                    const startX = -100;
                    
                    for (let i = 0; i < numFish; i++) {
                        school.fish.push({
                            x: startX - i * 60,
                            y: baseY + (Math.random() - 0.5) * 40,
                            size: 15 + Math.random() * 10,
                            speed: 2 + Math.random() * 1,
                            phase: Math.random() * Math.PI * 2,
                            particles: this.createFishParticles()
                        });
                    }
                    
                    this.schools.push(school);
                }
                
                this.animationStart = Date.now();
            }
            
            createFishParticles() {
                const particles = [];
                const numParticles = 30;
                for (let i = 0; i < numParticles; i++) {
                    particles.push({
                        angle: (i / numParticles) * Math.PI * 2,
                        dist: Math.random() * 8 + 5,
                        size: Math.random() * 2 + 1
                    });
                }
                return particles;
            }
            
            drawFish(fish, time) {
                const ctx = this.ctx;
                const wobble = Math.sin(time * 3 + fish.phase) * 3;
                
                fish.particles.forEach(p => {
                    const x = fish.x + Math.cos(p.angle) * p.dist;
                    const y = fish.y + Math.sin(p.angle) * p.dist + wobble;
                    
                    ctx.fillStyle = `rgba(255, 122, 92, ${0.6 + Math.random() * 0.3})`;
                    ctx.beginPath();
                    ctx.arc(x, y, p.size, 0, Math.PI * 2);
                    ctx.fill();
                });
            }
            
            showAnswerPrompt() {
                this.currentPhase = 'answering';
                const overlay = document.getElementById('question-overlay');
                const questionText = document.getElementById('question-text');
                const optionsDiv = document.getElementById('answer-options');
                
                const lang = I18N.lang;
                if (this.round === 1 || this.correctAnswers.length === 1) {
                    questionText.textContent = lang === 'en' ? 'How many fish did you see?' : '你看到了几条鱼?';
                } else {
                    questionText.textContent = lang === 'en' ? 
                        'First school count? Then second school count?' : 
                        '第一群有几条?第二群有几条?';
                }
                
                optionsDiv.innerHTML = '';
                
                const createInput = (placeholder) => {
                    const input = document.createElement('input');
                    input.type = 'number';
                    input.min = '1';
                    input.max = '20';
                    input.placeholder = placeholder;
                    input.style.cssText = 'width: 100%; padding: 1rem; margin-bottom: 0.8rem; border: 1px solid rgba(192, 38, 37, 0.3); font-size: 1rem;';
                    return input;
                };
                
                const input1 = createInput(this.correctAnswers.length === 1 ? 'Enter count' : 'First school');
                optionsDiv.appendChild(input1);
                
                let input2;
                if (this.correctAnswers.length === 2) {
                    input2 = createInput('Second school');
                    optionsDiv.appendChild(input2);
                }
                
                const submitBtn = document.createElement('button');
                submitBtn.className = 'btn accent';
                submitBtn.textContent = lang === 'en' ? 'SUBMIT' : '提交';
                submitBtn.style.cssText = 'width: 100%; margin-top: 1rem;';
                submitBtn.addEventListener('click', () => {
                    const ans1 = parseInt(input1.value);
                    const ans2 = input2 ? parseInt(input2.value) : null;
                    
                    let correct = 0;
                    if (ans1 === this.correctAnswers[0]) correct++;
                    if (this.correctAnswers.length === 2 && ans2 === this.correctAnswers[1]) correct++;
                    
                    if (correct === this.correctAnswers.length) {
                        GameEngine.stats.score += 20;
                        Sound.play('success');
                        Haptic.success();
                    } else {
                        GameEngine.stats.errors++;
                        GameEngine.stats.score = Math.max(0, GameEngine.stats.score - 10);
                        Sound.play('click', 'C2', 0.5);
                        Haptic.error();
                    }
                    
                    overlay.classList.remove('active');
                    
                    if (this.round >= this.maxRounds) {
                        GameEngine.complete();
                    } else {
                        setTimeout(() => this.startRound(), 1000);
                    }
                });
                optionsDiv.appendChild(submitBtn);
                
                overlay.classList.add('active');
            }
            
            update(stats, deltaTime) {
                if (!this.isActive) return;
                
                const ctx = this.ctx;
                ctx.fillStyle = '#f5f5f0';
                ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                if (this.currentPhase === 'showing') {
                    const elapsed = Date.now() - this.animationStart;
                    const time = elapsed / 1000;
                    
                    let allDone = true;
                    
                    this.schools.forEach(school => {
                        if (elapsed > school.showTime && !school.shown) {
                            school.shown = true;
                        }
                        
                        if (school.shown) {
                            school.fish.forEach(fish => {
                                fish.x += fish.speed;
                                this.drawFish(fish, time);
                            });
                            
                            // Fish array is ordered: [0] is rightmost (enters first), [length-1] is leftmost (enters last)
                            // Check if the leftmost fish (last to enter) has completely left the screen
                            const leftmostFish = school.fish[school.fish.length - 1];
                            if (leftmostFish.x <= this.canvas.width + 100) {
                                allDone = false;
                            }
                        } else {
                            allDone = false;
                        }
                    });
                    
                    // Only show answer prompt when all schools have been shown AND all fish have left
                    const latestShowTime = Math.max(...this.schools.map(s => s.showTime));
                    if (allDone && elapsed > latestShowTime + 1000) {
                        this.showAnswerPrompt();
                    }
                }
                
                stats.progress = (this.round / this.maxRounds) * 100;
            }
            
            cleanup() {
                this.isActive = false;
                if (this.canvas && this.canvas.parentNode) {
                    this.canvas.parentNode.removeChild(this.canvas);
                }
                const overlay = document.getElementById('question-overlay');
                if (overlay) overlay.classList.remove('active');
            }
        }

        // MODULE 2: Signal
        class Module2 {
            init() {
                this.focusLevel = 0;
                this.focusDuration = 0;
                this.inBreakthrough = false;
                this.timeOffTarget = 0;
                this.lastSoundTime = 0;
                this.breakthroughs = 0;
                this.totalBreakthroughs = 2;

                const difficulty = App.tOC;
                this.signalSpeed = 1.2 + (difficulty / 100) * 1.5;
                this.trackingRadius = 0.20 - (difficulty / 100) * 0.12;
                this.requiredFocusDuration = 5 - (difficulty / 100) * 2;
                this.isActive = true;

                this.pointer = { x: 0, y: 0, isDown: false };
                this.onMove = (e) => {
                    const clientX = e.clientX || (e.touches && e.touches[0].clientX);
                    const clientY = e.clientY || (e.touches && e.touches[0].clientY);
                    this.pointer.x = (clientX / innerWidth) * 2 - 1;
                    this.pointer.y = -(clientY / innerHeight) * 2 + 1;
                };
                this.onDown = () => { 
                    this.pointer.isDown = true; 
                    if(this.isActive) Sound.start('module2', 'C4', 0.4);
                };
                this.onUp = () => { 
                    this.pointer.isDown = false; 
                    if(this.isActive) Sound.release('module2');
                };

                document.addEventListener('mousemove', this.onMove);
                document.addEventListener('touchmove', this.onMove, { passive: false });
                document.addEventListener('mousedown', this.onDown);
                document.addEventListener('touchstart', this.onDown, { passive: false });
                document.addEventListener('mouseup', this.onUp);
                document.addEventListener('touchend', this.onUp);

                this.material = new THREE.ShaderMaterial({
                    uniforms: {
                        u_time: { value: 0 },
                        u_focus_level: { value: 0.0 },
                        u_signal_speed: { value: this.signalSpeed },
                        u_breakthrough: { value: 0.0 },
                        u_focus_progress: { value: 0.0 }
                    },
                    vertexShader: `
                        varying vec2 vUv;
                        void main() {
                            vUv = uv;
                            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                        }
                    `,
                    fragmentShader: `
                        uniform float u_time;
                        uniform float u_focus_level;
                        uniform float u_signal_speed;
                        uniform float u_breakthrough;
                        uniform float u_focus_progress;
                        varying vec2 vUv;

                        float random (vec2 st) { return fract(sin(dot(st.xy, vec2(12.9898,78.233)))*43758.5453123); }
                        float noise (in vec2 st) { vec2 i = floor(st); vec2 f = fract(st); float a = random(i); float b = random(i + vec2(1.0, 0.0)); float c = random(i + vec2(0.0, 1.0)); float d = random(i + vec2(1.0, 1.0)); vec2 u = f*f*(3.0-2.0*f); return mix(a, b, u.x) + (c - a)* u.y * (1.0 - u.x) + (d - b) * u.x * u.y; }
                        float fbm (in vec2 st) { float value = 0.0; float amplitude = .5; for (int i = 0; i < 4; i++) { value += amplitude * noise(st); st *= 2.; amplitude *= .5; } return value; }

                        void main() {
                            vec2 st = vUv * vec2(0.8, 1.5) + vec2(0.0, -u_time * 0.05);
                            float fbm_val = fbm(st);
                            
                            vec3 color1 = vec3(0.5, 0.1, 0.2);
                            vec3 color2 = vec3(0.8, 0.3, 0.1);
                            vec3 color3 = vec3(0.9, 0.7, 0.5);
                            
                            vec3 nebula_color = mix(color1, color2, smoothstep(0.3, 0.6, fbm_val));
                            nebula_color = mix(nebula_color, color3, smoothstep(0.7, 0.9, fbm_val));

                            float signalY = sin(u_time * u_signal_speed) * 0.4 + 0.5;
                            float distToSignal = abs(vUv.y - signalY);
                            float signalClarity = 1.0 - smoothstep(0.0, 0.05, distToSignal);
                            float signal = sin(vUv.x * 80.0 + u_time * 10.0) * 0.5 + 0.5;
                            signal = smoothstep(0.7, 0.71, signal) * signalClarity;

                            float static_noise = random(vUv * 2.0 - u_time * 0.1);
                            vec3 noise_color = vec3(static_noise * 0.5);

                            vec3 final_color = mix(noise_color, nebula_color, smoothstep(0.1, 0.8, u_focus_level));
                            final_color += vec3(signal) * (0.4 + u_focus_level * 0.6);
                            
                            float breakthrough_wave = 1.0 - smoothstep(0.0, 0.8, abs(distance(vUv, vec2(0.5)) - u_breakthrough * 0.7));
                            vec3 breakthrough_color = nebula_color * 1.8 + breakthrough_wave;
                            final_color = mix(final_color, breakthrough_color, u_breakthrough);

                            gl_FragColor = vec4(final_color, 1.0);
                        }
                    `
                });
                this.screenMesh = new THREE.Mesh(new THREE.PlaneGeometry(16, 9), this.material);
                this.screenMesh.position.z = -1;
                Visual.scene.add(this.screenMesh);
            }

            update(stats, deltaTime) {
                if (!this.material || !this.material.uniforms) return;
                
                try {
                    this.material.uniforms.u_time.value = stats.time;

                    const signalY = Math.sin(stats.time * this.signalSpeed) * 0.4 + 0.5;
                    const pointerYNorm = this.pointer.y * 0.5 + 0.5;
                    const dist = Math.abs(pointerYNorm - signalY);
                    let isOnTarget = this.pointer.isDown && dist < this.trackingRadius;
                    
                    if (isOnTarget) {
                        this.focusLevel = Math.min(1.0, this.focusLevel + deltaTime * 0.4);
                    } else {
                        this.focusLevel = Math.max(0.0, this.focusLevel - deltaTime * 0.7);
                    }
                    this.material.uniforms.u_focus_level.value = this.focusLevel;

                    if (this.focusLevel > 0.95 && !this.inBreakthrough) {
                        this.focusDuration += deltaTime;
                        this.timeOffTarget = 0;
                    } else {
                        if (this.focusDuration > 0) {
                            this.timeOffTarget += deltaTime;
                            if (this.timeOffTarget > 0.5) { this.focusDuration = 0; }
                        }
                    }
                    this.material.uniforms.u_focus_progress.value = this.focusDuration / this.requiredFocusDuration;

                    if (this.focusDuration > this.requiredFocusDuration && !this.inBreakthrough) {
                        this.inBreakthrough = true;
                        this.breakthroughs++;
                        Sound.play('breakthrough');
                        setTimeout(() => {
                            this.inBreakthrough = false;
                            this.focusDuration = 0;
                        }, 2000);
                    }
                    
                    if (this.inBreakthrough) {
                        const breakthroughProgress = (this.focusDuration - this.requiredFocusDuration) / 2.0;
                        this.material.uniforms.u_breakthrough.value = Math.sin(Math.min(breakthroughProgress, 1.0) * Math.PI);
                    } else {
                        this.material.uniforms.u_breakthrough.value = Math.max(0.0, this.material.uniforms.u_breakthrough.value - deltaTime * 2);
                    }

                    if (isOnTarget && stats.time > this.lastSoundTime + 0.1 && Sound.synths.module2) {
                        Sound.synths.module2.frequency.rampTo(400 + Math.random() * 200, 0.2);
                        this.lastSoundTime = stats.time;
                    } else if (!isOnTarget && this.pointer.isDown && Sound.synths.module2) {
                        Sound.synths.module2.frequency.rampTo(200 + Math.random() * 100, 0.5);
                    }

                    stats.progress = Math.min(100, (this.breakthroughs / this.totalBreakthroughs) * 100);
                    stats.score = Math.round(stats.progress);

                    if (this.breakthroughs >= this.totalBreakthroughs) {
                        GameEngine.complete();
                    }
                } catch(e) {
                    console.error('Module2 update error:', e);
                }
            }

            cleanup() {
                this.isActive = false;
                Sound.release('module2');      
                
                document.removeEventListener('mousemove', this.onMove);
                document.removeEventListener('touchmove', this.onMove);
                document.removeEventListener('mousedown', this.onDown);
                document.removeEventListener('touchstart', this.onDown);
                document.removeEventListener('mouseup', this.onUp);
                document.removeEventListener('touchend', this.onUp);      
                
                if (Visual.scene && this.screenMesh) {
                    Visual.scene.remove(this.screenMesh);
                    if (this.screenMesh.geometry) this.screenMesh.geometry.dispose();
                    if (this.screenMesh.material) this.screenMesh.material.dispose();
                }      
                this.screenMesh = null;
                this.material = null;
            }
        }

    // MODULE 3: Pattern Recognition
class Module3 {
    validateDependencies() {
        let isValid = true;
        if (typeof App === 'undefined' || typeof App.tOC === 'undefined') {
            console.error("Module3 CRITICAL: 'App' or 'App.tOC' is not available.");
            isValid = false;
        }
        if (typeof Visual === 'undefined' || !Visual.scene || !Visual.camera) {
            console.error("Module3 CRITICAL: 'Visual', 'Visual.scene', or 'Visual.camera' is not available.");
            isValid = false;
        }
        this.countdownEl = document.getElementById('pattern-countdown');
        const questionOverlay = document.getElementById('question-overlay');
        if (!this.countdownEl || !questionOverlay) {
            console.error("Module3 CRITICAL: UI elements 'pattern-countdown' or 'question-overlay' not found in the DOM.");
            isValid = false;
        }
        return isValid;
    }

    init() {
        try {
            if (!this.validateDependencies()) {
                console.error("Module3 initialization aborted due to missing dependencies.");
                return;
            }

            const difficulty = App.tOC;
            this.group = new THREE.Group();
            this.phase = 'intro'; // Start with an intro phase
            this.introTime = 0;
            this.stabilityTime = 0;
            this.requiredStability = 3.5 - (difficulty / 100) * 1.5;
            this.roundsComplete = 0;
            this.totalRounds = 5;
            this.isHolding = false;
            this.touchCount = 0;
            this.lastSoundTime = 0;
            this.isActive = true;

            this.camera = Visual.camera;
            this.initialCameraPos = this.camera.position.clone();
            this.shakeIntensity = 0;

            const accentColor = new THREE.Color(0xc02625);

            const geom = new THREE.TorusKnotGeometry(2.0, 0.6, 128, 16);
            this.mat = new THREE.ShaderMaterial({
                transparent: true,
                uniforms: {
                    u_time: { value: 0 },
                    u_stability: { value: 0.0 },
                    u_color_unstable: { value: accentColor },
                    u_color_stable: { value: new THREE.Color(0xffffff) },
                    u_explosion: { value: 0.0 },
                    u_opacity: { value: 0.0 }
                },
                vertexShader: `
                    uniform float u_time;
                    uniform float u_stability;
                    uniform float u_explosion;
                    varying vec3 v_normal;
                    varying vec3 v_position;
                    
                    vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
                    vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
                    vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
                    vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }
                    float snoise(vec3 v) { 
                        const vec2 C = vec2(1.0/6.0, 1.0/3.0);
                        const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);
                        vec3 i = floor(v + dot(v, C.yyy));
                        vec3 x0 = v - i + dot(i, C.xxx);
                        vec3 g = step(x0.yzx, x0.xyz);
                        vec3 l = 1.0 - g;
                        vec3 i1 = min(g.xyz, l.zxy);
                        vec3 i2 = max(g.xyz, l.zxy);
                        vec3 x1 = x0 - i1 + C.xxx;
                        vec3 x2 = x0 - i2 + C.yyy;
                        vec3 x3 = x0 - D.yyy;
                        i = mod289(i);
                        vec4 p = permute(permute(permute(i.z + vec4(0.0, i1.z, i2.z, 1.0)) + i.y + vec4(0.0, i1.y, i2.y, 1.0)) + i.x + vec4(0.0, i1.x, i2.x, 1.0));
                        float n_ = 0.142857142857;
                        vec3 ns = n_ * D.wyz - D.xzx;
                        vec4 j = p - 49.0 * floor(p * ns.z * ns.z);
                        vec4 x_ = floor(j * ns.z);
                        vec4 y_ = floor(j - 7.0 * x_);
                        vec4 x = x_ * ns.x + ns.yyyy;
                        vec4 y = y_ * ns.x + ns.yyyy;
                        vec4 h = 1.0 - abs(x) - abs(y);
                        vec4 b0 = vec4(x.xy, y.xy);
                        vec4 b1 = vec4(x.zw, y.zw);
                        vec4 s0 = floor(b0)*2.0 + 1.0;
                        vec4 s1 = floor(b1)*2.0 + 1.0;
                        vec4 sh = -step(h, vec4(0.0));
                        vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;
                        vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;
                        vec3 p0 = vec3(a0.xy,h.x);
                        vec3 p1 = vec3(a0.zw,h.y);
                        vec3 p2 = vec3(a1.xy,h.z);
                        vec3 p3 = vec3(a1.zw,h.w);
                        vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));
                        p0 *= norm.x; p1 *= norm.y; p2 *= norm.z; p3 *= norm.w;
                        vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
                        m = m * m;
                        return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));
                    }

                    void main() {
                        v_normal = normal;
                        v_position = position;
                        float instability = 1.0 - u_stability;
                        float displacement = pow(instability, 2.0) * 0.3;
                        float noise_speed = u_time * 1.5;
                        float pulse = sin(u_time * 3.0) * 0.05 * instability;
                        vec3 newPosition = position + normal * (snoise(position * 3.0 + noise_speed) * displacement + pulse);
                        
                        float explosion_scale = pow(u_explosion, 1.5) * 1.5;
                        newPosition += normalize(position) * explosion_scale;
                        
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform float u_time;
                    uniform float u_stability;
                    uniform float u_explosion;
                    uniform vec3 u_color_unstable;
                    uniform vec3 u_color_stable;
                    uniform float u_opacity;
                    varying vec3 v_normal;
                    varying vec3 v_position;

                    vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
                    vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
                    vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
                    vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }
                    float snoise(vec3 v) { 
                        const vec2 C = vec2(1.0/6.0, 1.0/3.0);
                        const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);
                        vec3 i = floor(v + dot(v, C.yyy));
                        vec3 x0 = v - i + dot(i, C.xxx);
                        vec3 g = step(x0.yzx, x0.xyz);
                        vec3 l = 1.0 - g;
                        vec3 i1 = min(g.xyz, l.zxy);
                        vec3 i2 = max(g.xyz, l.zxy);
                        vec3 x1 = x0 - i1 + C.xxx;
                        vec3 x2 = x0 - i2 + C.yyy;
                        vec3 x3 = x0 - D.yyy;
                        i = mod289(i);
                        vec4 p = permute(permute(permute(i.z + vec4(0.0, i1.z, i2.z, 1.0)) + i.y + vec4(0.0, i1.y, i2.y, 1.0)) + i.x + vec4(0.0, i1.x, i2.x, 1.0));
                        float n_ = 0.142857142857;
                        vec3 ns = n_ * D.wyz - D.xzx;
                        vec4 j = p - 49.0 * floor(p * ns.z * ns.z);
                        vec4 x_ = floor(j * ns.z);
                        vec4 y_ = floor(j - 7.0 * x_);
                        vec4 x = x_ * ns.x + ns.yyyy;
                        vec4 y = y_ * ns.x + ns.yyyy;
                        vec4 h = 1.0 - abs(x) - abs(y);
                        vec4 b0 = vec4(x.xy, y.xy);
                        vec4 b1 = vec4(x.zw, y.zw);
                        vec4 s0 = floor(b0)*2.0 + 1.0;
                        vec4 s1 = floor(b1)*2.0 + 1.0;
                        vec4 sh = -step(h, vec4(0.0));
                        vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;
                        vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;
                        vec3 p0 = vec3(a0.xy,h.x);
                        vec3 p1 = vec3(a0.zw,h.y);
                        vec3 p2 = vec3(a1.xy,h.z);
                        vec3 p3 = vec3(a1.zw,h.w);
                        vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));
                        p0 *= norm.x; p1 *= norm.y; p2 *= norm.z; p3 *= norm.w;
                        vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
                        m = m * m;
                        return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));
                    }

                    void main() {
                        vec3 viewDir = normalize(cameraPosition - v_position);
                        float fresnel = 1.0 - dot(normalize(v_normal), viewDir);
                        fresnel = pow(fresnel, 2.0);
                        
                        vec3 final_color = mix(u_color_unstable, u_color_stable, u_stability);
                        
                        float stableGlowAmount = pow(u_stability, 4.0);
                        vec3 glow_color = mix(u_color_unstable, vec3(1.0, 1.0, 1.0), 0.5);
                        final_color += fresnel * glow_color * stableGlowAmount * 2.5;
                        
                        float energyFlow = snoise(v_position * 2.5 + vec3(u_time * 0.8, 0.0, 0.0));
                        energyFlow = pow(abs(energyFlow), 4.0);
                        final_color += u_color_unstable * energyFlow * (1.0 - u_stability) * 0.6;

                        vec3 explosion_base_color = vec3(1.0, 0.8, 0.6) * u_explosion * 3.0;
                        vec3 explosion_core_color = vec3(1.0, 1.0, 1.0) * pow(u_explosion, 2.0) * 1.5;
                        vec3 explosion_color = mix(explosion_base_color, explosion_core_color, u_explosion);
                        final_color = mix(final_color, explosion_color, pow(u_explosion, 0.7));

                        gl_FragColor = vec4(final_color, (1.0 - u_explosion * 0.3) * u_opacity);
                    }
                `
            });
            this.core = new THREE.Mesh(geom, this.mat);
            this.group.add(this.core);

            const light1 = new THREE.PointLight(0xffffff, 2.0, 100);
            light1.position.set(5, 5, 5);
            this.group.add(light1);
            const light2 = new THREE.PointLight(0xff5555, 1.5, 100);
            light2.position.set(-5, -5, 5);
            this.group.add(light2);
            this.group.add(new THREE.AmbientLight(0xffffff, 0.8));

            this.group.position.z = 0;
            this.group.visible = false; // Start invisible
            Visual.scene.add(this.group);
            console.log('Module3: Group added to scene');

            this.questionBank = [
                { q_en: "Which doesn't belong: Rose, Tulip, Oak, Daisy?", q_zh: "哪个不属于:玫瑰、郁金香、橡树、雏菊?", a_en: ["Rose", "Tulip", "Oak", "Daisy"], a_zh: ["玫瑰", "郁金香", "橡树", "雏菊"], correct: 2 },
                { q_en: "Odd one out: Apple, Orange, Carrot, Banana?", q_zh: "哪个不同:苹果、橙子、胡萝卜、香蕉?", a_en: ["Apple", "Orange", "Carrot", "Banana"], a_zh: ["苹果", "橙子", "胡萝卜", "香蕉"], correct: 2 },
                { q_en: "Which is not a mammal: Dolphin, Shark, Whale, Seal?", q_zh: "哪个不是哺乳动物:海豚、鲨鱼、鲸鱼、海豹?", a_en: ["Dolphin", "Shark", "Whale", "Seal"], a_zh: ["海豚", "鲨鱼", "鲸鱼", "海豹"], correct: 1 },
                { q_en: "Which is a reptile: Frog, Lizard, Salamander, Toad?", q_zh: "哪个是爬行动物:青蛙、蜥蜴、蝾螈、蟾蜍?", a_en: ["Frog", "Lizard", "Salamander", "Toad"], a_zh: ["青蛙", "蜥蜴", "蝾螈", "蟾蜍"], correct: 1 },
                { q_en: "Odd tool: Hammer, Screwdriver, Wrench, Pencil?", q_zh: "奇怪的工具:锤子、螺丝刀、扳手、铅笔?", a_en: ["Hammer", "Screwdriver", "Wrench", "Pencil"], a_zh: ["锤子", "螺丝刀", "扳手", "铅笔"], correct: 3 },
                { q_en: "Which is not a color: Red, Loud, Blue, Green?", q_zh: "哪个不是颜色:红色、响亮、蓝色、绿色?", a_en: ["Red", "Loud", "Blue", "Green"], a_zh: ["红色", "响亮", "蓝色", "绿色"], correct: 1 },
                { q_en: "Odd one: Circle, Square, Triangle, Book?", q_zh: "哪个不同:圆形、正方形、三角形、书?", a_en: ["Circle", "Square", "Triangle", "Book"], a_zh: ["圆形", "正方形", "三角形", "书"], correct: 3 },
                { q_en: "Which is not a beverage: Water, Coffee, Sandwich, Tea?", q_zh: "哪个不是饮料:水、咖啡、三明治、茶?", a_en: ["Water", "Coffee", "Sandwich", "Tea"], a_zh: ["水", "咖啡", "三明治", "茶"], correct: 2 },
            ];

            this.selectedQuestions = this.shuffleArray([...this.questionBank]).slice(0, 5);
            this.timeLimit = 10 - (difficulty / 100) * 5;
            this.questionStartTime = 0;

            this.onDown = (e) => {
                if (this.phase !== 'stabilize') return;
                const isTouch = e.type === 'touchstart';
                if (isTouch) {
                    this.touchCount = e.touches.length;
                    if (e.touches.length >= 2) {
                        this.isHolding = true;
                        if (!this.stabilityTime && this.isActive) Sound.start('module3_unstable', 'C1', 0.1);
                        e.preventDefault();
                    }
                } else {
                    this.isHolding = true;
                    if (!this.stabilityTime && this.isActive) Sound.start('module3_unstable', 'C1', 0.1);
                }
            };
            this.onUp = (e) => {
                const isTouch = e.type === 'touchend' || e.type === 'touchcancel';
                if (isTouch) {
                    const remainingTouches = e.touches ? e.touches.length : 0;
                    if (remainingTouches < 2) {
                        this.isHolding = false;
                        this.touchCount = remainingTouches;
                        if (this.isActive) Sound.release('module3_unstable');
                    }
                } else {
                    this.isHolding = false;
                    if (this.isActive) Sound.release('module3_unstable');
                }
            };
            this.onTouchChange = (e) => {
                if (this.phase !== 'stabilize') return;
                if (e.type === 'touchmove' && e.touches.length >= 2) {
                    if (!this.isHolding) {
                        this.isHolding = true;
                        if (!this.stabilityTime && this.isActive) Sound.start('module3_unstable', 'C1', 0.1);
                    }
                    e.preventDefault();
                }
            };

            document.addEventListener('mousedown', this.onDown);
            document.addEventListener('mouseup', this.onUp);
            document.addEventListener('touchstart', this.onDown, { passive: false });
            document.addEventListener('touchend', this.onUp);
            document.addEventListener('touchcancel', this.onUp);
            document.addEventListener('touchmove', this.onTouchChange, { passive: false });

            console.log('Module3 initialized successfully');
        } catch (e) {
            console.error("A CRITICAL ERROR occurred during Module3 init:", e);
            this.isActive = false; // Stop the module from running
        }
    }

    shuffleArray(array) {
        const shuffled = [...array];
        for (let i = shuffled.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
        }
        return shuffled;
    }

    showQuestion() {
        if (!this.isActive) return;
        if (this.roundsComplete >= this.totalRounds) {
            setTimeout(() => GameEngine.complete(), 500);
            return;
        }
        const q = this.selectedQuestions[this.roundsComplete];
        const overlay = document.getElementById('question-overlay');
        const lang = I18N.lang;
        document.getElementById('question-text').textContent = q[`q_${lang}`];
        const optionsDiv = document.getElementById('answer-options');
        optionsDiv.innerHTML = '';
        const answers = q[`a_${lang}`];
        answers.forEach((ans, idx) => {
            const btn = document.createElement('button');
            btn.className = 'answer-option';
            btn.textContent = ans;
            btn.addEventListener('click', () => {
                if (idx === q.correct) {
                    Sound.play('success');
                    Haptic.success();
                    GameEngine.stats.score += 20;
                    this.roundsComplete++;
                    overlay.classList.remove('active');
                    this.countdownEl.classList.remove('active');
                    if (this.roundsComplete >= this.totalRounds) {
                        setTimeout(() => GameEngine.complete(), 500);
                    } else {
                        this.phase = 'stabilize';
                        this.stabilityTime = 0;
                        this.mat.uniforms.u_explosion.value = 0;
                    }
                } else {
                    Sound.play('click', 'C2', 0.5);
                    Haptic.error();
                    GameEngine.stats.errors++;
                    GameEngine.stats.score = Math.max(0, GameEngine.stats.score - 15);
                }
            });
            optionsDiv.appendChild(btn);
        });
        overlay.classList.add('active');
        this.countdownEl.classList.add('active');
        this.questionStartTime = Date.now();
    }
    
    updateIntroPhase(deltaTime) {
        this.group.visible = true;
        this.introTime += deltaTime;
        const introDuration = 1.5;
        this.mat.uniforms.u_opacity.value = Math.min(1.0, this.introTime / introDuration);
        if (this.introTime >= introDuration) {
            this.phase = 'stabilize';
            console.log("Module3: Intro complete. Starting interaction.");
        }
    }

    updateStabilizePhase(stats, deltaTime) {
        this.mat.uniforms.u_explosion.value = Math.max(0, this.mat.uniforms.u_explosion.value - deltaTime * 2);
        if (this.isHolding) {
            this.stabilityTime = Math.min(this.requiredStability, this.stabilityTime + deltaTime * 1.2);
            this.shakeIntensity = Math.max(0, this.shakeIntensity - deltaTime * 0.8);
            if (stats.time > this.lastSoundTime + 0.15 && Sound.synths.module3_unstable) {
                Sound.synths.module3_unstable.frequency.rampTo(100 + this.stabilityTime * 60, 0.2);
                this.lastSoundTime = stats.time;
            }
        } else {
            this.stabilityTime = Math.max(0, this.stabilityTime - deltaTime * 2.5);
            this.shakeIntensity = Math.min(0.15, this.shakeIntensity + deltaTime * 0.2);
            if (Sound.synths.module3_unstable) {
                Sound.synths.module3_unstable.frequency.rampTo(80, 0.5);
            }
        }
        if (this.stabilityTime >= this.requiredStability) {
            this.phase = 'answer';
            Sound.release('module3_unstable');
            Sound.play('module3_hit', 'G4', 0.9);
            this.mat.uniforms.u_explosion.value = 1;
            setTimeout(() => this.showQuestion(), 400);
        }
    }

    updateAnswerPhase(stats, deltaTime) {
        const elapsed = (Date.now() - this.questionStartTime) / 1000;
        const remaining = Math.max(0, this.timeLimit - elapsed);
        if (this.countdownEl) {
            this.countdownEl.textContent = Math.ceil(remaining);
        }
        this.mat.uniforms.u_explosion.value = Math.max(0, this.mat.uniforms.u_explosion.value - deltaTime * 1.2);
        this.shakeIntensity = Math.max(0, this.shakeIntensity - deltaTime * 0.8);
        if (elapsed > this.timeLimit) {
            GameEngine.stats.errors++;
            GameEngine.stats.score = Math.max(0, GameEngine.stats.score - 20);
            const overlay = document.getElementById('question-overlay');
            if (overlay) overlay.classList.remove('active');
            if (this.countdownEl) this.countdownEl.classList.remove('active');
            this.phase = 'stabilize';
            this.stabilityTime = 0;
            this.roundsComplete++;
            if (this.roundsComplete >= this.totalRounds) {
                setTimeout(() => GameEngine.complete(), 500);
            }
        }
    }

    update(stats, deltaTime) {
        if (!this.isActive || !this.mat || !this.mat.uniforms) return;
        try {
            if (this.phase === 'intro') {
                this.updateIntroPhase(deltaTime);
            } else if (this.phase === 'stabilize') {
                this.updateStabilizePhase(stats, deltaTime);
            } else if (this.phase === 'answer') {
                this.updateAnswerPhase(stats, deltaTime);
            }
            this.mat.uniforms.u_time.value = stats.time;
            this.mat.uniforms.u_stability.value = this.stabilityTime / this.requiredStability;
            if (this.core) {
                const instabilityFactor = (1 - this.mat.uniforms.u_stability.value);
                this.core.rotation.y += (0.3 + instabilityFactor * 0.5) * deltaTime;
                this.core.rotation.x += (0.15 + instabilityFactor * 0.3) * deltaTime;
                this.core.rotation.z += (0.1 * instabilityFactor) * deltaTime;
            }
            if (this.camera && this.initialCameraPos) {
                if (this.shakeIntensity > 0.01) {
                    const shake = new THREE.Vector3(
                        (Math.random() - 0.5) * this.shakeIntensity,
                        (Math.random() - 0.5) * this.shakeIntensity,
                        (Math.random() - 0.5) * this.shakeIntensity
                    );
                    this.camera.position.copy(this.initialCameraPos).add(shake);
                } else {
                    this.camera.position.lerp(this.initialCameraPos, 0.1);
                }
            }
            stats.progress = (this.roundsComplete / this.totalRounds) * 100;
        } catch (e) {
            console.error('Module3 update error:', e);
            this.isActive = false; // Stop on update error
        }
    }

    cleanup() {
        this.isActive = false;
        document.removeEventListener('mousedown', this.onDown);
        document.removeEventListener('mouseup', this.onUp);
        document.removeEventListener('touchstart', this.onDown);
        document.removeEventListener('touchend', this.onUp);
        document.removeEventListener('touchcancel', this.onUp);
        document.removeEventListener('touchmove', this.onTouchChange);
        if (this.camera && this.initialCameraPos) {
            this.camera.position.copy(this.initialCameraPos);
        }
        if (Visual.scene && this.group) {
            Visual.scene.remove(this.group);
        }
        if (this.core) {
            if (this.core.geometry) this.core.geometry.dispose();
            if (this.mat) this.mat.dispose();
        }
        const questionOverlay = document.getElementById('question-overlay');
        if (questionOverlay) questionOverlay.classList.remove('active');
        if (this.countdownEl) this.countdownEl.classList.remove('active');
        console.log("Module3 cleaned up.");
    }
}
        
        // MODULE 4: Wave Match
        class Module4 {
            init() {
                this.isActive = true;
                this.canvas = document.getElementById('mod4-canvas');
                this.canvas.style.display = 'block';
                
                const size = Math.min(window.innerWidth * 0.9, window.innerHeight * 0.8, 700);
                this.canvas.width = size;
                this.canvas.height = size * 0.6;
                this.ctx = this.canvas.getContext('2d');
                
                const difficulty = App.tOC;
                this.currentStage = 0;
                this.totalStages = 3 + Math.floor(difficulty / 30);
                
                this.userFreq = 1.0;
                this.userAmp = 0.5;
                
                this.targetWaves = [];
                for (let i = 0; i < this.totalStages; i++) {
                    this.targetWaves.push({
                        freq: 0.5 + Math.random() * 2,
                        amp: 0.3 + Math.random() * 0.5
                    });
                }
                
                this.createControls();
            }
            
            createControls() {
                const controlDiv = document.createElement('div');
                controlDiv.style.cssText = 'position: absolute; bottom: 8rem; left: 50%; transform: translateX(-50%); background: rgba(255,255,255,0.95); padding: 1.5rem; border: 2px solid #c02625; width: 90%; max-width: 600px;';
                
                const freqLabel = document.createElement('div');
                freqLabel.textContent = 'Frequency: 1.0';
                freqLabel.style.cssText = 'margin-bottom: 0.5rem; font-size: 0.9rem;';
                controlDiv.appendChild(freqLabel);
                
                const freqSlider = document.createElement('input');
                freqSlider.type = 'range';
                freqSlider.min = '0.1';
                freqSlider.max = '3';
                freqSlider.step = '0.1';
                freqSlider.value = '1.0';
                freqSlider.style.cssText = 'width: 100%; margin-bottom: 1rem;';
                freqSlider.addEventListener('input', (e) => {
                    this.userFreq = parseFloat(e.target.value);
                    freqLabel.textContent = `Frequency: ${this.userFreq.toFixed(1)}`;
                });
                controlDiv.appendChild(freqSlider);
                
                const ampLabel = document.createElement('div');
                ampLabel.textContent = 'Amplitude: 0.5';
                ampLabel.style.cssText = 'margin-bottom: 0.5rem; font-size: 0.9rem;';
                controlDiv.appendChild(ampLabel);
                
                const ampSlider = document.createElement('input');
                ampSlider.type = 'range';
                ampSlider.min = '0.1';
                ampSlider.max = '1';
                ampSlider.step = '0.1';
                ampSlider.value = '0.5';
                ampSlider.style.cssText = 'width: 100%; margin-bottom: 1rem;';
                ampSlider.addEventListener('input', (e) => {
                    this.userAmp = parseFloat(e.target.value);
                    ampLabel.textContent = `Amplitude: ${this.userAmp.toFixed(1)}`;
                });
                controlDiv.appendChild(ampSlider);
                
                const matchBtn = document.createElement('button');
                matchBtn.className = 'btn accent';
                matchBtn.textContent = 'CHECK MATCH';
                matchBtn.style.cssText = 'width: 100%;';
                matchBtn.addEventListener('click', () => this.checkMatch());
                controlDiv.appendChild(matchBtn);
                
                this.controlDiv = controlDiv;
                document.getElementById('game-screen').appendChild(controlDiv);
            }
            
            checkMatch() {
                const target = this.targetWaves[this.currentStage];
                const freqDiff = Math.abs(this.userFreq - target.freq);
                const ampDiff = Math.abs(this.userAmp - target.amp);
                
                if (freqDiff < 0.3 && ampDiff < 0.2) {
                    Sound.play('success');
                    Haptic.success();
                    GameEngine.stats.score += 20;
                    this.currentStage++;
                    
                    if (this.currentStage >= this.totalStages) {
                        GameEngine.complete();
                    }
                } else {
                    Sound.play('click', 'C2', 0.5);
                    Haptic.error();
                    GameEngine.stats.errors++;
                }
            }
            
            update(stats, deltaTime) {
                if (!this.isActive) return;
                
                const ctx = this.ctx;
                const w = this.canvas.width;
                const h = this.canvas.height;
                
                ctx.fillStyle = '#1a1a1a';
                ctx.fillRect(0, 0, w, h);
                
                const target = this.targetWaves[this.currentStage];
                
                ctx.strokeStyle = '#00ff00';
                ctx.lineWidth = 3;
                ctx.beginPath();
                for (let x = 0; x < w; x++) {
                    const t = (x / w) * Math.PI * 4;
                    const y = h / 3 + Math.sin(t * target.freq + stats.time) * target.amp * h / 4;
                    if (x === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.stroke();
                
                ctx.strokeStyle = '#ff0000';
                ctx.lineWidth = 3;
                ctx.beginPath();
                for (let x = 0; x < w; x++) {
                    const t = (x / w) * Math.PI * 4;
                    const y = h * 2/3 + Math.sin(t * this.userFreq + stats.time) * this.userAmp * h / 4;
                    if (x === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.stroke();
                
                ctx.fillStyle = '#00ff00';
                ctx.font = '14px Inter';
                ctx.fillText('TARGET', 10, 30);
                
                ctx.fillStyle = '#ff0000';
                ctx.fillText('YOUR WAVE', 10, h - 10);
                
                stats.progress = (this.currentStage / this.totalStages) * 100;
            }
            
            cleanup() {
                this.isActive = false;
                if (this.canvas) this.canvas.style.display = 'none';
                if (this.controlDiv && this.controlDiv.parentNode) {
                    this.controlDiv.parentNode.removeChild(this.controlDiv);
                }
            }
        }

        // MODULE 5: Reflex
        class Module5 {
            init() {
                this.canvasEl = document.getElementById('reflex-canvas');
                this.ctx = this.canvasEl.getContext('2d');
                this.canvasEl.style.display = 'block';
                this.isGameActive = true;

                this.setCanvasSize();
                this.resizeHandler = PerformanceUtils.throttle(() => this.setCanvasSize(), 250);
                window.addEventListener('resize', this.resizeHandler);

                this.dots = [];
                this.numDots = 9;
                this.targetDotIndex = -1;
                this.state = 'countdown';
                this.countdownTimer = 3;
                this.trialCount = 0;
                this.maxTrials = 15;
                this.reactionTimes = [];
                
                this.drawInitialDots();
                this.startCountdown();

                this.onClick = this.handleClick.bind(this);
                this.canvasEl.addEventListener('mousedown', this.onClick);
                this.canvasEl.addEventListener('touchstart', this.onClick);
            }

            setCanvasSize() {
                if (!this.canvasEl) return;
                // Ensure canvas fits on screen with safe margins
                const maxWidth = window.innerWidth * 0.85;
                const maxHeight = window.innerHeight * 0.75;
                const size = Math.min(maxWidth, maxHeight, 600);
                
                this.canvasEl.width = size;
                this.canvasEl.height = size;
                this.drawInitialDots();
                this.drawBackground();
            }

            drawInitialDots() {
                this.dots = [];
                const w = this.canvasEl.width;
                const h = this.canvasEl.height;
                
                // Ensure dots fit comfortably on screen with proper padding
                const padding = w * 0.18; // Increased from 0.15 to 0.18
                const gridW = (w - padding * 2) / 2;
                const gridH = (h - padding * 2) / 2;
                
                // Calculate dot radius ensuring they don't overlap and are visible
                const minSpacing = Math.min(gridW, gridH);
                const maxDotRadius = minSpacing * 0.35; // Limit to 35% of spacing
                const dotRadius = Math.min(w * 0.055, maxDotRadius); // Reduced from 0.06
                
                for (let i = 0; i < 3; i++) {
                    for (let j = 0; j < 3; j++) {
                        this.dots.push({ 
                            x: padding + j * gridW, 
                            y: padding + i * gridH, 
                            r: dotRadius, 
                            state: 'hidden',
                            index: i * 3 + j 
                        });
                    }
                }
            }

            startCountdown() {
                this.state = 'countdown';
                this.dots.forEach(d => d.state = 'hidden');
                Sound.play('reflex_start');
                
                this.countdownInterval = setInterval(() => { 
                    if (!this.isGameActive) {
                        clearInterval(this.countdownInterval);
                        return;
                    }
                    this.countdownTimer--;
                    if (this.countdownTimer <= 0) {
                        clearInterval(this.countdownInterval);
                        this.countdownInterval = null;
                        this.startTrial();
                    } else {
                        Sound.play('reflex_cue', 'C2');
                    }
                }, 1000);
            }

            startTrial() {
                if (!this.isGameActive) return;

                this.trialCount++;
                if (this.trialCount > this.maxTrials) {
                    this.calculateResults();
                    GameEngine.complete();
                    return;
                }
                
                this.state = 'wait';
                const delay = Math.random() * 2000 + 1000;
                this.cueTimeout = setTimeout(() => this.cueTarget(), delay); 
            }

            cueTarget() {
                if (!this.isGameActive) return;

                this.state = 'cue';
                this.cueTime = performance.now();
                
                const isTarget = Math.random() > 0.3;
                this.targetDotIndex = Math.floor(Math.random() * this.numDots);
                this.dots[this.targetDotIndex].state = isTarget ? 'black' : 'red';
                this.isCurrentTarget = isTarget;
                
                Sound.play('reflex_cue', 'A5');

                this.missTimeout = setTimeout(() => { 
                    if (this.isGameActive && this.state === 'cue') {
                        if (this.isCurrentTarget) {
                            this.handleMiss();
                        } else {
                            this.handleCorrectAvoid();
                        }
                    }
                }, 1000); 
            }

            handleClick(e) {
                if (this.state !== 'cue') return;

                clearTimeout(this.missTimeout);
                this.missTimeout = null;

                const rect = this.canvasEl.getBoundingClientRect();
                const clickX = (e.clientX || e.touches[0].clientX) - rect.left;
                const clickY = (e.clientY || e.touches[0].clientY) - rect.top;

                let clickedDot = null;
                this.dots.forEach(dot => {
                    const dist = Math.sqrt((clickX - dot.x)**2 + (clickY - dot.y)**2);
                    if (dist < dot.r * 1.5) clickedDot = dot;
                });
                
                if (clickedDot && clickedDot.index === this.targetDotIndex) {
                    if (this.isCurrentTarget) {
                        const reactionTime = performance.now() - this.cueTime;
                        this.reactionTimes.push(reactionTime);
                        this.handleHit(reactionTime);
                    } else {
                        this.handleWrongClick();
                    }
                } else {
                    this.handleWrongClick();
                }
            }

            handleHit(reactionTime) {
                this.state = 'click';
                this.dots[this.targetDotIndex].state = 'green';
                Sound.play('reflex_hit', 'G6');
                Haptic.light();
                GameEngine.stats.score += 10;
                
                setTimeout(() => {
                    this.dots[this.targetDotIndex].state = 'hidden';
                    this.startTrial();
                }, 300);
            }

            handleMiss() {
                this.state = 'click';
                GameEngine.stats.errors++;
                GameEngine.stats.score = Math.max(0, GameEngine.stats.score - 5);
                Sound.play('reflex_miss', 'C2', 0.8);
                Haptic.medium();
                this.dots[this.targetDotIndex].state = 'gray'; 
                
                setTimeout(() => {
                    this.dots[this.targetDotIndex].state = 'hidden';
                    this.startTrial();
                }, 300);
            }
            
            handleCorrectAvoid() {
                this.state = 'click';
                this.dots[this.targetDotIndex].state = 'hidden';
                GameEngine.stats.score += 5;
                Haptic.light();
                setTimeout(() => this.startTrial(), 300);
            }
            
            handleWrongClick() {
                GameEngine.stats.errors++;
                GameEngine.stats.score = Math.max(0, GameEngine.stats.score - 10);
                Sound.play('reflex_miss', 'C1', 0.5);
                Haptic.heavy();
                
                this.state = 'click';
                setTimeout(() => {
                    this.dots[this.targetDotIndex].state = 'hidden';
                    this.startTrial();
                }, 300);
            }

            calculateResults() {
                const totalTime = this.reactionTimes.reduce((sum, rt) => sum + rt, 0);
                const avgTime = this.reactionTimes.length > 0 ? totalTime / this.reactionTimes.length : 500;
                GameEngine.stats.score = Math.round(avgTime);
            }

            drawBackground() {
                const ctx = this.ctx;
                const w = this.canvasEl.width;
                const h = this.canvasEl.height;

                // Transparent background with subtle gradient
                ctx.clearRect(0, 0, w, h);
                const gradient = ctx.createRadialGradient(w/2, h/2, 0, w/2, h/2, w/2);
                gradient.addColorStop(0, 'rgba(245, 245, 240, 0.1)');
                gradient.addColorStop(1, 'rgba(192, 38, 37, 0.05)');
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, w, h);
                
                this.dots.forEach(dot => {
                    if (dot.state === 'hidden') {
                        ctx.strokeStyle = 'rgba(192, 38, 37, 0.3)';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.arc(dot.x, dot.y, dot.r, 0, Math.PI * 2);
                        ctx.stroke();
                    } else {
                        let color = '#2a2a2a';
                        if (dot.state === 'black') color = '#2a2a2a';
                        if (dot.state === 'red') color = '#dd0000'; 
                        if (dot.state === 'green') color = '#00cc00'; 
                        if (dot.state === 'gray') color = '#888888';

                        ctx.fillStyle = color;
                        ctx.beginPath();
                        ctx.arc(dot.x, dot.y, dot.r, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Add glow effect for active dots
                        ctx.shadowBlur = 20;
                        ctx.shadowColor = color;
                        ctx.fill();
                        ctx.shadowBlur = 0;
                    }
                });
                
                if (this.state === 'countdown') {
                    const countEl = document.getElementById('game-countdown');
                    countEl.textContent = this.countdownTimer;
                    countEl.style.opacity = 1;
                } else {
                    document.getElementById('game-countdown').style.opacity = 0;
                }
            }

            update(stats, deltaTime) {
                this.drawBackground();
                stats.progress = Math.min(100, (this.trialCount / this.maxTrials) * 100);
            }

            cleanup() { 
                this.isGameActive = false;      
                
                if (this.countdownInterval) {
                    clearInterval(this.countdownInterval);
                    this.countdownInterval = null;
                }
                if (this.cueTimeout) {
                    clearTimeout(this.cueTimeout);
                    this.cueTimeout = null;
                }
                if (this.missTimeout) {
                    clearTimeout(this.missTimeout);
                    this.missTimeout = null;
                }

                if (this.resizeHandler) {
                    window.removeEventListener('resize', this.resizeHandler);
                }
                if (this.canvasEl && this.onClick) {
                    this.canvasEl.removeEventListener('mousedown', this.onClick);
                    this.canvasEl.removeEventListener('touchstart', this.onClick);
                }      
                if (this.canvasEl) {
                    this.canvasEl.style.display = 'none';
                }      
                const countdownEl = document.getElementById('game-countdown');
                if (countdownEl) countdownEl.style.opacity = 0;
            }
        }
        
        // MODULE 6: Flow 
        class Module6 {
            init() {
                this.group = new THREE.Group();
                
                this.inhaleDuration = 4;
                this.holdDuration = 7;
                this.exhaleDuration = 8;
                this.cycleDuration = this.inhaleDuration + this.holdDuration + this.exhaleDuration;
                
                this.totalPresenceTime = 0;
                this.requiredTime = 60;
                this.isHolding = false;
                this.isActive = true;
                
                this.particles = [];
                this.numParticles = 3000;
                
                const geom = new THREE.BufferGeometry();
                const positions = new Float32Array(this.numParticles * 3);
                const colors = new Float32Array(this.numParticles * 3);
                const velocities = new Float32Array(this.numParticles * 3);
                const phases = new Float32Array(this.numParticles);
                
                const palette = [
                    { r: 232/255, g: 74/255, b: 95/255 },
                    { r: 255/255, g: 122/255, b: 92/255 },
                    { r: 255/255, g: 193/255, b: 182/255 }
                ];
                
                for (let i = 0; i < this.numParticles; i++) {
                    positions[i*3] = (Math.random() - 0.5) * 15;
                    positions[i*3+1] = (Math.random() - 0.5) * 15;
                    positions[i*3+2] = (Math.random() - 0.5) * 8;
                    
                    velocities[i*3] = 0;
                    velocities[i*3+1] = 0;
                    velocities[i*3+2] = 0;
                    
                    phases[i] = Math.random() * Math.PI * 2;
                    
                    const colorChoice = palette[Math.floor(Math.random() * palette.length)];
                    colors[i*3] = colorChoice.r;
                    colors[i*3+1] = colorChoice.g;
                    colors[i*3+2] = colorChoice.b;
                }
                
                geom.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                geom.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                geom.setAttribute('velocity', new THREE.BufferAttribute(velocities, 3));
                geom.setAttribute('phase', new THREE.BufferAttribute(phases, 1));
                
                this.mat = new THREE.PointsMaterial({
                    size: 0.15,
                    vertexColors: true,
                    transparent: true,
                    opacity: 0.8,
                    blending: THREE.AdditiveBlending
                });
                
                this.vortexParticles = new THREE.Points(geom, this.mat);
                this.group.add(this.vortexParticles);
                
                this.group.add(new THREE.AmbientLight(0xffffff, 0.5));
                const pointLight = new THREE.PointLight(0xff7a5c, 1.5, 100);
                pointLight.position.set(5, 5, 5);
                this.group.add(pointLight);
                
                Visual.scene.add(this.group);
                
                this.quoteEl = document.getElementById('game-intro-text');
                this.quoteEl.style.top = '75%';
                this.quoteEl.style.color = '#E84A5F';
                this.quoteEl.style.textShadow = '0 0 20px rgba(232, 74, 95, 0.5)';

                this.onDown = () => { this.isHolding = true; };
                this.onUp = () => { this.isHolding = false; };
                
                document.addEventListener('mousedown', this.onDown);
                document.addEventListener('mouseup', this.onUp);
                document.addEventListener('touchstart', this.onDown);
                document.addEventListener('touchend', this.onUp);
            }
            
            update(stats, deltaTime) {
                if (!this.isActive || !this.vortexParticles || !this.vortexParticles.geometry) return;

                try {
                    const elapsedInCycle = stats.time % this.cycleDuration;
                    
                    let breathPhase, targetScale;
                    
                    if (elapsedInCycle < this.inhaleDuration) {
                        breathPhase = 'inhale';
                        targetScale = 1.0 - (elapsedInCycle / this.inhaleDuration) * 0.5;
                        if (this.quoteEl) {
                            this.quoteEl.textContent = I18N.lang === 'en' ? 'INHALE (4s)' : '吸气 (4秒)';
                        }
                    } else if (elapsedInCycle < this.inhaleDuration + this.holdDuration) {
                        breathPhase = 'hold';
                        targetScale = 0.5; 
                        if (this.quoteEl) {
                            this.quoteEl.textContent = I18N.lang === 'en' ? 'HOLD (7s)' : '屏息 (7秒)';
                        }
                    } else {
                        breathPhase = 'exhale';
                        const exhaleTime = elapsedInCycle - (this.inhaleDuration + this.holdDuration); 
                        targetScale = 0.5 + (exhaleTime / this.exhaleDuration) * 0.5;
                        if (this.quoteEl) {
                            this.quoteEl.textContent = I18N.lang === 'en' ? 'EXHALE (8s)' : '呼气 (8秒)';
                        }
                    }
                    
                    const positions = this.vortexParticles.geometry.attributes.position.array;
                    const velocities = this.vortexParticles.geometry.attributes.velocity.array;
                    const phases = this.vortexParticles.geometry.attributes.phase.array;
                    
                    const breathForce = breathPhase === 'inhale' ? -0.003 : (breathPhase === 'exhale' ? 0.003 : 0);
                    
                    for (let i = 0; i < this.numParticles; i++) {
                        const i3 = i * 3;
                        
                        const x = positions[i3];
                        const y = positions[i3+1];
                        const z = positions[i3+2];
                        
                        const dist = Math.sqrt(x*x + y*y);
                        
                        const angle = Math.atan2(y, x);
                        const vortexStrength = 0.015 * Math.sin(stats.time * 1.5 + phases[i]);
                        const tangentialForce = vortexStrength / (dist + 0.1);
                        
                        velocities[i3] += (-Math.sin(angle) * tangentialForce + breathForce * x * 0.15);
                        velocities[i3+1] += (Math.cos(angle) * tangentialForce + breathForce * y * 0.15);
                        velocities[i3+2] += Math.sin(stats.time * 0.8 + phases[i]) * 0.002;
                        
                        velocities[i3] *= 0.97;
                        velocities[i3+1] *= 0.97;
                        velocities[i3+2] *= 0.97;
                        
                        positions[i3] += velocities[i3];
                        positions[i3+1] += velocities[i3+1];
                        positions[i3+2] += velocities[i3+2];
                        
                        if (Math.abs(positions[i3]) > 12) positions[i3] = -Math.sign(positions[i3]) * 12;
                        if (Math.abs(positions[i3+1]) > 12) positions[i3+1] = -Math.sign(positions[i3+1]) * 12;
                        if (Math.abs(positions[i3+2]) > 6) positions[i3+2] = -Math.sign(positions[i3+2]) * 6;
                    }
                    
                    this.vortexParticles.geometry.attributes.position.needsUpdate = true;
                    
                    const isTargetInhale = breathPhase === 'inhale';
                    const inSync = (this.isHolding && isTargetInhale) || (!this.isHolding && !isTargetInhale);
                    
                    if (inSync) {
                        this.totalPresenceTime += deltaTime;
                    }
                    
                    stats.progress = Math.min(100, (this.totalPresenceTime / this.requiredTime) * 100);
                    stats.score = Math.round(stats.progress);
                    
                    if (this.group) {
                        this.group.rotation.y += 0.002;
                    }
                    
                    if (this.totalPresenceTime >= this.requiredTime) {
                        GameEngine.complete();
                    }
                } catch(e) {
                    console.error('Module6 update error:', e);
                }
            }
            
            cleanup() { 
                this.isActive = false;
                Sound.release('flow_pacer');
                
                const quoteEl = document.getElementById('game-intro-text');
                if (quoteEl) {
                    quoteEl.textContent = ''; 
                    quoteEl.style.top = '50%';
                    quoteEl.style.color = '';
                    quoteEl.style.textShadow = '';
                }

                document.removeEventListener('mousedown', this.onDown);
                document.removeEventListener('mouseup', this.onUp);
                document.removeEventListener('touchstart', this.onDown);
                document.removeEventListener('touchend', this.onUp);
                
                if (Visual.scene && this.group) {
                    Visual.scene.remove(this.group);
                }      
                
                const disposeMesh = (mesh) => {
                    if (mesh) {
                        if (mesh.geometry) mesh.geometry.dispose();
                        if (mesh.material) mesh.material.dispose();
                    }
                };
                disposeMesh(this.vortexParticles);
            }
        }
        
        function initUI() {
            const cursor = document.getElementById('cursor');
            
            document.addEventListener('mousemove', e => {
                cursor.style.transform = `translate(${e.clientX - 3}px, ${e.clientY - 3}px)`;
            });
            document.addEventListener('mousedown', () => cursor.classList.add('active'));
            document.addEventListener('mouseup', () => cursor.classList.remove('active'));
            
            document.querySelectorAll('.lang-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('.lang-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    Sound.play('click');
                    Haptic.selection();
                    I18N.set(btn.dataset.lang);
                });
            });
            
            const welcomeScreen = document.getElementById('welcome-screen');
            const startApp = async (e) => {
                if (e.target.closest('#lang-switch')) return;
                if (!welcomeScreen.classList.contains('active')) return;

                try {
                    await Tone.start();
                    Sound.init();
                    Sound.play('click');
                } catch(err) {
                    console.warn('Audio start error:', err);
                }
                
                welcomeScreen.removeEventListener('click', startApp);
                welcomeScreen.removeEventListener('touchstart', startApp);
                
                App.setState('INFO');
            };
            
            welcomeScreen.addEventListener('click', startApp);
            welcomeScreen.addEventListener('touchstart', startApp, { passive: true });
            
            document.getElementById('info-submit').addEventListener('click', () => {
                const name = document.getElementById('user-name').value.trim();
                const age = document.getElementById('user-age').value;
                const gender = document.getElementById('user-gender').value;
                const status = document.getElementById('user-status').value;
                
                App.patient = { name, age: parseInt(age) || null, gender: gender || 'unknown', status: status || 'unknown' };
                Sound.play('click');
                Haptic.light();
                App.setState('SCENT');
            });
            
            document.getElementById('scent-submit').addEventListener('click', () => {
                App.scents = { ...LumenScent.values };
                Sound.play('click');
                App.setState('MODULES');
            });
            
            document.getElementById('scent-prev').addEventListener('click', (e) => {
                e.stopPropagation();
                LumenScent.prevPage();
            });
            
            document.getElementById('scent-next').addEventListener('click', (e) => {
                e.stopPropagation();
                LumenScent.nextPage();
            });
            
            document.querySelectorAll('.page-dot').forEach(dot => {
                dot.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const page = parseInt(dot.dataset.page);
                    LumenScent.goToPage(page);
                    Sound.play('click');
                });
            });
            
            const tocSlider = document.getElementById('toc-slider');
            tocSlider.addEventListener('input', (e) => {
                App.tOC = parseInt(e.target.value);
                document.getElementById('toc-value').textContent = App.tOC;
                const pitch = `C${Math.floor(App.tOC / 20) + 3}`;
                Sound.play('slider', pitch, App.tOC / 120);
            });
            
            document.getElementById('back-btn').addEventListener('click', () => {
                document.getElementById('tutorial-overlay').classList.remove('active');
                
                const introTextEl = document.getElementById('game-intro-text');
                introTextEl.classList.remove('active-intro'); 
                
                if (GameEngine.module) {
                    GameEngine.module.cleanup();
                    GameEngine.module = null;
                }
                Sound.play('click');
                App.setState('MODULES');
            });
            
            document.getElementById('finish-btn').addEventListener('click', () => App.finish());
            document.getElementById('restart-btn').addEventListener('click', () => {
                App.resetAllResources();
                location.reload();
            });
            
            document.querySelectorAll('.btn, .module-cell').forEach(el => {
                el.addEventListener('mouseenter', () => Sound.play('hover'));
            });

            I18N.set(I18N.lang);
        }
        
        // CDN Fallback & Dependency Check
        function checkDependencies() {
            const missing = [];
            if (typeof THREE === 'undefined') missing.push('Three.js');
            if (typeof Tone === 'undefined') missing.push('Tone.js');
            if (typeof d3 === 'undefined') missing.push('D3.js');
            return missing;
        }

        function showFallbackError(missing) {
            document.body.innerHTML = `
                <div style="display: flex; align-items: center; justify-content: center; height: 100vh; flex-direction: column; font-family: Inter, sans-serif; padding: 2rem; text-align: center; background: #f5f5f0; color: #2a2a2a;">
                    <div style="max-width: 500px; padding: 2rem; background: white; border: 2px solid #c02625; box-shadow: 0 10px 40px rgba(0,0,0,0.1);">
                        <h1 style="font-size: 2rem; margin-bottom: 1rem; color: #c02625;">⚠️ Loading Error</h1>
                        <p style="margin-bottom: 1rem; line-height: 1.6;">Failed to load required libraries:</p>
                        <ul style="list-style: none; padding: 0; margin-bottom: 1.5rem; color: #c02625; font-weight: 500;">
                            ${missing.map(lib => `<li>• ${lib}</li>`).join('')}
                        </ul>
                        <p style="font-size: 0.9rem; color: #666; line-height: 1.5;">
                            Please check your internet connection and refresh the page.<br>
                            If the problem persists, the CDN may be temporarily unavailable.
                        </p>
                        <button onclick="location.reload()" style="margin-top: 1.5rem; padding: 0.8rem 2rem; background: #c02625; color: white; border: none; cursor: pointer; font-size: 0.9rem; text-transform: uppercase; letter-spacing: 0.1em;">
                            RETRY
                        </button>
                    </div>
                </div>
            `;
        }

        window.addEventListener('load', () => { 
            try {
                // Check if all dependencies loaded
                const missing = checkDependencies();
                if (missing.length > 0) {
                    console.error('Missing dependencies:', missing);
                    showFallbackError(missing);
                    return;
                }

                window.addEventListener('error', (e) => {
                    console.error('Global error:', e.error);
                    App.resetAllResources(); 
                    e.preventDefault();
                });
                
                window.addEventListener('unhandledrejection', (e) => {
                    console.error('Unhandled promise rejection:', e.reason);
                    App.resetAllResources(); 
                    e.preventDefault();
                });
                
                Visual.init();
                initUI();
                
                console.log('🌸 NeuroScent Bright Edition loaded');
                console.log('✨ Enhanced with improved modules');
            } catch(e) {
                console.error('Initialization error:', e);
                showFallbackError(['Application initialization']);
            }
        });
        
        window.addEventListener('beforeunload', (e) => {
            if (App.completed.size > 0 && App.state !== 'RESULTS') {
                e.preventDefault();
                e.returnValue = '';
            }
        });
    });
    </script>
</body>
</html>
